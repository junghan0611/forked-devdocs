<header><h1>Optional chaining</h1></header><div class="section-content">
<p><strong>optional chaining</strong> 연산자 (<code>?.</code>) 는 체인의 각 참조가 유효한지 명시적으로 검증하지 않고, 연결된 객체 체인 내에 깊숙이 위치한 속성 값을 읽을 수 있다.</p> <p><code>?.</code> 연산자는 <code>.</code> 체이닝 연산자와 유사하게 작동하지만, 만약 참조가 <a href="https://developer.mozilla.org/ko/docs/Glossary/Nullish">nullish</a> (<a href="null"><code>null</code></a> 또는 <a href="../global_objects/undefined"><code>undefined</code></a>)이라면, 에러가 발생하는 것 대신에 표현식의 리턴 값은 <code>undefined</code>로 단락된다. 함수 호출에서 사용될 때, 만약 주어진 함수가 존재하지 않는다면, <code>undefined</code>를 리턴한다.</p> <p>따라서 참조가 누락될 가능성이 있는 경우 연결된 속성으로 접근할 때 더 짧고 간단한 표현식이 생성된다. 어떤 속성이 필요한지에 대한 보증이 확실하지 않는 경우 객체의 내용을 탐색하는 동안 도움이 될 수 있다.</p> <p>optional chaining은 선언되지 않은 루트 객체에 사용할 수 없지만, 정의되지 않은 루트 객체와는 함께 사용할 수 있다.</p>
</div>
<section aria-labelledby="시도해보기"><h2 id="시도해보기">시도해보기</h2>
<div class="section-content"><iframe class="interactive is-js-height" height="200" src="https://interactive-examples.mdn.mozilla.net/pages/js/expressions-optionalchainingoperator.html" title="MDN Web Docs Interactive Example" loading="lazy"></iframe></div></section><section aria-labelledby="문법"><h2 id="문법">문법</h2>
<div class="section-content"><div class="code-example">
<p class="example-header"><span class="language-name">js</span></p>
<pre data-signature="SoCcYl8m00LFrHFJ0SyoovHpb0q9MZfCHhnlJAv+BrE=" data-language="js">    obj<span class="token operator">?.</span>prop
    obj<span class="token operator">?.</span><span class="token punctuation">[</span>expr<span class="token punctuation">]</span>
    arr<span class="token operator">?.</span><span class="token punctuation">[</span>index<span class="token punctuation">]</span>
    func<span class="token operator">?.</span><span class="token punctuation">(</span>args<span class="token punctuation">)</span>
</pre>
</div></div></section><section aria-labelledby="설명"><h2 id="설명">설명</h2>
<div class="section-content">
<p>optional chaining 연산자는 참조나 기능이 <code>undefined</code> 또는 <code>null</code>일 수 있을 때 연결된 객체의 값에 접근하는 단순화할 수 있는 방법을 제공한다.</p> <p>예를 들어, 중첩된 구조를 가진 객체에서 <code>obj</code>가 있다. optional chaining이 없이 깊이 중첩된 하위 속성을 찾으려면, 다음과 같이 참조를 확인해야 한다:</p> <div class="code-example">
<p class="example-header"><span class="language-name">js</span></p>
<pre data-signature="cvBXwaKIjbVYbHdd8uTtMMk1XC9bmAFu+Mw8SfNM+nY=" data-language="js"><span class="token keyword">let</span> nestedProp <span class="token operator">=</span> obj<span class="token punctuation">.</span>first <span class="token operator">&amp;&amp;</span> obj<span class="token punctuation">.</span>first<span class="token punctuation">.</span>second<span class="token punctuation">;</span>
</pre>
</div> <p><code>obj.first</code>의 값은 <code>obj.first.second</code>의 값에 접근하기 전에 <code>null</code> (그리고 <code>undefined</code>)가 아니라는 점을 검증한다. 이는 만약에 <code>obj.first</code>를 테스트 없이 <code>obj.first.second</code> 에 직접 접근할 때 일어날 수 있는 에러를 방지한다.</p> <p>그러나 optional chaining 연산자(<code>?.</code>)를 사용하여, <code>obj.first.second</code> 에 접근하기 전에 <code>obj.first</code>의 상태에 따라 명시적으로 테스트하거나 단락시키지 않아도 된다:</p> <div class="code-example">
<p class="example-header"><span class="language-name">js</span></p>
<pre data-signature="uXo7Z7YZTlayWKNWuApl6mX3Aju1K+ZdTk8qoCVNGJ4=" data-language="js"><span class="token keyword">let</span> nestedProp <span class="token operator">=</span> obj<span class="token punctuation">.</span>first<span class="token operator">?.</span>second<span class="token punctuation">;</span>
</pre>
</div> <p><code>.</code> 대신에 <code>?.</code> 연산자를 사용함으로써, 자바스크립트는 <code>obj.first.second</code>에 접근하기 전에 <code>obj.first</code>가 <code>null</code> 또는 <code>undefined</code>가 아니라는 것을 암묵적으로 확인하는 것을 알고 있다. 만약 <code>obj.first</code>가 <code>null</code> 또는 <code>undefined</code>이라면, 그 표현식은 자동으로 단락되어 <code>undefined</code>가 반환된다.</p> <p>이는 임시 변수가 실제로 생성되지 않는다는 점을 제외하고 다음과 동일하다.</p> <div class="code-example">
<p class="example-header"><span class="language-name">js</span></p>
<pre data-signature="xD8RA26PVo1gXG0fXf1KJP6J+mFadzHbAvqi1DX2uiQ=" data-language="js"><span class="token keyword">let</span> temp <span class="token operator">=</span> obj<span class="token punctuation">.</span>first<span class="token punctuation">;</span>
<span class="token keyword">let</span> nestedProp <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>temp <span class="token operator">===</span> <span class="token keyword">null</span> <span class="token operator">||</span> temp <span class="token operator">===</span> <span class="token keyword">undefined</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token keyword">undefined</span> <span class="token operator">:</span> temp<span class="token punctuation">.</span>second<span class="token punctuation">)</span><span class="token punctuation">;</span>
</pre>
</div>
</div></section><section aria-labelledby="함수의_호출과_optional_chaining"><h3 id="함수의_호출과_optional_chaining">함수의 호출과 Optional chaining</h3>
<div class="section-content">
<p>존재하지 않을 수 있는 매서드를 호출할 때, optional chaining을 사용할 수 있다. 예를 들어, 구현 기간이나 사용자 장치에서 사용할 수 없는 기능 때문에 메서드를 사용할 수 없는 API를 사용할 경우, 유용할 수 있다.</p> <p>함수 호출과 optional chaining을 사용함으로써 메서드를 찾을 수 없는 경우에 예외를 발생시키는 것 대신에 그 표현식은 자동으로 <code>undefined</code>를 반환한다:</p> <div class="code-example">
<p class="example-header"><span class="language-name">js</span></p>
<pre data-signature="+QVMSquuoiTl8ur4fCGk9QCTBVXdWWqNpqHUd0NqMHw=" data-language="js"><span class="token keyword">let</span> result <span class="token operator">=</span> someInterface<span class="token punctuation">.</span>customMethod<span class="token operator">?.</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</pre>
</div> <div class="note notecard" id="sect1"> <p><strong>메모:</strong> 만약 속성에 해당 이름이 있지만 함수가 아니라면, <code>?.</code>의 사용은 여전히 예외를 발생시킨다. <a href="../global_objects/typeerror"><code>TypeError</code></a> exception (<code>x.y</code><code> is not a function</code>).</p> </div> <div class="note notecard" id="sect2"> <p><strong>메모:</strong> 만약 <code>someInterface</code> 자체가 <code>null</code>이나 <code>undefined</code>이면, <code>TypeError</code> 예외가 여전히 발생 할 것이다. <code>someInterface</code> 자체가 <code>null</code>이나 <code>undefined</code>으로 예상된다면, <code>?.</code>을 사용해야한다: <code>someInterface?.customMethod?.()</code></p> </div> <h4 id="optional_callbacks과_event_handlers_다루기">optional callbacks과 event handlers 다루기</h4> <p>만약 객체에서 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment#object_destructuring">destructuring assignment</a>로 callbacks 또는 fetch 메서드를 사용한다면, 그 존재 여부를 테스트하지 않으면 함수로 호출할 수 없는 존재 하지 않는 값을 가질 수 있다. <code>?.</code>을 사용하면, 다음 추가 테스트를 피할 수 있다:</p> <div class="code-example">
<p class="example-header"><span class="language-name">js</span></p>
<pre data-signature="L2dPT/OzHe5mF5Z3TfvdSZWcdnNLLBYM6GKP9AmBolM=" data-language="js"><span class="token comment">// Written as of ES2019</span>
<span class="token keyword">function</span> <span class="token function">doSomething</span><span class="token punctuation">(</span><span class="token parameter">onContent<span class="token punctuation">,</span> onError</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">try</span> <span class="token punctuation">{</span>
    <span class="token comment">// ... do something with the data</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">catch</span> <span class="token punctuation">(</span>err<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>onError<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// Testing if onError really exists</span>
      <span class="token function">onError</span><span class="token punctuation">(</span>err<span class="token punctuation">.</span>message<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</pre>
</div> <div class="code-example">
<p class="example-header"><span class="language-name">js</span></p>
<pre data-signature="fqKtl9TgqIFmzY2kd8W2gviLetxfBOTbWzPBiWNSmCY=" data-language="js"><span class="token comment">// Using optional chaining with function calls</span>
<span class="token keyword">function</span> <span class="token function">doSomething</span><span class="token punctuation">(</span><span class="token parameter">onContent<span class="token punctuation">,</span> onError</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">try</span> <span class="token punctuation">{</span>
   <span class="token comment">// ... do something with the data</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">catch</span> <span class="token punctuation">(</span>err<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    onError<span class="token operator">?.</span><span class="token punctuation">(</span>err<span class="token punctuation">.</span>message<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// no exception if onError is undefined</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</pre>
</div>
</div></section><section aria-labelledby="표현식에서_optional_chaining"><h3 id="표현식에서_optional_chaining">표현식에서 Optional chaining</h3>
<div class="section-content">
<p>optional chaining 연산자를 속성에 표현식으로 접근할 때 대괄호 표기법(<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Property_accessors#bracket_notation">the bracket notation of the property accessor</a>)을 사용할 수 있다:</p> <div class="code-example">
<p class="example-header"><span class="language-name">js</span></p>
<pre data-signature="ZP8EN1C16zTXXpteUHFjB4hEaeFH4+3+/P76rm/EwyM=" data-language="js"><span class="token keyword">let</span> nestedProp <span class="token operator">=</span> obj<span class="token operator">?.</span><span class="token punctuation">[</span><span class="token string">'prop'</span> <span class="token operator">+</span> <span class="token string">'Name'</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
</pre>
</div>
</div></section><section aria-labelledby="optional_chaining은_할당자_왼쪽에서_유효하지_않습니다"><h3 id="optional_chaining은_할당자_왼쪽에서_유효하지_않습니다">Optional chaining은 할당자 왼쪽에서 유효하지 않습니다.</h3>
<div class="section-content"><div class="code-example">
<p class="example-header"><span class="language-name">js</span></p>
<pre data-signature="4IBkk7DqpwLw1ovD8R1tWTjdtrF7LWeuoLUoTKnjkp4=" data-language="js"><span class="token keyword">let</span> object <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
object<span class="token operator">?.</span>property <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">// Uncaught SyntaxError: Invalid left-hand side in assignment</span>
</pre>
</div></div></section><section aria-labelledby="optional_chaining으로_배열_항목에_접근하기"><h3 id="optional_chaining으로_배열_항목에_접근하기">Optional chaining으로 배열 항목에 접근하기</h3>
<div class="section-content"><div class="code-example">
<p class="example-header"><span class="language-name">js</span></p>
<pre data-signature="eFfWnGCcyJ3tzuzAz5Wk326yhTxtI1GiCwbXz/ntiak=" data-language="js"><span class="token keyword">let</span> arrayItem <span class="token operator">=</span> arr<span class="token operator">?.</span><span class="token punctuation">[</span><span class="token number">42</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
</pre>
</div></div></section><section aria-labelledby="예제"><h2 id="예제">예제</h2>
</section><section aria-labelledby="기본_예제"><h3 id="기본_예제">기본 예제</h3>
<div class="section-content">
<p>이 예제는 해당 멤버가 없을 때, map에서 멤버 bar의 <code>name</code>의 속성 값을 찾는다. 그러므로 결과는 <code>undefined</code>이다.</p> <div class="code-example">
<p class="example-header"><span class="language-name">js</span></p>
<pre data-signature="emplRjlgE9gzHZnp7ZB32Ju4GK9QaBBI+HpML0129IM=" data-language="js"><span class="token keyword">let</span> myMap <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Map</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
myMap<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token string">"foo"</span><span class="token punctuation">,</span> <span class="token punctuation">{</span><span class="token literal-property property">name</span><span class="token operator">:</span> <span class="token string">"baz"</span><span class="token punctuation">,</span> <span class="token literal-property property">desc</span><span class="token operator">:</span> <span class="token string">"inga"</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">let</span> nameBar <span class="token operator">=</span> myMap<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">"bar"</span><span class="token punctuation">)</span><span class="token operator">?.</span>name<span class="token punctuation">;</span>
</pre>
</div>
</div></section><section aria-labelledby="단락_평가"><h3 id="단락_평가">단락 평가</h3>
<div class="section-content">
<p>표현식에서 optional chaining을 사용할 때, 만약 왼쪽에 있는 피연산자가 <code>null</code> or <code>undefined</code>인 경우, 그 표현식은 평가되지 않는다. 예들 들어:</p> <div class="code-example">
<p class="example-header"><span class="language-name">js</span></p>
<pre data-signature="g3dUKxinl9lVmQec+BaAFkBw8c3g3p3oMhqGukqY14s=" data-language="js"><span class="token keyword">let</span> potentiallyNullObj <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> x <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> prop <span class="token operator">=</span> potentiallyNullObj<span class="token operator">?.</span><span class="token punctuation">[</span>x<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>

console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 0  x는 증가하지 않음</span>
</pre>
</div>
</div></section><section aria-labelledby="optional_chaining_연산자_쌓기"><h3 id="optional_chaining_연산자_쌓기">optional chaining 연산자 쌓기</h3>
<div class="section-content">
<p>중첩된 구조에서는 optional chaining을 여러 번 사용할 수 있다:</p> <div class="code-example">
<p class="example-header"><span class="language-name">js</span></p>
<pre data-signature="y7lGtqTCOMTzHxSLkaKbZA9p205R0KW66cS0WzMOguI=" data-language="js"><span class="token keyword">let</span> customer <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token literal-property property">name</span><span class="token operator">:</span> <span class="token string">"Carl"</span><span class="token punctuation">,</span>
  <span class="token literal-property property">details</span><span class="token operator">:</span> <span class="token punctuation">{</span>
    <span class="token literal-property property">age</span><span class="token operator">:</span> <span class="token number">82</span><span class="token punctuation">,</span>
    <span class="token literal-property property">location</span><span class="token operator">:</span> <span class="token string">"Paradise Falls"</span> <span class="token comment">// detailed address is unknown</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> customerCity <span class="token operator">=</span> customer<span class="token punctuation">.</span>details<span class="token operator">?.</span>address<span class="token operator">?.</span>city<span class="token punctuation">;</span>

<span class="token comment">// … this also works with optional chaining function call</span>
<span class="token keyword">let</span> duration <span class="token operator">=</span> vacations<span class="token punctuation">.</span>trip<span class="token operator">?.</span>getTime<span class="token operator">?.</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</pre>
</div>
</div></section><section aria-labelledby="널_병합_연산자와_같이_사용하기"><h3 id="널_병합_연산자와_같이_사용하기">널 병합 연산자와 같이 사용하기</h3>
<div class="section-content">
<p>널 병합 연산자는 optional chaining를 사용한 후에 아무 값도 찾을 수 없을 때 기본 값을 주기 위해 사용될 수 있다:</p> <div class="code-example">
<p class="example-header"><span class="language-name">js</span></p>
<pre data-signature="CjeyuBuzCvk+O+GqBeDcOPy4hkqCSEVBHQJxoXWSV4A=" data-language="js"><span class="token keyword">let</span> customer <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token literal-property property">name</span><span class="token operator">:</span> <span class="token string">"Carl"</span><span class="token punctuation">,</span>
  <span class="token literal-property property">details</span><span class="token operator">:</span> <span class="token punctuation">{</span> <span class="token literal-property property">age</span><span class="token operator">:</span> <span class="token number">82</span> <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> customerCity <span class="token operator">=</span> customer<span class="token operator">?.</span>city <span class="token operator">??</span> <span class="token string">"Unknown city"</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>customerCity<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Unknown city</span>
</pre>
</div>
</div></section><h2 id="명세서">명세서</h2>
<div class="_table"><table class="standard-table">
<thead><tr><th scope="col">Specification</th></tr></thead>
<tbody><tr><td><a href="https://tc39.es/ecma262/multipage/ecmascript-language-expressions.html#prod-OptionalExpression">ECMAScript Language Specification <br><small># prod-OptionalExpression</small></a></td></tr></tbody>
</table></div>
<h2 id="브라우저_호환성">브라우저 호환성</h2>
<p>BCD tables only load in the browser<noscript> with JavaScript enabled. Enable JavaScript to view data.</noscript></p>
<section aria-labelledby="참고"><h2 id="참고">참고</h2>
<div class="section-content"><ul> <li>The <a href="nullish_coalescing">Nullish Coalescing Operator</a>
</li> <li><a href="https://github.com/tc39/proposals" target="_blank">TC39 proposals</a></li> </ul></div></section><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2005&ndash;2023 MDN contributors.<br>Licensed under the Creative Commons Attribution-ShareAlike License v2.5 or later.<br>
    <a href="https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Operators/Optional_chaining" class="_attribution-link">https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Operators/Optional_chaining</a>
  </p>
</div>
