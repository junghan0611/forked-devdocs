{"index":"<h1>TypeScript Documentation</h1>\n<div class=\"main-content-block container handbook-content\"><div class=\"columns wide\">\n<div class=\"item raised\">\n<h2>Get Started</h2>\n<p>Quick introductions based on your background or preference.</p>\n<ul>\n<li><a href=\"typescript-from-scratch\">TS for the New Programmer</a></li>\n<li><a href=\"typescript-in-5-minutes\">TypeScript for JS Programmers</a></li>\n<li><a href=\"typescript-in-5-minutes-oop\">TS for Java/C# Programmers</a></li>\n<li><a href=\"typescript-in-5-minutes-func\">TS for Functional Programmers</a></li>\n<li><a href=\"typescript-tooling-in-5-minutes\">TypeScript Tooling in 5 minutes</a></li>\n</ul>\n</div>\n<div class=\"item raised\">\n<h2>Handbook</h2>\n<p>A great first read for your daily TS work.</p>\n<ul>\n<li><a href=\"intro\">The TypeScript Handbook</a></li>\n<li><a href=\"2/basic-types\">The Basics</a></li>\n<li><a href=\"2/everyday-types\">Everyday Types</a></li>\n<li><a href=\"https://www.typescriptlang.org/docs/handbook/2/narrowing.html\">Narrowing</a></li>\n<li><a href=\"2/functions\">More on Functions</a></li>\n<li><a href=\"https://www.typescriptlang.org/docs/handbook/2/objects.html\">Object Types</a></li>\n<li><a href=\"https://www.typescriptlang.org/docs/handbook/2/classes.html\">Classes</a></li>\n<li><a href=\"https://www.typescriptlang.org/docs/handbook/2/modules.html\">Modules</a></li>\n</ul>\n</div>\n<div class=\"item raised\">\n<h2>Reference</h2>\n<p>Deep dive reference materials.</p>\n<ul>\n<li><a href=\"utility-types\">Utility Types</a></li>\n<li><a href=\"https://www.typescriptlang.org/cheatsheets\">Cheat Sheets</a></li>\n<li><a href=\"decorators\">Decorators</a></li>\n<li><a href=\"declaration-merging\">Declaration Merging</a></li>\n<li><a href=\"enums\">Enums</a></li>\n<li><a href=\"iterators-and-generators\">Iterators and Generators</a></li>\n<li><a href=\"jsx\">JSX</a></li>\n<li><a href=\"https://www.typescriptlang.org/docs/handbook/mixins.html\">Mixins</a></li>\n<li><a href=\"https://www.typescriptlang.org/docs/handbook/esm-node.html\">ECMAScript Modules in Node.js</a></li>\n<li><a href=\"modules\">Modules</a></li>\n<li><a href=\"module-resolution\">Module Resolution</a></li>\n<li><a href=\"namespaces\">Namespaces</a></li>\n<li><a href=\"namespaces-and-modules\">Namespaces and Modules</a></li>\n<li><a href=\"symbols\">Symbols</a></li>\n<li><a href=\"triple-slash-directives\">Triple-Slash Directives</a></li>\n<li><a href=\"type-compatibility\">Type Compatibility</a></li>\n<li><a href=\"type-inference\">Type Inference</a></li>\n<li><a href=\"variable-declarations\">Variable Declaration</a></li>\n</ul>\n</div>\n<div class=\"item raised\">\n<h2>Tutorials</h2>\n<p>Using TypeScript in several environments.</p>\n<ul>\n<li><a href=\"asp-net-core\">ASP.NET Core</a></li>\n<li><a href=\"gulp\">Gulp</a></li>\n<li><a href=\"dom-manipulation\">DOM Manipulation</a></li>\n<li><a href=\"migrating-from-javascript\">Migrating from JavaScript</a></li>\n<li><a href=\"babel-with-typescript\">Using Babel with TypeScript</a></li>\n</ul>\n</div>\n<div class=\"item raised\">\n<h2>Declaration Files</h2>\n<p>Learn how to write declaration files to describe existing JavaScript. Important for DefinitelyTyped contributions.</p>\n<ul>\n<li><a href=\"declaration-files/introduction\">Introduction</a></li>\n<li><a href=\"declaration-files/by-example\">Declaration Reference</a></li>\n<li><a href=\"declaration-files/library-structures\">Library Structures</a></li>\n<li><a href=\"declaration-files/do-s-and-don-ts\">Do's and Don'ts</a></li>\n<li><a href=\"declaration-files/deep-dive\">Deep Dive</a></li>\n<li><a href=\"declaration-files/publishing\">Publishing</a></li>\n<li><a href=\"declaration-files/consumption\">Consumption</a></li>\n</ul>\n</div>\n<div class=\"item raised\">\n<h2>JavaScript</h2>\n<p>How to use TypeScript-powered JavaScript tooling.</p>\n<ul>\n<li><a href=\"intro-to-js-ts\">JS Projects Utilizing TypeScript</a></li>\n<li><a href=\"type-checking-javascript-files\">Type Checking JavaScript Files</a></li>\n<li><a href=\"jsdoc-supported-types\">JSDoc Reference</a></li>\n<li><a href=\"declaration-files/dts-from-js\">Creating .d.ts Files from .js files</a></li>\n</ul>\n</div>\n<div class=\"item raised\">\n<h2>Project Configuration</h2>\n<p>Compiler configuration reference.</p>\n<ul>\n<li><a href=\"tsconfig-json\">What is a tsconfig.json</a></li>\n<li><a href=\"compiler-options-in-msbuild\">Compiler Options in MSBuild</a></li>\n<li><a href=\"https://www.typescriptlang.org/tsconfig\">TSConfig Reference</a></li>\n<li><a href=\"compiler-options\">tsc CLI Options</a></li>\n<li><a href=\"project-references\">Project References</a></li>\n<li><a href=\"integrating-with-build-tools\">Integrating with Build Tools</a></li>\n<li><a href=\"configuring-watch\">Configuring Watch</a></li>\n<li><a href=\"nightly-builds\">Nightly Builds</a></li>\n</ul>\n</div>\n</div></div><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2012-2023 Microsoft<br>Licensed under the Apache License, Version 2.0.<br>\n    <a href=\"https://www.typescriptlang.org/ko/docs/handbook/\" class=\"_attribution-link\">https://www.typescriptlang.org/ko/docs/handbook/</a>\n  </p>\n</div>\n","typescript-from-scratch":"<h1>TypeScript for the New Programmer</h1>\n<p>첫 번째 언어로 TypeScript를 고른것을 축하드립니다 - 정말로 좋은 결정입니다!</p> <p>Typescript가 Javascript의 “기호(flavor)“나 “변형(variant)“이라는 것을 들어봤을 겁니다. TypeScript(TS)와 JavaScript(JS)의 관계는 현대 프로그래밍 언어에서 꽤 독특한 관계이니, 이 관계를 더 배우는 것은 어떻게 TypeScript를 JavaScript에 추가할지에 도움이 될 것입니다.</p> <h2 id=\"javascript의-짧은-역사-what-is-javascript-a-brief-history\" style=\"position:relative;\">JavaScript의 짧은 역사 (What is JavaScript? A Brief History)</h2> <p>JavaScript(ECMAScript으로도 알려져있는)는 처음에 브라우저를 위한 스크립팅 언어로 만들어졌습니다. JavaScript가 처음 나왔을 때, 수십 줄 이상의 코드를 작성하는 것은 다소 이례적인 일이었기에 웹 페이지 속 짧은 코드들을 위해 사용할 것으로 여겨졌습니다. 때문에, 초기 웹 브라우저들은 수십 줄 이상의 코드를 실행하는데 오래 걸렸습니다. 그러나 시간이 흘러 JS가 점점 더 유명해지면서, 웹 개발자들은 JS를 이용해 상호작용을 하는 경험을 하기 시작했습니다.</p> <p>웹 브라우저 개발자들은 위와 같이 늘어나는 JS 사용량에 대하여 실행 엔진(동적 컴파일)을 최적화시키고 최적화 된 것을 이용해 할 수 있는 일(API 추가)을 확장하여 웹 개발자가 더 많이 JS를 사용할 수 있게 했습니다. 현대 웹사이트에서, 브라우저는 수십만 줄의 코드로 구성된 어플리케이션을 자주 실행합니다. 이는 정적 페이지의 간단한 네트워크로 시작해서, 모든 종류의 만족스러울만한 <em>어플리케이션</em>을 위한 플랫폼으로 성장한 “웹”의 길고 점진적인 성장입니다.</p> <p>이외에도, JS는 node.js를 사용하여 JS 서버들을 구현하는 것처럼, 브라우저 맥락에서 벗어나는 일에 사용하기 충분할 정도로 유명해졌습니다. “어디서든 작동됨”과 같은 JS의 성질은 교차 플랫폼(cross-platform) 개발을 위한 매력적인 선택지이기도 합니다. 오늘날 많은 개발자들은 <em>오직</em> JavaScript만을 이용하여 전체 스택을 프로그래밍하고 있습니다!</p> <p>요약하자면, 우리에게는 빠른 사용을 위해 설계되었으며 수백만 줄의 어플리케이션들을 작성하기 위해 만들어진 완벽한 도구인 JavaScript가 있습니다. 모든 언어는 각자의 <em>별난 점</em> - 이상한 점과 놀랄만한 점이 있으며, JavaScript의 자랑스럽지만은 않은 시작은 <em>많은</em> 문제를 만들게 되었습니다. 예를 들어:</p> <ul> <li> <p>JavaScript의 동일 연산자는 (<code>==</code>) 인수를 <em>강제로 변환하여(coerces)</em>, 예기치 않은 동작을 유발합니다:</p> <pre data-language=\"js\">if (\"\" == 0) {\n  // 참입니다! 근데 왜죠??\n}\nif (1 &lt; x &lt; 3) {\n  // *어떤* x 값이던 참입니다!\n}</pre> </li> <li> <p>JavaScript는 또한 존재하지 않는 프로퍼티의 접근을 허용합니다:</p> <pre data-language=\"js\">const obj = { width: 10, height: 15 };\n// 왜 이게 NaN이죠? 철자가 어렵네요!\nconst area = obj.width * obj.heigth;</pre> </li> </ul> <p>대부분의 프로그래밍 언어는 이런 종류의 오류들이 발생하면 오류를 표출해주고, 일부는 코드가 실행되기 전인 컴파일 중에 오류를 표출해줍니다. 작은 프로그램을 작성할 때에는, 이런 이상한 점들이 화를 돋구지만 관리는 가능합니다. 그러나 수백 또는 수천 줄의 어플리케이션들을 작성할 때에는, 이러한 지속적 놀라움들은 심각한 문제입니다.</p> <h2 id=\"typescript-정적-타입-검사자-typescript-a-static-type-checker\" style=\"position:relative;\">TypeScript: 정적 타입 검사자 (TypeScript: A Static Type Checker)</h2> <p>앞서 몇 언어는 버그가 많은 프로그램을 아예 실행시키지 않는다고 했습니다. 프로그램을 실행시키지 않으면서 코드의 오류를 검출하는 것을 <em>정적 검사</em>라고 합니다. 어떤 것이 오류인지와 어떤 것이 연산 되는 값에 기인하지 않음을 정하는 것이 정적 <em>타입</em> 검사입니다.</p> <p><em>정적 타입 검사자</em>인 TypeScript는 프로그램을 실행시키기 전에 <em>값의 종류</em>를 기반으로 프로그램의 오류를 찾습니다. 예를 들어, 위의 마지막 예시에 오류가 있는 이유는 <code>obj</code>의 <em>타입</em> 때문입니다. 다음은 TypeScript에서 볼 수 있는 오류입니다:</p> <pre data-language=\"typescript\">// @errors: 2551\nconst obj = { width: 10, height: 15 };\nconst area = obj.width * obj.heigth;</pre> <h3 id=\"타입이-있는-javascript의-상위-집합-a-typed-superset-of-javascript\" style=\"position:relative;\">타입이 있는 JavaScript의 상위 집합 (A Typed Superset of JavaScript)</h3> <p>그렇다면 TypeScript는 JavaScript와 어떤 관계일까요?</p> <h4 id=\"구문-syntax\" style=\"position:relative;\">구문 (Syntax)</h4> <p>TypeScript는 JS의 구문이 허용되는, JavaScript의 <em>상위 집합</em> 언어입니다. 구문은 프로그램을 만들기 위해 코드를 작성하는 방법을 의미합니다. 예를 들어, 다음 코드는 <code>)</code>이 없으므로 <em>구문</em> 오류입니다:</p> <pre data-language=\"typescript\">// @errors: 1005\nlet a = (4</pre> <p>TypeScript는 독특한 구문 때문에 JavaScript 코드를 오류로 보지 않습니다. 즉, 어떻게 작성돼있는지 모르지만 작동하는 JavaScript 코드를 TypeScript 파일에 넣어도 잘 작동합니다.</p> <h4 id=\"타입-types\" style=\"position:relative;\">타입 (Types)</h4> <p>그러나 TypeScript는 다른 종류의 값들을 사용할 수 있는 방법이 추가된, <em>타입이 있는</em> 상위 집합입니다. 위의 <code>obj.heigth</code> 오류는 <em>구문</em> 오류가 아닌, 값의 종류(<em>타입</em>)를 잘못 사용해서 생긴 오류입니다.</p> <p>또 다른 예시로, 아래와 같은 JavaScript 코드가 브라우저에서 실행될 때, 다음과 같은 값이 출력될 <em>것입니다</em>:</p> <pre data-language=\"js\">console.log(4 / []);</pre> <p>구문적으로 옳은(syntactically-legal) 위 코드는 JavaScript에서 <code>NaN</code>을 출력합니다. 그러나 TypeScript는 배열로 숫자를 나누는 연산이 옳지 않다고 판단하고 오류를 발생시킵니다:</p> <pre data-language=\"typescript\">// @errors: 2363\nconsole.log(4 / []);</pre> <p>실제로 어떤 일이 일어나는지 보려는 의도로 숫자를 배열로 나눌 수 <em>있지만</em>, 대부분은 프로그래밍 실수입니다. TypeScript의 타입 검사자는 일반적인 오류를 최대한 많이 검출하면서 올바른 프로그램을 만들 수 있게 설계되었습니다. (나중에 TypeScript가 코드를 얼마나 엄격하게 검사할 수 있는지에 대한 설정에 대해 알아봅시다.)</p> <p>만약 JavaScript 파일의 코드를 TypeScript 코드로 옮기면, 코드를 어떻게 작성했는지에 따라 <em>타입 오류</em>를 볼 수 있습니다. 이는 코드 상의 문제이거나, TypeScript가 지나치게 보수적인 것일 수 있습니다. 위와 같은 오류를 제거하기 위해 가이드는 다양한 TypeScript 구문을 추가하는 방법을 보여줍니다.</p> <h4 id=\"런타임-특성-runtime-behavior\" style=\"position:relative;\">런타임 특성 (Runtime Behavior)</h4> <p>TypeScript는 JavaScript의 <em>런타임 특성</em>을 가진 프로그래밍 언어입니다. 예를 들어, JavaScript에서 0으로 나누는 행동은 런타임 예외로 처리하지 않고 <code>Infinity</code>값을 반환합니다. 논리적으로, TypeScript는 JavaScript 코드의 런타임 특성을 <strong>절대</strong> 변화시키지 않습니다.</p> <p>즉 TypeScript가 코드에 타입 오류가 있음을 검출해도, JavaScript 코드를 TypeScript로 이동시키는 것은 같은 방식으로 실행시킬 것을 <strong>보장합니다</strong></p> <p>JavaScript와 동일한 런타임 동작을 유지하는 것은 프로그램 작동을 중단시킬 수 있는 미묘한 차이를 걱정하지 않고 두 언어 간에 쉽게 전환할 수 있도록 하기 위한 TypeScript의 기본적인 약속입니다.</p>  <h4 id=\"삭제된-타입-erased-types\" style=\"position:relative;\">삭제된 타입 (Erased Types)</h4> <p>개략적으로, TypeScript의 컴파일러가 코드 검사를 마치면 타입을 <em>삭제해서</em> 결과적으로 “컴파일된” 코드를 만듭니다. 즉 코드가 한 번 컴파일되면, 결과로 나온 일반 JS 코드에는 타입 정보가 없습니다.</p> <p>타입 정보가 없는 것은 TypeScript가 추론한 타입에 따라 프로그램의 <em>특성</em>을 변화시키지 않는다는 의미입니다. 결론적으로 컴파일 도중에는 타입 오류가 표출될 수 있지만, 타입 시스템 자체는 프로그램이 실행될 때 작동하는 방식과 관련이 없습니다.</p> <p>마지막으로, TypeScript는 추가 런타임 라이브러리를 제공하지 않습니다. TypeScript는 프로그램은 JavaScript 프로그램과 같은 표준 라이브러리 (또는 외부 라이브러리)를 사용하므로, TypeScript 관련 프레임워크를 추가로 공부할 필요가 없습니다.</p>  <h2 id=\"javascript와-typescript-학습-learning-javascript-and-typescript\" style=\"position:relative;\">JavaScript와 TypeScript 학습 (Learning JavaScript and TypeScript)</h2> <p>종종 “JavaScript 또는 TypeScript를 배워야 할까요?”와 같은 질문을 볼 수 있습니다.</p> <p>정답은 JavaScript를 배우지 않고선 TypeScript를 배울 수 없다는 것입니다! TypeScript는 JavaScript와 구문과 런타임 특성을 공유하므로, JavaScript에서 배운 모든 것들은 동시에 TypeScript를 배울 때 도움이 될 것입니다.</p> <p>프로그래머들을 위한 JavaScript 학습 자원이 많습니다; TypeScript를 작성할 때 그런 학습 자원을 무시해선 <em>안됩니다</em>. 예를 들어 <code>javascript</code>태그가 붙은 질문이 <code>typescript</code>태그가 붙은 질문보다 약 20배는 많지만, <em>모든</em> <code>javascript</code>질문은 TypeScript에도 적용할 수 있습니다.</p> <p>만약 “TypeScript에서 리스트를 정렬하는 법”과 같은 것을 찾는 경우, 기억하세요: <strong>TypeScript는 컴파일-타임 타입 검사자가 있는 JavaScript의 런타임입니다</strong>. 리스트를 TypeScript에서 정렬하는 방법은 JavaScript에서 똑같은 방법으로 할 수 있습니다. 만약 TypeScript를 직접적으로 사용하는 자원을 찾았다면 그것도 좋지만, 런타임 작업을 실행하기 위한 일상적인 질문을 TypeScript 관련 답변에만 제한시킬 필요는 없습니다.</p> <hr> <p>여기서, JavaScript 기초 몇 가지를 배우는 것을 추천합니다 (<a href=\"https://developer.mozilla.org/docs/Web/JavaScript/Guide\">Mozilla 웹 문서의 JavaScript 가이드</a>가 괜찮겠네요.)</p> <p>익숙해지셨다면, 다시 돌아와서 <a href=\"https://www.typescriptlang.org/docs/handbook/typescript-in-5-minutes.html\">JavaScript 프로그래머들을 위한 TypeScript</a>을 읽어보시고, <a href=\"https://www.typescriptlang.org/docs/handbook/intro.html\">핸드북</a>을 시작하시거나 <a href=\"https://www.typescriptlang.org/play#show-examples\">예제</a>를 보세요.</p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2012-2023 Microsoft<br>Licensed under the Apache License, Version 2.0.<br>\n    <a href=\"https://www.typescriptlang.org/ko/docs/handbook/typescript-from-scratch.html\" class=\"_attribution-link\">https://www.typescriptlang.org/ko/docs/handbook/typescript-from-scratch.html</a>\n  </p>\n</div>\n","triple-slash-directives":"<h1>Triple-Slash Directives</h1>\n<p>트리플-슬래시 지시어는 단일 XML 태그를 포함한 한 줄 주석입니다. 주석의 내용은 컴파일러 지시어로 사용됩니다.</p> <p>트리플-슬래시 지시어는 <strong>오직</strong> 포함된 파일의 상단에서만 유효합니다. 다른 트리플-슬래시 지시어를 포함한 트리플-슬래시 지시어는 한 줄 또는 여러 줄 주석 앞에만 있을 수 있습니다. 만약 문이나 선언 뒤에 나오면 보통 한 줄 주석으로 여겨지며 어떤 특별한 의미도 갖지 않습니다.</p> <h2 id=\"-reference-path-\" style=\"position:relative;\"><code>/// &lt;reference path=\"...\" /&gt;</code></h2> <p><code>/// &lt;reference path=\"...\" /&gt;</code>지시어는 가장 일반적인 트리플-슬래시 지시어입니다. 이 지시어는 파일 간의 <em>의존성</em> 선언으로 사용됩니다.</p> <p>트리플-슬래시 참조는 컴파일러에게 추가 파일을 컴파일 과정에 포함할 것을 지시합니다.</p> <p>또한 <code>--out</code>이나 <code>--outFile</code>을 사용할 때 출력을 정렬하는 메서드로 사용됩니다. 파일은 전처리 통과 후 입력과 동일한 순서로 출력 파일 위치에 생성됩니다.</p> <h3 id=\"입력-파일-전처리-preprocessing-input-files\" style=\"position:relative;\">입력 파일 전처리 (Preprocessing input files)</h3> <p>컴파일러는 모든 트리플-슬래시 참조 지시어를 분석하기 위해 입력 파일에 대해 전처리를 수행합니다. 이 과정 동안, 추가 파일이 컴파일에 추가됩니다.</p> <p>이 과정은 <em>root files</em> 집합에서 시작됩니다; 이 루트 파일은 명령 줄이나 <code>tsconfig.json</code>파일의 <code>\"files\"</code> 목록에 있는 파일 이름입니다. 이러한 파일은 지정된 순서대로 전처리됩니다. 목록에 파일을 추가하기 전에, 파일에 있는 모든 트리플-슬래시 참조가 처리되고, 그 대상들이 포함됩니다. 트리플-슬래시 참조는 파일에서 보이는 순서대로 깊이 우선으로 처리됩니다.</p> <p>루트가 없는 경우, 트리플-슬래시 참조 경로는 이를 포함하고 있는 파일을 기준으로 처리됩니다.</p> <h3 id=\"오류-errors\" style=\"position:relative;\">오류 (Errors)</h3> <p>존재하지 않는 파일을 참조하는 것은 오류입니다. 자기 자신에 대한 트리플-슬래시 참조를 갖는 파일은 오류입니다.</p> <h3 id=\"--noresolve-사용하기-using---noresolve\" style=\"position:relative;\">\n<code>--noResolve</code> 사용하기 (Using <code>--noResolve</code>)</h3> <p>컴파일러 플래그 <code>--noResolve</code>가 지정되면, 트리플-슬래시 참조는 무시됩니다; 새 파일을 추가하거나, 제공된 파일의 순서를 바꾸지 않습니다.</p> <h2 id=\"-reference-types-\" style=\"position:relative;\"><code>/// &lt;reference types=\"...\" /&gt;</code></h2> <p><em>의존성</em> 선언 역할을 하는 <code>/// &lt;reference path=\"...\" /&gt;</code> 지시어와 유사하게, <code>/// &lt;reference types=\"...\" /&gt;</code> 지시어는 패키지의 의존성을 선언합니다.</p> <p>패키지 이름을 처리하는 과정은 <code>import</code>문에서 모듈 이름을 처리하는 과정과 유사합니다. 트리플-슬래시-참조-타입 지시어를 선언 패키지의 <code>import</code>로 생각하면 이해하기 쉽습니다.</p> <p>예를 들어, 선언 파일에 <code>/// &lt;reference types=\"node\" /&gt;</code>를 포함하는 것은 <code>@types/node/index.d.ts</code>에 선언된 이름을 사용한다고 하는 것이고; 따라서 이 패키지는 선언 파일과 함께 컴파일에 포함되어야 합니다.</p> <p>이 지시어는 <code>d.ts</code> 파일을 직접 작성할 때만 사용하세요.</p> <p>컴파일 중 생성된 선언 파일의 경우, 컴파일러는 자동으로 <code>/// &lt;reference types=\"...\" /&gt;</code>를 추가합니다;<br> <code>/// &lt;reference types=\"...\" /&gt;</code>는 오직 결과 파일이 참조된 패키지의 선언문을 사용하는 경우에만 생성된 파일 안에 추가됩니다.</p> <p><code>.ts</code> 파일에서 <code>@types</code> 패키지의 의존성을 선언하기 위해서는, 명령 줄에서 <code>--types</code>를 사용하거나 <code>tsconfig.json</code>를 사용하세요. <a href=\"https://www.typescriptlang.org/docs/handbook/tsconfig-json.html#types-typeroots-and-types\">using <code>@types</code>, <code>typeRoots</code> and <code>types</code> in <code>tsconfig.json</code> files</a> 에서 세부 사항을 확인하세요.</p> <h2 id=\"-reference-lib-\" style=\"position:relative;\"><code>/// &lt;reference lib=\"...\" /&gt;</code></h2> <p>이 지시어는 파일이 명시적으로 기존 내장 <em>lib</em> 파일을 포함하게 합니다..</p> <p>내장 <em>lib</em> 파일은 <em>tsconfig.json</em>의 <code>\"lib\"</code> 컴파일러 옵션과 같은 방식으로 참조됩니다 (예.<code>lib=\"lib.es2015.d.ts\"</code> 가 아닌 <code>lib=\"es2015\"</code> 사용 등).</p> <p>내장 타입에 의존하는 선언 파일 작성자에게는 트리플-슬래시-참조 lib 지시어를 사용하는 것이 권장됩니다(내장 타입 : DOM APIs 또는 <code>Symbol</code>이나 <code>Iterable</code>과 같은 내장 JS 런-타임 생성자) 이전에는 이런 .d.ts 파일은 이러한 타입의 전달/중복 선언을 추가했어야 한다.</p> <p>예를 들어, 컴파일에서 파일 중 하나에 <code>/// &lt;reference lib=\"es2017.string\" /&gt;</code>를 추가한 것은 <code>--lib es2017.string</code>으로 컴파일하는 것과 같습니다.</p> <pre data-language=\"ts\">/// &lt;reference lib=\"es2017.string\" /&gt;\n\n\"foo\".padStart(4);</pre> <h2 id=\"-reference-no-default-libtrue\" style=\"position:relative;\"><code>/// &lt;reference no-default-lib=\"true\"/&gt;</code></h2> <p>이 지시어는 파일을 <em>기본 라이브러리</em>라고 표시합니다. <code>lib.d.ts</code>와 이를 변형한 것들의 맨 상단에서 볼 수 있습니다.</p> <p>이 지시어는 컴파일러 기본 라이브러리(예. <code>lib.d.ts</code>) 를 컴파일에 포함시키지 <em>않도록</em> 지시합니다. 명령 줄에 <code>--noLib</code>을 넘겨주는 것과 비슷한 영향을 줍니다.</p> <p>또한 <code>--skipDefaultLibCheck</code>를 넘겨주면, 컴파일러가 <code>/// &lt;reference no-default-lib=\"true\"/&gt;</code>을 갖는 파일은 검사하지 않는다는 것을 유의하세요.</p> <h2 id=\"-amd-module-\" style=\"position:relative;\"><code>/// &lt;amd-module /&gt;</code></h2> <p>기본적으로 AMD 모듈은 익명으로 생성됩니다. 이는 모듈로 만들어내는 과정에서 다른 도구(예. <code>r.js</code>)를 사용할 경우 문제가 생길 수 있습니다.</p> <p><code>amd-module</code> 지시어는 컴파일러에게 선택적으로 모듈 이름을 넘길 수 있도록 해줍니다:</p> <h5 id=\"amdmodulets\" style=\"position:relative;\">amdModule.ts</h5> <pre data-language=\"ts\">///&lt;amd-module name=\"NamedModule\"/&gt;\nexport class C {}</pre> <p><code>define</code> 호출의 일부로 <code>NamedModule</code> 이름을 모듈에 할당하는 결과를 줄 것입니다:</p> <h5 id=\"amdmodulejs\" style=\"position:relative;\">amdModule.js</h5> <pre data-language=\"js\">define(\"NamedModule\", [\"require\", \"exports\"], function (require, exports) {\n  var C = (function () {\n    function C() {}\n    return C;\n  })();\n  exports.C = C;\n});</pre> <h2 id=\"-amd-dependency-\" style=\"position:relative;\"><code>/// &lt;amd-dependency /&gt;</code></h2> <blockquote> <p><strong>Note</strong>: 이 지시어는 deprecated 되었습니다. 대신 <code>import \"moduleName\";</code> 문을 사용하세요.</p> </blockquote> <p><code>/// &lt;amd-dependency path=\"x\" /&gt;</code>는 컴파일러에게 결과 모듈의 require 호출에 추가해야 하는 TS가 아닌 모듈의 의존성에 대해 알려줍니다.</p> <p>The <code>amd-dependency</code> 지시어는 선택적으로 <code>name</code> 프로퍼티를 갖습니다; 이로 인해 amd-dependency에 선택적으로 이름을 전달할 수 있습니다:</p> <pre data-language=\"ts\">/// &lt;amd-dependency path=\"legacy/moduleA\" name=\"moduleA\"/&gt;\ndeclare var moduleA: MyType;\nmoduleA.callStuff();</pre> <p>생성된 JS 코드:</p> <pre data-language=\"js\">define([\"require\", \"exports\", \"legacy/moduleA\"], function (\n  require,\n  exports,\n  moduleA\n) {\n  moduleA.callStuff();\n});</pre><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2012-2023 Microsoft<br>Licensed under the Apache License, Version 2.0.<br>\n    <a href=\"https://www.typescriptlang.org/ko/docs/handbook/triple-slash-directives.html\" class=\"_attribution-link\">https://www.typescriptlang.org/ko/docs/handbook/triple-slash-directives.html</a>\n  </p>\n</div>\n","type-compatibility":"<h1>Type Compatibility</h1>\n<p>TypeScript의 타입 호환성은 구조적 서브 타이핑(subtyping)을 기반으로 합니다. 구조적 타이핑이란 오직 멤버만으로 타입을 관계시키는 방식입니다. 명목적 타이핑(nominal typing) 과는 대조적입니다. 다음 코드를 살펴보겠습니다:</p> <pre data-language=\"ts\">interface Named {\n    name: string;\n}\n\nclass Person {\n    name: string;\n}\n\nlet p: Named;\n// 성공, 구조적 타이핑이기 때문입니다.\np = new Person();</pre> <p>C#이나 Java와 같은 명목적-타입 언어에서는 <code>Person</code> 클래스는 <code>Named</code> 인터페이스를 명시적인 구현체로 기술하지 않았기 때문에 해당 코드는 오류를 발생시킵니다.</p> <p>TypeScript의 구조적 타입 시스템은 JavaScript 코드의 일반적인 작성 방식에 따라서 설계되었습니다. JavaScript는 함수 표현식이나 객체 리터럴 같은 익명 객체를 광범위하게 사용하기 때문에 JavaScript에서 발견되는 관계의 타입을 명목적 타입 시스템보다는 구조적 타입 시스템을 이용하여 표현하는 것이 훨씬 더 자연스럽습니다.</p> <h2 id=\"건전성에-대한-참고사항-a-note-on-soundness\" style=\"position:relative;\">건전성에 대한 참고사항 (A Note on Soundness)</h2> <p>TypeScript의 타입 시스템은 컴파일 시간에 확인할 수 없는 특정 작업을 안전하게 수행할 수 있습니다. 타입 시스템이 이런 특성을 갖고 있을 때, “건전”하지 않다고 말합니다. TypeScript에서 건전하지 못한 곳을 허용하는 부분을 신중하게 고려했으며, 이 문서 전체에서 이러한 상황이 발생하는 곳과 유발하는 시나리오에 대해 설명합니다.</p> <h1 id=\"시작하기-starting-out\" style=\"position:relative;\">시작하기 (Starting out)</h1> <p>TypeScript의 구조적 타입 시스템의 기본 규칙은 <code>y</code>가 최소한 <code>x</code>와 동일한 멤버를 가지고 있다면 <code>x</code>와 <code>y</code>는 호환된다는 것입니다. 예를 들어:</p> <pre data-language=\"ts\">interface Named {\n    name: string;\n}\n\nlet x: Named;\n// y의 추론된 타입은 { name: string; location: string; } 입니다.\nlet y = { name: \"Alice\", location: \"Seattle\" };\nx = y;</pre> <p><code>y</code>를 <code>x</code>에 할당할 수 있는지 검사하기 위해, 컴파일러는 <code>x</code>의 각 프로퍼티를 검사하여 <code>y</code>에서 상응하는 호환 가능한 프로퍼티를 찾습니다. 이 경우, <code>y</code>는 <code>name</code>이라는 문자열 멤버를 가지고 있어야 합니다. 그러므로 할당이 허용됩니다.</p> <p>함수 호출 인수를 검사할 때 동일한 할당 규칙이 적용됩니다:</p> <pre data-language=\"ts\">function greet(n: Named) {\n    console.log(\"Hello, \" + n.name);\n}\ngreet(y); // 성공</pre> <p><code>y</code>는 <code>location</code> 프로퍼티를 추가적으로 가지고 있지만 오류를 발생시키지 않는 점에 유의합니다. 호환성을 검사할 때는 오직 대상 타입의 멤버(이 경우는 <code>Named</code>)만 고려됩니다.</p> <p>이 비교하는 과정은 재귀적으로 각 멤버와 하위-멤버의 타입을 탐색하면서 진행됩니다.</p> <h1 id=\"두-함수-비교-comparing-two-functions\" style=\"position:relative;\">두 함수 비교 (Comparing two functions)</h1> <p>원시 타입과 객체 타입을 비교하는 것은 비교적 간단하지만, 어떤 유형의 함수들이 호환될 수 있는지에 대한 질문은 조금 더 복잡합니다. 먼저 매개변수 목록에서만 다른 두 함수의 기본 예제를 살펴보겠습니다:</p> <pre data-language=\"ts\">let x = (a: number) =&gt; 0;\nlet y = (b: number, s: string) =&gt; 0;\n\ny = x; // 성공\nx = y; // 오류</pre> <p><code>x</code>를 <code>y</code>에 할당할 수 있는지 검사하기 위해, 먼저 매개변수 목록을 살펴봅니다. <code>x</code>의 각 매개변수는 호환 가능한 타입을 가진 <code>y</code>의 해당 매개변수를 가져야 합니다. 매개변수의 이름은 고려하지 않고 타입만 검사한다는 점에 유의하세요. 이 경우에는 <code>x</code>의 모든 매개변수는 <code>y</code>에 상응하는 호환 가능한 매개변수를 가지므로 할당이 허용됩니다.</p> <p>두 번째 할당은 <code>y</code>는 <code>x</code>에 없는 두 번째 필수적인 매개변수를 가지고 있기 때문에 할당이 허용되지 않아 오류가 발생합니다.</p> <p><code>y = x</code>의 예제에서처럼 매개변수를 ‘버리는’ 것이 허용되는 이유가 궁금할 수 있습니다. 이러한 할당이 허용되는 이유는 함수의 추가 매개변수를 무시하는 것이 실제로 JavaScript에선 매우 일반적이기 때문입니다. 예를 들어, <code>Array#forEach</code>는 콜백 함수에게 3 가지 매개변수인 배열 요소, 그 요소의 인덱스 그리고 이것을 포함하는 배열을 제공합니다. 그럼에도 불구하고 첫 번째 매개변수만 사용하는 콜백을 제공하는 것은 매우 유용합니다:</p> <pre data-language=\"ts\">let items = [1, 2, 3];\n\n// 추가 매개변수를 강제로 사용하지 마세요.\nitems.forEach((item, index, array) =&gt; console.log(item));\n\n// 괜찮습니다!\nitems.forEach(item =&gt; console.log(item));</pre> <p>반환 타입이 다른 두 함수를 사용하여 반환 타입이 어떻게 처리되는지 살펴보겠습니다:</p> <pre data-language=\"ts\">let x = () =&gt; ({name: \"Alice\"});\nlet y = () =&gt; ({name: \"Alice\", location: \"Seattle\"});\n\nx = y; // 성공\ny = x; // 오류, x()는 location 프로퍼티가 없습니다.</pre> <p>타입 시스템은 원본 함수의 반환 타입이 대상 타입의 반환 타입의 하위 타입이 되도록 합니다.</p> <h2 id=\"함수-매개변수의-bivariance-function-parameter-bivariance\" style=\"position:relative;\">함수 매개변수의 Bivariance (Function Parameter Bivariance)</h2> <p>함수 매개변수의 타입을 비교할 때, 원본 매개변수가 대상 매개변수에 할당이 가능하거나 이 반대여도 할당은 성공합니다. 이것은 호출한 측에서 더 특수한 타입을 취하여 함수를 제공할 수도 있지만, 덜 특수화된 타입의 함수를 호출할 수 있기 때문에 바람직하지 않습니다. 실제로 이런 종류의 오류는 드물지만 이는 많은 일반적인 JavaScript 패턴들을 사용할 수 있게 합니다. 간단한 예제:</p> <pre data-language=\"ts\">enum EventType {\n  Mouse,\n  Keyboard,\n}\n\ninterface Event {\n  timestamp: number;\n}\ninterface MyMouseEvent extends Event {\n  x: number;\n  y: number;\n}\ninterface MyKeyEvent extends Event {\n  keyCode: number;\n}\n\nfunction listenEvent(eventType: EventType, handler: (n: Event) =&gt; void) {\n  /* ... */\n}\n\n// 바람직하진 않지만 유용하고 일반적임\nlistenEvent(EventType.Mouse, (e: MyMouseEvent) =&gt; console.log(e.x + \",\" + e.y));\n\n// 건전성 측면에서 바람직하지 않은 대안\nlistenEvent(EventType.Mouse, (e: Event) =&gt;\n  console.log((e as MyMouseEvent).x + \",\" + (e as MyMouseEvent).y)\n);\nlistenEvent(EventType.Mouse, ((e: MyMouseEvent) =&gt;\n  console.log(e.x + \",\" + e.y)) as (e: Event) =&gt; void);\n\n// 여전히 허용되지 않음 (명확한 오류). 완전히 호환되지 않는 타입에 적용되는 타입 안전성(Type safety)\nlistenEvent(EventType.Mouse, (e: number) =&gt; console.log(e));</pre> <p>컴파일러 플래그인 <code>strictFunctionTypes</code>을 통해 이러한 상황이 발생하면 TypeScript에서 오류가 발생하도록 할 수 있습니다.</p> <h2 id=\"선택적-매개변수와-나머지-매개변수-optional-parameters-and-rest-parameters\" style=\"position:relative;\">선택적 매개변수와 나머지 매개변수 (Optional Parameters and Rest Parameters)</h2> <p>함수의 호환성을 비교할 때 선택적 매개변수와 필수 매개변수를 서로 바꿔 사용할 수 있습니다. 원본 타입의 추가 선택적 매개변수는 오류가 아니고, 원본 타입의 해당 매개변수가 없는 대상 타입의 선택적 매개변수도 오류가 아닙니다.</p> <p>함수가 나머지 매개변수를 가지고 있다면, 마치 무한한 일련의 선택적 매개변수처럼 처리됩니다.</p> <p>이것은 타입 시스템 관점에서는 바람직하지 않지만, 런타임 관점에서는 해당 위치에 <code>undefined</code>를 전달하는 것은 대부분 함수에 해당하므로 선택적 매개변수에 대한 아이디어는 제대로 적용되지 않습니다.</p> <p>다음을 유발하는 예제는 콜백을 받아서 (프로그래머에게는) 예측이 가능하지만 (타입 시스템이) 알 수 없는 개수의 인수를 호출하는 함수의 일반적인 패턴입니다:</p> <pre data-language=\"ts\">function invokeLater(args: any[], callback: (...args: any[]) =&gt; void) {\n    /* ... 'args'를 사용하여 콜백을 호출함 ... */\n}\n\n// 바람직하지 않음 - invokeLater는 \"아마도\" 여러개의 인수를 제공합니다\ninvokeLater([1, 2], (x, y) =&gt; console.log(x + \", \" + y));\n\n// 혼란스럽고 (x와 y가 실제로 필요함) 발견할 수 없음\ninvokeLater([1, 2], (x?, y?) =&gt; console.log(x + \", \" + y));</pre> <h2 id=\"오버로드-함수-functions-with-overloads\" style=\"position:relative;\">오버로드 함수 (Functions with overloads)</h2> <p>함수에 오버로드가 있는 경우 원본 타입의 각 오버로드는 대상 타입의 호환 가능한 시그니처와 일치해야 합니다. 이를 통해 원본 함수와 모든 동일한 상황에서 대상 함수를 호출할 수 있습니다.</p> <h1 id=\"열거형-enums\" style=\"position:relative;\">열거형 (Enums)</h1> <p>열거형은 숫자와 호환되며 숫자는 열거형과 호환됩니다. 다른 열거형 타입의 열거형 값은 호환되지 않는 것으로 간주됩니다. 예를 들면,</p> <pre data-language=\"ts\">enum Status {\n  Ready,\n  Waiting,\n}\nenum Color {\n  Red,\n  Blue,\n  Green,\n}\n\nlet status = Status.Ready;\nstatus = Color.Green; // 오류</pre> <h1 id=\"클래스-classes\" style=\"position:relative;\">클래스 (Classes)</h1> <p>클래스는 객체 리터럴 타입과 인터페이스와 한 가지 예외를 제외하곤 유사하게 동작합니다: 클래스는 정적 타입과 인스턴스 타입이 있습니다. 클래스 타입의 두 개의 객체를 비교할 때, 오직 인스턴스의 멤버만 비교됩니다. 정적인 멤버와 생성자는 호환성에 영향을 주지 않습니다.</p> <pre data-language=\"ts\">class Animal {\n  feet: number;\n  constructor(name: string, numFeet: number) {}\n}\n\nclass Size {\n  feet: number;\n  constructor(numFeet: number) {}\n}\n\nlet a: Animal;\nlet s: Size;\n\na = s; // 성공\ns = a; // 성공</pre> <h2 id=\"클래스의-private-멤버와-protected-멤버-private-and-protected-members-in-classes\" style=\"position:relative;\">클래스의 private 멤버와 protected 멤버 (Private and protected members in classes)</h2> <p>클래스의 private과 protected 멤버는 호환성에 영향을 줍니다. 클래스 인스턴스의 호환성을 검사할 때 대상 타입에 private 멤버가 있다면, 원본 타입 또한 동일 클래스에서 비롯된 private 멤버가 있어야 합니다. 마찬가지로 protected 멤버가 있는 인스턴스도 똑같이 적용됩니다. 이를 통해 클래스는 상위 클래스와 호환 가능하지만 같은 형태를 가진 다른 상속 계층 구조의 클래스와는 호환이 되지 <em>않습니다</em>.</p> <h1 id=\"제네릭-generics\" style=\"position:relative;\">제네릭 (Generics)</h1> <p>TypeScript는 구조적 타입 시스템이기 때문에, 타입 매개변수는 멤버의 타입의 일부로 사용할 때 결과 타입에만 영향을 줍니다. 에를 들면,</p> <pre data-language=\"ts\">interface Empty&lt;T&gt; {}\nlet x: Empty&lt;number&gt;;\nlet y: Empty&lt;string&gt;;\n\nx = y; // 성공, y는 x의 구조와 대응하기 때문</pre> <p>위에서 <code>x</code>와 <code>y</code>는 구조가 타입 인수를 서로 다르게 사용하지 않기 때문에 호환됩니다. 이 예제에 <code>Empty&lt;T&gt;</code>를 멤버에 추가하여 어떻게 동작하는 살펴봅시다:</p> <pre data-language=\"ts\">interface NotEmpty&lt;T&gt; {\n  data: T;\n}\nlet x: NotEmpty&lt;number&gt;;\nlet y: NotEmpty&lt;string&gt;;\n\nx = y; // 오류, x와 y 는 호환되지 않음</pre> <p>이런 식으로, 타입 인수가 지정된 제네릭 타입은 비-제네릭 타입처럼 동작합니다.</p> <p>타입 인수가 지정되지 않은 제네릭 타입에 관해선, 모든 지정되지 않은 타입 인수를 대신해서 <code>any</code>로 지정함으로써 호환성 검사를 합니다. 그 결과 생성된 타입은 비-제네릭 경우와 마찬가지로 호환성을 검사합니다.</p> <p>예를 들어,</p> <pre data-language=\"ts\">let identity = function &lt;T&gt;(x: T): T {\n  // ...\n};\n\nlet reverse = function &lt;U&gt;(y: U): U {\n  // ...\n};\n\nidentity = reverse; // 성공, (x: any) =&gt; any는  (y: any) =&gt; any와 대응하기 때문</pre> <h1 id=\"고급-주제-advanced-topics\" style=\"position:relative;\">고급 주제 (Advanced Topics)</h1> <h2 id=\"하위-타입-vs-할당-subtype-vs-assignment\" style=\"position:relative;\">하위 타입 vs 할당 (Subtype vs Assignment)</h2> <p>지금까지 언어 사양에 정의된 용어가 아닌 “호환” 을 사용했습니다. TypeScript에서는 두 가지 종류의 호환성이 있습니다: 하위 타입과 할당. 할당은 하위 타입의 호환성을 확장하여 <code>any</code>에서의 할당과 <code>enum</code>과 해당 숫자 값의 할당을 허용하는 규칙을 가진다는 점만 다릅니다.</p> <p>언어에서 다른 위치는 상황에 따라 두 가지 호환 메커니즘 중 하나를 사용합니다. 실용적인 목적을 위해 타입 호환성은 심지어 <code>implements</code>와 <code>extends</code>의 경우에도 할당 호환성에 의해 결정됩니다.</p> <h2 id=\"any-unknown-object-void-undefined-null-never-할당-호환성\" style=\"position:relative;\">\n<code>Any</code>, <code>unknown</code>, <code>object</code>, <code>void</code>, <code>undefined</code>, <code>null</code>, <code>never</code> 할당 호환성</h2> <p>The following table summarizes assignability between some abstract types. Rows indicate what each is assignable to, columns indicate what is assignable to them. A ”<span class=\"black-tick\">✓</span>” indicates a combination that is compatible only when <a href=\"https://www.typescriptlang.org/tsconfig#strictNullChecks\"><code>--strictNullChecks</code></a> is off.</p>  <table class=\"data\"> <thead> <tr> <th></th> <th align=\"center\">any</th> <th align=\"center\">unknown</th> <th align=\"center\">object</th> <th align=\"center\">void</th> <th align=\"center\">undefined</th> <th align=\"center\">null</th> <th align=\"center\">never</th> </tr> </thead> <tbody> <tr> <td>any →</td> <td align=\"center\"></td> <td align=\"center\"><span class=\"blue-tick\" style=\"\n    color: #007aff;\n\">✓</span></td> <td align=\"center\"><span class=\"blue-tick\">✓</span></td> <td align=\"center\"><span class=\"blue-tick\">✓</span></td> <td align=\"center\"><span class=\"blue-tick\">✓</span></td> <td align=\"center\"><span class=\"blue-tick\">✓</span></td> <td align=\"center\"><span class=\"red-cross\">✕</span></td> </tr> <tr> <td>unknown →</td> <td align=\"center\"><span class=\"blue-tick\">✓</span></td> <td align=\"center\"></td> <td align=\"center\"><span class=\"red-cross\">✕</span></td> <td align=\"center\"><span class=\"red-cross\">✕</span></td> <td align=\"center\"><span class=\"red-cross\">✕</span></td> <td align=\"center\"><span class=\"red-cross\">✕</span></td> <td align=\"center\"><span class=\"red-cross\">✕</span></td> </tr> <tr> <td>object →</td> <td align=\"center\"><span class=\"blue-tick\">✓</span></td> <td align=\"center\"><span class=\"blue-tick\">✓</span></td> <td align=\"center\"></td> <td align=\"center\"><span class=\"red-cross\">✕</span></td> <td align=\"center\"><span class=\"red-cross\">✕</span></td> <td align=\"center\"><span class=\"red-cross\">✕</span></td> <td align=\"center\"><span class=\"red-cross\">✕</span></td> </tr> <tr> <td>void →</td> <td align=\"center\"><span class=\"blue-tick\">✓</span></td> <td align=\"center\"><span class=\"blue-tick\">✓</span></td> <td align=\"center\"><span class=\"red-cross\">✕</span></td> <td align=\"center\"></td> <td align=\"center\"><span class=\"red-cross\">✕</span></td> <td align=\"center\"><span class=\"red-cross\">✕</span></td> <td align=\"center\"><span class=\"red-cross\">✕</span></td> </tr> <tr> <td>undefined →</td> <td align=\"center\"><span class=\"blue-tick\">✓</span></td> <td align=\"center\"><span class=\"blue-tick\">✓</span></td> <td align=\"center\"><span class=\"black-tick\">✓</span></td> <td align=\"center\"><span class=\"blue-tick\">✓</span></td> <td align=\"center\"></td> <td align=\"center\"><span class=\"black-tick\">✓</span></td> <td align=\"center\"><span class=\"red-cross\">✕</span></td> </tr> <tr> <td>null →</td> <td align=\"center\"><span class=\"blue-tick\">✓</span></td> <td align=\"center\"><span class=\"blue-tick\">✓</span></td> <td align=\"center\"><span class=\"black-tick\">✓</span></td> <td align=\"center\"><span class=\"black-tick\">✓</span></td> <td align=\"center\"><span class=\"black-tick\">✓</span></td> <td align=\"center\"></td> <td align=\"center\"><span class=\"red-cross\">✕</span></td> </tr> <tr> <td>never →</td> <td align=\"center\"><span class=\"blue-tick\">✓</span></td> <td align=\"center\"><span class=\"blue-tick\">✓</span></td> <td align=\"center\"><span class=\"blue-tick\">✓</span></td> <td align=\"center\"><span class=\"blue-tick\">✓</span></td> <td align=\"center\"><span class=\"blue-tick\">✓</span></td> <td align=\"center\"><span class=\"blue-tick\">✓</span></td> <td align=\"center\"></td> </tr> </tbody> </table> <p>Reiterating <a href=\"https://www.typescriptlang.org/handbook/basic-types.html\">Basic Types</a>:</p> <ul> <li>Everything is assignable to itself.</li> <li>\n<code>any</code> and <code>unknown</code> are the same in terms of what is assignable to them, different in that <code>unknown</code> is not assignable to anything except <code>any</code>.</li> <li>\n<code>unknown</code> and <code>never</code> are like inverses of each other. Everything is assignable to <code>unknown</code>, <code>never</code> is assignable to everything. Nothing is assignable to <code>never</code>, <code>unknown</code> is not assignable to anything (except <code>any</code>).</li> <li>\n<code>void</code> is not assignable to or from anything, with the following exceptions: <code>any</code>, <code>unknown</code>, <code>never</code>, <code>undefined</code>, and <code>null</code> (if <code>--strictNullChecks</code> is off, see table for details).</li> <li>When <code>--strictNullChecks</code> is off, <code>null</code> and <code>undefined</code> are similar to <code>never</code>: assignable to most types, most types are not assignable to them. They are assignable to each other.</li> <li>When <code>--strictNullChecks</code> is on, <code>null</code> and <code>undefined</code> behave more like <code>void</code>: not assignable to or from anything, except for <code>any</code>, <code>unknown</code>, <code>never</code>, and <code>void</code> (<code>undefined</code> is always assignable to <code>void</code>).</li> </ul><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2012-2023 Microsoft<br>Licensed under the Apache License, Version 2.0.<br>\n    <a href=\"https://www.typescriptlang.org/ko/docs/handbook/type-compatibility.html\" class=\"_attribution-link\">https://www.typescriptlang.org/ko/docs/handbook/type-compatibility.html</a>\n  </p>\n</div>\n","iterators-and-generators":"<h1>Iterators and Generators</h1>\n<h2 id=\"이터러블\" style=\"position:relative;\">이터러블</h2> <p><a href=\"symbols#symboliterator\"><code>Symbol.iterator</code></a> 프로퍼티에 대한 구현을 가진 객체는 이터러블로 간주합니다. <code>Array</code>, <code>Map</code>, <code>Set</code>, <code>String</code>, <code>Int32Array</code>, <code>Uint32Array</code>, 등과 같은 내장 타입에는 <code>Symbol.iterator</code> 프로퍼티가 이미 구현되어 있습니다. 객체에 있는 <code>Symbol.iterator</code> 함수는 반복할 값 목록을 반환합니다.</p> <h2 id=\"forof-문\" style=\"position:relative;\">\n<code>for..of</code> 문</h2> <p><code>for..of</code>문은 객체 내부 <code>Symbol.iterator</code> 프로퍼티를 호출해 이터러블 객체를 반복합니다. 다음은 배열의 간단한 <code>for..of</code> 루프입니다:</p> <pre data-language=\"ts\">let someArray = [1, \"string\", false];\n\nfor (let entry of someArray) {\n  console.log(entry); // 1, \"string\", false\n}</pre> <h3 id=\"forof-vs-forin문\" style=\"position:relative;\">\n<code>for..of</code> vs. <code>for..in</code>문</h3> <p><code>for..of</code>와 <code>for..in</code>문은 모두 리스트를 반복하지만 반복하는 값이 다릅니다. <code>for..in</code>은 반복하는 객체의 <em>키</em> 리스트를 반환하지만 <code>for..of</code>는 반복하는 객체의 숫자 프로퍼티인 <em>값</em> 리스트를 반환합니다.</p> <p>다음은 이러한 차이를 보여주는 예시입니다:</p> <pre data-language=\"ts\">let list = [4, 5, 6];\n\nfor (let i in list) {\n  console.log(i); // \"0\", \"1\", \"2\",\n}\n\nfor (let i of list) {\n  console.log(i); // \"4\", \"5\", \"6\"\n}</pre> <p>또 다른 차이는 <code>for..in</code>이 모든 객체에서 작동한다는 것입니다. 그래서 객체의 프로퍼티를 검사하는 방법으로 사용합니다. 반면에 <code>for..of</code>는 주로 이터러블 객체의 값에 중점을 둡니다. <code>Map</code>과 <code>Set</code> 같은 내장 객체는 저장된 값에 접근할 수 있는 <code>Symbol.iterator</code> 프로퍼티를 구현합니다.</p> <pre data-language=\"ts\">let pets = new Set([\"Cat\", \"Dog\", \"Hamster\"]);\npets[\"species\"] = \"mammals\";\n\nfor (let pet in pets) {\n  console.log(pet); // \"species\"\n}\n\nfor (let pet of pets) {\n  console.log(pet); // \"Cat\", \"Dog\", \"Hamster\"\n}</pre> <h3 id=\"코드-생성\" style=\"position:relative;\">코드 생성</h3> <h4 id=\"es5-및-es3-타겟팅\" style=\"position:relative;\">ES5 및 ES3 타겟팅</h4> <p>ES5 또는 ES3 호환 엔진을 대상으로 하는 경우, 반복자는 <code>Array</code> 타입 값만 허용합니다. <code>Symbol.iterator</code> 프로퍼티를 구현하더라도 Array가 아닌 값에 <code>for..of</code> 루프를 사용하면 오류가 발생합니다.</p> <p>컴파일러는 <code>for..of</code>에 대해 간단한 <code>for</code> 루프를 생성합니다, 예를 들면:</p> <pre data-language=\"ts\">let numbers = [1, 2, 3];\nfor (let num of numbers) {\n  console.log(num);\n}</pre> <p>컴파일러는 위 코드를 다음과 같이 생성합니다:</p> <pre data-language=\"js\">var numbers = [1, 2, 3];\nfor (var _i = 0; _i &lt; numbers.length; _i++) {\n  var num = numbers[_i];\n  console.log(num);\n}</pre> <h4 id=\"ecmascript-2015-및-상위-버전-타겟팅\" style=\"position:relative;\">ECMAScript 2015 및 상위 버전 타겟팅</h4> <p>ECMAScipt 2015 호환 엔진을 대상으로 하는 경우, 컴파일러는 엔진에서 내장 반복자 구현을 대상으로 하는 <code>for..of</code> 루프를 생성합니다.</p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2012-2023 Microsoft<br>Licensed under the Apache License, Version 2.0.<br>\n    <a href=\"https://www.typescriptlang.org/ko/docs/handbook/iterators-and-generators.html\" class=\"_attribution-link\">https://www.typescriptlang.org/ko/docs/handbook/iterators-and-generators.html</a>\n  </p>\n</div>\n","intro":"<h1>The TypeScript Handbook</h1>\n<h2 id=\"핸드북에-대해서-about-this-handbook\" style=\"position:relative;\">핸드북에 대해서 (About this Handbook)</h2> <p>JavaScript는 프로그래밍 커뮤니티에 도입된 지 20년이 지난 지금, 가장 널리 퍼진 cross-platform 언어 중 하나입니다. JavaScript는 웹 페이지에 사소한 상호작용을 추가하기 위한 작은 스크립팅 언어로 시작하여, 규모에 상관없이 프론트엔드와 백엔드 애플리케이션에서 선택 가능한 언어로 성장했습니다. JavaScript로 작성된 프로그램의 크기, 범위 및 복잡성은 기하급수적으로 커졌지만, 다른 코드 단위 간의 관계를 표현하는 JavaScript 언어의 능력은 그렇지 못했습니다. JavaScript의 다소 특이한 런타임 의미 체계(runtime semantics)와 더불어, 언어와 프로그램 복잡성 간의 불일치는 JavaScript 개발을 규모에 맞게 관리하기 어려운 작업으로 만들었습니다.</p> <p>프로그래머들이 작성하는 가장 흔한 오류는 타입 오류입니다: 다른 종류의 값이 예상되는 곳에 특정한 값이 사용된 경우입니다. 이는 단순한 오타, 라이브러리 API를 이해하지 못한 것, 런타임 동작에 대한 잘못된 가정 또는 다른 오류 때문일 수 있습니다. TypeScript의 목표는 JavaScript 프로그램의 정적 타입 검사자 입니다. 즉, 코드가 실행되기 전에 실행하고(정적), 프로그램 타입이 정확한지 확인하는 도구(타입 검사)입니다.</p> <p>JavaScript에 대한 배경지식 없이 TypeScript를 첫 번째 언어로 사용한다면, 먼저 <a href=\"https://developer.mozilla.org/docs/Web/JavaScript/Guide\">Mozilla 웹 문서에서 JavaScript에 대한</a> 문서를 읽어 보는 것이 좋습니다. 다른 언어에 대한 경험이 있다면, 핸드북을 읽으면서 JavaScript 구문을 꽤 빠르게 익힐 수 있을 것입니다.</p> <h2 id=\"핸드북은-어떻게-구성되어-있는가-how-is-this-handbook-structured\" style=\"position:relative;\">핸드북은 어떻게 구성되어 있는가? (How is this Handbook Structured)</h2> <p>핸드북은 두 영역으로 나뉩니다:</p> <ul> <li> <p><strong>핸드북</strong></p> <p>TypeScript 핸드북은 평범한 프로그래머들에게 TypeScript를 설명하는 종합적인 문서입니다. 왼쪽 메뉴를 통해 위에서 아래로 이동하며 읽을 수 있습니다.</p> <p>각 장 또는 페이지가 주어진 개념에 대해 자세한 설명을 제공할 것이라고 기대할 것입니다. TypeScript 핸드북은 언어에 대한 완전한 설명서는 아니지만, 모든 특징과 동작에 대한 종합적인 가이드입니다.</p> <p>실습을 완료한 독자는 다음을 수행할 수 있어야 합니다:</p> <ul> <li>일반적으로 사용하는 TypeScript 구문 및 패턴을 읽고 이해하기</li> <li>중요한 컴파일러 옵션의 효과 설명하기</li> <li>대부분의 경우에서 타입 시스템 동작을 올바르게 예측하기</li> <li>간단한 함수, 객체 또는 클래스에 대한 .d.ts 선언 작성하기</li> </ul> <p>핸드북의 주요 내용은 명확성과 간결성을 위해, 다루어지고 있는 특징의 모든 엣지 케이스 또는 세부 사항을 탐구하지는 않습니다. 참고문헌에서 특정 개념에 대한 자세한 내용을 찾아볼 수 있습니다.</p> </li> <li> <p><strong>핸드북 레퍼런스</strong></p> <p>핸드북 레퍼런스는 TypeScript의 특정 부분이 어떻게 작동하는지 풍부한 이해를 제공하기 위해 작성되었습니다. 위에서 아래로 읽을 수 있지만, 연속적으로 설명하는 것이 아니라, 각 섹션은 단일 개념에 대한 더 깊은 설명 제공을 목표로 합니다.</p> </li> </ul> <h3 id=\"잠재적인-목표-non-goals\" style=\"position:relative;\">잠재적인 목표 (Non-Goals)</h3> <p>핸드북은 몇 시간 안에 편하게 읽을 수 있는 간결한 문서로 제작되었습니다. 간결함을 유지하기 위해 특정 주제는 다루지 않습니다.</p> <p>특히, 함수, 클래스, 클로저와 같은 JavaScript 핵심 개념을 전부 소개하지는 않습니다. 필요한 경우, 해당 개념을 읽는 데 사용할 수 있는 배경 자료 링크를 제시할 것입니다.</p> <p>또한, 핸드북은 언어 명세를 대체하기 위함이 아닙니다. 경우에 따라서는, 대략적이고 이해하기 쉬운 설명을 위해, 에지 케이스나 동작의 형식적인 설명을 생략할 수 있습니다. 대신에, TypeScript 동작의 여러 측면을 보다 정확하고 공식적으로 설명하는 별도의 참조 페이지가 있습니다. 레퍼런스 페이지는 TypeScript에 익숙하지 않은 독자를 위한 것이 아니기 때문에, 아직 읽지 않은 고급 용어나 주제를 사용할 수 있습니다.</p> <p>마지막으로, 필요한 경우를 제외하고는 TypeScript가 다른 도구와 어떻게 상호작용하는지는 다루지 않습니다. webpack, rollup, parcel, react, babel, closure, lerna, rush, bazel, preact, vue, angular, svelte, jquery, yarn, npm으로 TypeScript를 구성하는 방법은 다른 웹사이트에서 찾을 수 있습니다.</p> <h2 id=\"시작하기-get-started\" style=\"position:relative;\">시작하기 (Get Started)</h2> <p><a href=\"https://www.typescriptlang.org/docs/handbook/2/basic-types.html\">기본 타입</a>을 시작하기 전에, 다음의 소개 페이지 중 하나를 읽어보는 것이 좋습니다. TypeScript와 당신이 선호하는 프로그래밍 언어 간의 주요 유사점과 차이점을 강조하고, 해당 언어에 대한 일반적인 오해를 정리했습니다.</p> <ul> <li><a href=\"https://www.typescriptlang.org/docs/handbook/typescript-from-scratch.html\">TypeScript for New Programmers</a></li> <li><a href=\"https://www.typescriptlang.org/docs/handbook/typescript-in-5-minutes.html\">TypeScript for JavaScript Programmers</a></li> <li><a href=\"https://www.typescriptlang.org/docs/handbook/typescript-in-5-minutes-oop.html\">TypeScript for OOP Programmers</a></li> <li><a href=\"https://www.typescriptlang.org/docs/handbook/typescript-in-5-minutes-func.html\">TypeScript for Functional Programmers</a></li> </ul> <p>또는, <a href=\"https://www.typescriptlang.org/docs/handbook/2/basic-types.html\">기본 타입</a>을 살펴보거나, <a href=\"https://www.typescriptlang.org/assets/typescript-handbook.epub\">Epub</a> 또는 <a href=\"https://www.typescriptlang.org/assets/typescript-handbook.pdf\">PDF</a> 형식의 핸드북을 다운로드 할 수 있습니다.</p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2012-2023 Microsoft<br>Licensed under the Apache License, Version 2.0.<br>\n    <a href=\"https://www.typescriptlang.org/ko/docs/handbook/intro.html\" class=\"_attribution-link\">https://www.typescriptlang.org/ko/docs/handbook/intro.html</a>\n  </p>\n</div>\n","module-resolution":"<h1>Module Resolution</h1>\n<blockquote> <p>이번 섹션은 모듈에 대한 기초적인 지식을 전제로 합니다. 더 많은 정보는 <a href=\"modules.md\">모듈</a>을 보도록 하세요.</p> </blockquote> <p><em>모듈 해석 (module resolution)</em> 은 컴파일러가 import가 무엇을 참조하는지 알아내기 위해 사용하는 프로세스입니다. <code>import { a } from \"moduleA\"</code>같은 import 문을 생각해보세요; <code>a</code>의 모든 사용을 검사하기 위해, 컴파일러는 무엇을 참조하는지 정확히 알아야 할 필요가 있습니다, 그리고 <code>moduleA</code> 정의를 검사해야 할 필요가 있습니다.</p> <p>이 시점에, 컴파일러는 ”<code>moduleA</code>의 형태가 뭘까?”라고 질문할 것입니다. 간단해 보이지만, <code>moduleA</code>는 <code>.ts</code>/<code>.tsx</code> 파일에 정의되어 있거나 혹은 코드가 의존하는 <code>.d.ts</code>에 정의되어 있을 수 있습니다.</p> <p>첫 번째로, 컴파일러는 가져온 모듈을 나타내는 파일의 위치를 찾으려고 할 것입니다. 그렇게 하기 위해 컴파일러는 두 가지 다른 전략 중 하나를 따릅니다: <a href=\"#%ED%81%B4%EB%9E%98%EC%8B%9D-classic\">클래식</a> 혹은 <a href=\"#%EB%85%B8%EB%93%9C-node\">노드</a>. 이 전략들은 컴파일러가 <code>moduleA</code>를 찾기 위해 <em>어디</em>를 봐야 할지 알려줍니다.</p> <p>만약 이 방법이 잘 안되고 모듈 이름이 비-상대적이라면 (<code>\"moduleA</code>의 경우가 그렇습니다), 컴파일러는 <a href=\"modules.md#Ambient-%EB%AA%A8%EB%93%88-Ambient-Modules\">ambient 모듈 선언</a>을 찾으려고 할 것입니다. 비-상대적 import는 다음에 다룰 것입니다.</p> <p>마지막으로, 컴파일러가 모듈을 해석할 수 없다면, 오류 로그가 발생합니다. 이 경우에, 오류는 <code>error TS2307: Cannot find module 'moduleA'</code>와 같습니다.</p> <h2 id=\"상대적-vs-비-상대적-모듈-import-relative-vs-non-relative-module-imports\" style=\"position:relative;\">상대적 vs. 비-상대적 모듈 import (Relative vs. Non-relative module imports)</h2> <p>모듈 참조가 상대적 혹은 비-상대적이냐에 따라 모듈 import는 다르게 해석됩니다.</p> <p><em>상대적 import</em> 는 <code>/</code>, <code>./</code> 혹은 <code>../</code>. 중에 하나로 시작합니다. 일부 예제는 다음과 같습니다:</p> <ul> <li><code>import Entry from \"./components/Entry\";</code></li> <li><code>import { DefaultHeaders } from \"../constants/http\";</code></li> <li><code>import \"/mod\";</code></li> </ul> <p>다른 모든 import는 <strong>비-상대적</strong> 으로 간주됩니다. 일부 예제는 다음과 같습니다:</p> <ul> <li><code>import * as $ from \"jquery\";</code></li> <li><code>import { Component } from \"@angular/core\";</code></li> </ul> <p>상대적 import는 가져온 파일에 상대적으로 해석되고 ambient 모듈 선언으로 해석 <em>될 수 없습니다</em>. 자신의 모듈에 대해서는 런타임에 상대적 위치를 유지하는 것을 보장하는 상대적 import를 사용해야 합니다.</p> <p>비-상대적 import는 <code>baseUrl</code>로 해석되거나, 밑에서 다루게 될 경로 매핑으로 해석될 수 있습니다. <a href=\"modules.md#Ambient-%EB%AA%A8%EB%93%88-Ambient-modules\">ambient 모듈 선언</a>으로도 해석될 수 있습니다. 외부 의존성을 import 할 때, 비-상대적 경로를 사용하세요.</p> <h2 id=\"모듈-해석-전략-module-resolution-strategies\" style=\"position:relative;\">모듈 해석 전략 (Module Resolution Strategies)</h2> <p>두 가지 가능한 모듈 해석 전략이 있습니다: <a href=\"#%EB%85%B8%EB%93%9C-node\">노드</a>와 <a href=\"#%ED%81%B4%EB%9E%98%EC%8B%9D-classic\">클래식</a>. <code>--moduleResolution</code> 플래그를 사용하여 모듈 해석 전략을 지정할 수 있습니다. 지정되지 않았으면, 디폴트는 <code>--module AMD | System | ES2015</code>에서는 [클래식][#클래식-classic]이고 나머지는 <a href=\"#%EB%85%B8%EB%93%9C-node\">노드</a>입니다.</p> <h3 id=\"클래식-classic\" style=\"position:relative;\">클래식 (Classic)</h3> <p>TypeScript의 디폴트 해석 전략으로 사용됩니다. 요즘에, 이 전략은 주로 이전 버전과의 호환성을 위해 제공됩니다.</p> <p>상대적 import는 import하는 파일에 상대적으로 해석됩니다. 그래서 소스 파일 <code>/root/src/folder/A.ts</code>안에 import { b } from “./moduleB”`는 다음과 같이 조회합니다:</p> <ol> <li><code>/root/src/folder/moduleB.ts</code></li> <li><code>/root/src/folder/moduleB.d.ts</code></li> </ol> <p>그러나, 비-상대적 모듈 import에서는, 컴파일러가 가져온 파일을 갖고 있는 디렉터리부터 시작해서 디렉터리 트리를 거슬러 올라가 맞는 정의 파일의 위치를 찾으려고 합니다.</p> <p>예를 들어:</p> <p>소스 파일 <code>/root/src/folder/A.ts</code>안에 <code>import { b } from \"moduleB\"</code>처럼 <code>moduleB</code>의 비-상대적 import은 <code>\"moduleB\"</code>의 위치를 찾기 위해 다음과 같은 위치를 찾습니다.</p> <ol> <li><code>/root/src/folder/moduleB.ts</code></li> <li><code>/root/src/folder/moduleB.d.ts</code></li> <li><code>/root/src/moduleB.ts</code></li> <li><code>/root/src/moduleB.d.ts</code></li> <li><code>/root/moduleB.ts</code></li> <li><code>/root/moduleB.d.ts</code></li> <li><code>/moduleB.ts</code></li> <li><code>/moduleB.d.ts</code></li> </ol> <h3 id=\"노드-node\" style=\"position:relative;\">노드 (Node)</h3> <p>이 해석 전략은 런타임에 <a href=\"https://nodejs.org/\">Node.js</a>의 모듈 해석 메커니즘을 모방하려고 시도합니다. 전체 Node.js 해석 알고리즘은 <a href=\"https://nodejs.org/api/modules.html#modules_all_together\">Node.js 모듈 문서</a>에 요약되어 있습니다.</p> <h4 id=\"nodejs가-모듈을-해석하는-방법-how-nodejs-resolves-modules\" style=\"position:relative;\">Node.js가 모듈을 해석하는 방법 (How Node.js resolves modules)</h4> <p>TS 컴파일러가 어떤 과정을 따를지 이해하기 위해서는, Node.js 모듈을 이해하는 것이 중요합니다. 전통적으로, Node.js의 import는 <code>require</code> 함수를 호출해 수행합니다. Node.js의 동작은 <code>require</code>에 상대적 경로 혹은 비-상대적 경로가 주어지는지에 따라 달라집니다.</p> <p>상대적 경로는 아주 간단합니다. 예를 들어, <code>var x = require(\"./moduleB\");</code>라는 import 문을 포함한 <code>/root/src/moduleA.js</code>에 위치한 파일을 생각해봅시다. Node.js는 다음 순서로 import를 해석합니다:</p> <ol> <li> <p><code>/root/src/moduleB.js</code>라는 파일이 존재하는지 확인.</p> </li> <li> <p>만약 <code>\"main\"</code> 모듈을 지정하는 <code>package.json</code>라는 파일을 포함하고 있으면, <code>/root/src/moduleB</code> 폴더 확인하기.</p> </li> </ol> <p>이 예제에서는, 만약 Node.js가 <code>{ \"main\": \"lib/mainModule.js\" }</code>을 포함하는 <code>/root/src/moduleB/package.json</code>파일을 찾았다면, Node.js가 <code>/root/src/moduleB/lib/mainModule.js</code>를 참조할 것입니다.</p> <ol start=\"3\"> <li>\n<code>index.js</code> 라는 파일을 포함하고 있으면, <code>/root/src/moduleB</code> 확인하기. 이 파일은 폴더의 “main” 모듈임을 암시적으로 나타냅니다.</li> </ol> <p>자세한 내용은 Node.js 문서 <a href=\"https://nodejs.org/api/modules.html#modules_file_modules\">파일 모듈</a>과 <a href=\"https://nodejs.org/api/modules.html#modules_folders_as_modules\">폴더 모듈</a>에서 더 읽어보실 수 있습니다.</p> <p>그러나, <a href=\"#relative-vs-non-relative-module-imports\">비-상대적 모듈 이름</a>에 대한 해석은 다르게 수행합니다. Node는 <code>node_modules</code>로 불리는 특별한 폴더에서 모듈을 찾을 것입니다. <code>node_modules</code> 폴더는 현재 파일과 동일한 레벨이거나, 디렉터리 체인에서 더 높을 수도 있습니다. Node는 디렉터리 체인을 올라가, 로드하려는 모듈을 찾을 때까지 각 <code>node_modules</code>을 찾습니다.</p> <p>위의 예제를 따라서, <code>/root/src/moduleA.js</code>가 대신 비-상대적 경로를 사용하고 <code>var x = require(\"moduleB\");</code> import를 가지고 있다고 생각해봅시다. Node는 하나가 일치할 때까지 각 위치에서 <code>moduleB</code>를 해석하려고 시도합니다.</p> <ol> <li><code>/root/src/node_modules/moduleB.js</code></li> <li>\n<code>/root/src/node_modules/moduleB/package.json</code> (<code>\"main\"</code> 항목을 지정했다면)</li> <li>\n<code>/root/src/node_modules/moduleB/index.js</code> <br><br>\n</li> <li><code>/root/node_modules/moduleB.js</code></li> <li>\n<code>/root/node_modules/moduleB/package.json</code> (<code>\"main\"</code> 항목을 지정했다면)</li> <li>\n<code>/root/node_modules/moduleB/index.js</code> <br><br>\n</li> <li><code>/node_modules/moduleB.js</code></li> <li>\n<code>/node_modules/moduleB/package.json</code> (<code>\"main\"</code> 항목을 지정했다면)</li> <li><code>/node_modules/moduleB/index.js</code></li> </ol> <p>Node.js가 (4) 와 (7)에서 디렉터리를 점프했다는 것에 주목하세요.</p> <p>프로세스에 대한 더 많은 정보는 Node.js 문서 <a href=\"https://nodejs.org/api/modules.html#modules_loading_from_node_modules_folders\"><code>node_modules</code>에서 모듈 로드하기</a>에서 읽어보실 수 있습니다.</p> <h4 id=\"typescript가-모듈을-해석하는-방법-how-typescript-resolves-modules\" style=\"position:relative;\">TypeScript가 모듈을 해석하는 방법 (How TypeScript resolves modules)</h4> <p>TypeScript는 컴파일-타임에 모듈의 정의 파일 위치를 찾기 위해 Node.js의 런타임 해석 전략을 모방합니다. 이를 달성하기 위해, TypeScript는 TypeScript 소스 파일 확장자 (<code>.ts</code>, <code>.tsx</code> 와 <code>.d.ts</code>)를 Node의 해석 로직 위에 씌웁니다. TypeScript는 <code>\"main\"</code>의 목적 - 컴파일러가 이를 사용하여 참조할 “main” 정의 파일을 찾음. 을 반영하기 위해 <code>\"types\"</code>라는 <code>package.json</code>안에 필드를 사용합니다</p> <p>예를 들어, <code>/root/src/moduleA.ts</code>안에 <code>import { b } from \"./moduleB\"</code> 같은 import 문은 <code>\"./moduleB\"</code>의 위치를 찾기 위해 다음과 같은 위치를 찾습니다.</p> <ol> <li><code>/root/src/moduleB.ts</code></li> <li><code>/root/src/moduleB.tsx</code></li> <li><code>/root/src/moduleB.d.ts</code></li> <li>\n<code>/root/src/moduleB/package.json</code> (<code>\"types\"</code> 항목을 지정했다면)</li> <li><code>/root/src/moduleB/index.ts</code></li> <li><code>/root/src/moduleB/index.tsx</code></li> <li><code>/root/src/moduleB/index.d.ts</code></li> </ol> <p>Node.js가 <code>moduleB.js</code> 파일을 찾고 나서, 해당하는 <code>package.json</code>을 찾고, <code>index.js</code>를 찾았다는 것을 상기해봅시다.</p> <p>비슷하게, 비-상대적 import는 Node.js 해석 로직을 따릅니다, 첫 번째로 파일을 찾고, 그러고 나서 해당하는 폴더를 찾습니다. 그래서 <code>/root/src/moduleA.ts</code> 소스 파일 안에 <code>import { b } from \"moduleB\"</code>는 다음과 같은 조회를 합니다.</p> <ol> <li><code>/root/src/node_modules/moduleB.ts</code></li> <li><code>/root/src/node_modules/moduleB.tsx</code></li> <li><code>/root/src/node_modules/moduleB.d.ts</code></li> <li>\n<code>/root/src/node_modules/moduleB/package.json</code> (<code>\"types\"</code> 프로퍼티를 지정했다면)</li> <li><code>/root/src/node_modules/@types/moduleB.d.ts</code></li> <li><code>/root/src/node_modules/moduleB/index.ts</code></li> <li><code>/root/src/node_modules/moduleB/index.tsx</code></li> <li>\n<code>/root/src/node_modules/moduleB/index.d.ts</code> <br><br>\n</li> <li><code>/root/node_modules/moduleB.ts</code></li> <li><code>/root/node_modules/moduleB.tsx</code></li> <li><code>/root/node_modules/moduleB.d.ts</code></li> <li>\n<code>/root/node_modules/moduleB/package.json</code> (<code>\"types\"</code> 항목을 지정했다면)</li> <li><code>/root/node_modules/@types/moduleB.d.ts</code></li> <li><code>/root/node_modules/moduleB/index.ts</code></li> <li><code>/root/node_modules/moduleB/index.tsx</code></li> <li>\n<code>/root/node_modules/moduleB/index.d.ts</code> <br><br>\n</li> <li><code>/node_modules/moduleB.ts</code></li> <li><code>/node_modules/moduleB.tsx</code></li> <li><code>/node_modules/moduleB.d.ts</code></li> <li>\n<code>/node_modules/moduleB/package.json</code> (<code>\"types\"</code> 항목을 지정했다면)</li> <li><code>/node_modules/@types/moduleB.d.ts</code></li> <li><code>/node_modules/moduleB/index.ts</code></li> <li><code>/node_modules/moduleB/index.tsx</code></li> <li><code>/node_modules/moduleB/index.d.ts</code></li> </ol> <p>스텝 수 때문에 두려워하지 마세요 - TypeScript가 여전히 디렉터리를 (9)와 (17)에서 두 번 점프합니다.</p> <p>Node.js가 하는 것보다 더 복잡하지 않습니다.</p> <h2 id=\"추가-모듈-해석-플래그-additional-module-resolution-flags\" style=\"position:relative;\">추가 모듈 해석 플래그 (Additional module resolution flags)</h2> <p>프로젝트 소스 레이아웃이 출력과 일치하지 않을 때도 있습니다. 일반적으로 일련의 빌드 스텝이 생성된 최종 출력을 만듭니다. <code>.ts</code>파일을 <code>.js</code>로 컴파일하고, 다른 소스 위치에서 하나의 출력 위치로 의존성을 복사하는 것을 포함합니다. 최종 결과는 런타임의 모듈이 해당 정의를 포함하는 소스 파일과 다른 이름을 가질 수 있다는 것이다. 혹은 최종 출력의 모듈 경로가 컴파일 타임에 해당하는 소스 파일 경로와 일치하지 않을 수 있습니다.</p> <p>TypeScript 컴파일러는 추가 플래그를 갖고 있습니다. The TypeScript compiler has a set of additional flags to <em>inform</em> the compiler of transformations that are expected to happen to the sources to generate the final output. TypeScript 컴파일러는 최종 출력을 생성하기위해 소스에 발생할 것으로 예상되는 변환을 컴파일러에게 <em>알리기</em> 위한 추가 플래그 세트가 있습니다.</p> <p>컴파일러가 이러한 변환도 수행하지 <em>않는</em> 다는 것에 유의하십시오; 정의 파일로 모듈 import를 해석하는 과정을 안내하기 위해 이러한 정보를 사용합니다.</p> <h3 id=\"기본-url-base-url\" style=\"position:relative;\">기본 URL (Base URL)</h3> <p><code>baseUrl</code>을 사용하는 것은 모듈들이 런타임에 단일 폴더로 “배포”되는 AMD 모듈 로더를 사용하는 애플리케이션에서 일반적인 방법입니다. 이 모듈들의 소스는 다른 디렉터리 안에 있을 수 있지만, 빌드 스크립트가 모두 하나로 만들 것입니다.</p> <p><code>baseUrl</code>을 설정하는 것은 컴파일러에게 어디에서 모듈을 찾을지 알려주는 것입니다. 모든 비-상대적 이름의 모듈 import는 <code>baseUrl</code>에 상대적이라고 가정합니다.</p> <p><em>baseUrl</em>의 값은 다음 중 하나로 결정됩니다:</p> <ul> <li>\n<em>baseUrl</em> 명령 줄 인수 값 (만약 주어진 경로가 상대적이면, 현재 디렉터리를 기준으로 계산됨)</li> <li>‘tsconfig.json’안에 <em>baseUrl</em> 프로퍼티 값 (만약 주어진 경로가 상대적이면, ‘tsconfig.json’의 위치를 기준으로 계산됨)</li> </ul> <p>상대적 모듈 import는 항상 가져온 파일의 상대적으로 해석되기 때문에, baseUrl을 설정하는 것에 영향을 받지 않는 점에 유의하십시오.</p> <p>baseUrl에 대한 더 많은 문서는 <a href=\"http://requirejs.org/docs/api.html#config-baseUrl\">RequireJS</a>와 <a href=\"https://github.com/systemjs/systemjs/blob/master/docs/config-api.md#baseurl\">SystemJS</a> 문서에서 찾으실 수 있습니다.</p> <h3 id=\"경로-매핑-path-mapping\" style=\"position:relative;\">경로 매핑 (Path mapping)</h3> <p>가끔 모듈이 <em>baseUrl</em> 아래에 위치하지 않는 경우가 있습니다. 예를 들어, <code>\"jquery\"</code> 모듈의 import는 런타임에 <code>\"node_modules/jquery/dist/jquery.slim.min.js\"</code>로 번역됩니다. 로더는 런타임에 모듈 이름을 파일에 매핑하기 위해 매핑 구성을 사용합니다, <a href=\"http://requirejs.org/docs/api.html#config-paths\">RequireJs 문서</a>와 <a href=\"https://github.com/systemjs/systemjs/blob/master/docs/config-api.md#paths\">SystemJS 문서</a>를 보세요.</p> <p>TypeScript 컴파일러는 <code>tsconfig.json</code> 파일 안에 <code>\"paths\"</code> 프로퍼티를 사용한 매핑의 선언을 지원합니다. <code>jquery</code>를 위한 <code>\"paths\"</code> 프로퍼티를 지정하는 방법에 대한 예제가 있습니다.</p> <pre data-language=\"json\">{\n  \"compilerOptions\": {\n    \"baseUrl\": \".\", // \"paths\"가 있는 경우 반드시 지정되어야함.\n    \"paths\": {\n      \"jquery\": [\"node_modules/jquery/dist/jquery\"] // 이 매핑은 \"baseUrl\"에 상대적임.\n    }\n  }\n}</pre> <p><code>\"paths\"</code>가 <code>\"baseUrl\"</code>에 상대적으로 해석된다는 점에 주목하세요. <code>\"baseUrl\"</code>을 <code>\".\"</code>가 아닌 다른 값, 예 <code>tsconfig.json</code>의 디렉터리,으로 설정하면, 그에 따라 매핑도 바뀝니다. 만약 위 예제에서 “baseUrl”: “./src” 로 설정한다면, jquery는 “../node_modules/jquery/dist/jquery” 로 매핑되어야 합니다.</p> <p><code>\"paths\"</code>를 사용하는 것은 여러 개의 이전 위치를 포함한 정교한 매핑이 가능합니다. 일부 모듈만 한 위치에서 사용 가능하고, 나머지는 다른 곳에 있는 프로젝트 구성을 생각해보세요. 빌드 스텝이 한곳으로 모을 것입니다. 프로젝트의 레이아웃은 다음과 같이 보입니다:</p> <pre data-language=\"typescript\">projectRoot\n├── folder1\n│   ├── file1.ts (imports 'folder1/file2' and 'folder2/file3')\n│   └── file2.ts\n├── generated\n│   ├── folder1\n│   └── folder2\n│       └── file3.ts\n└── tsconfig.json</pre> <p><code>tsconfig.json</code>는 다음과 같이 보일 것입니다:</p> <pre data-language=\"json\">{\n  \"compilerOptions\": {\n    \"baseUrl\": \".\",\n    \"paths\": {\n      \"*\": [\n        \"*\",\n        \"generated/*\"\n      ]\n    }\n  }\n}</pre> <p>이는 컴파일러에게 두 위치에서 패턴 <code>\"*\"</code> (i.e. 모든 값) 과 일치하는 모든 모듈 import를 알려줍니다</p> <ol> <li>\n<code>\"*\"</code>: 같은 이름은 바뀌지 않음을 의미, 그래서 <code>&lt;moduleName&gt;</code> =&gt; <code>&lt;baseUrl&gt;/&lt;moduleName&gt;</code>으로 매핑</li> <li>\n<code>\"generated/*\"</code> 접두사 “generated”가 추가된 모듈 이름을 의미, 그래서 <code>&lt;moduleName&gt;</code> =&gt; <code>&lt;baseUrl&gt;/generated/&lt;moduleName&gt;</code>로 매핑</li> </ol> <p>이 로직을 따르면, 컴파일러는 다음과 같은 두 가지 import를 해석하려고 할 것입니다:</p> <p>import ‘folder1/file2’:</p> <ol> <li>모듈 ’*‘은 일치하고 와일드카드가 전체 모듈 이름을 캡처함</li> <li>목록에서 첫 번째 대체 시도: ’*’ -&gt; <code>folder1/file2</code>\n</li> <li>대체의 결과가 비-상대적 이름 - <em>baseUrl</em>과 결합 -&gt; <code>projectRoot/folder1/file2.ts</code>\n</li> <li>파일이 존재. 완료.</li> </ol> <p>import ‘folder2/file3’:</p> <ol> <li>모듈 ’*‘은 일치하고 와일드카드가 전체 모듈 이름을 캡처함</li> <li>목록에서 첫 번째 대체 시도: ’*’ -&gt; <code>folder2/file3</code>\n</li> <li>대체의 결과가 비-상대적 이름 - <em>baseUrl</em>과 결합 -&gt; <code>projectRoot/folder2/file3.ts</code>\n</li> <li>파일이 존재하지 않음, 두 번째 대체로 이동</li> <li>두 번째 대체 ‘generated/*’ -&gt; <code>generated/folder2/file3</code>\n</li> <li>대체의 결과가 비-상대적 이름 - <em>baseUrl</em>과 결합 -&gt; <code>projectRoot/generated/folder2/file3.ts</code>\n</li> <li>파일이 존재. 완료.</li> </ol> <h3 id=\"rootdirs-가상-디렉터리-virtual-directories-with-rootdirs\" style=\"position:relative;\">\n<code>rootDirs</code> 가상 디렉터리 (Virtual Directories with <code>rootDirs</code>)</h3> <p>때때로 컴파일 타임에 여러 디렉터리의 프로젝트 소스가 모두 결합되어 단일 출력 디렉터리를 생성합니다. 여러 소스 디렉터리가 “가상” 디렉터리를 생성하는 것으로 보입니다.</p> <p>‘rootDirs’를 사용하면, 컴파일러에게 이 “가상” 디렉터리를 구성하는 <em>roots</em>를 알릴 수 있습니다; 따라서 컴파일러는 이러한 “가상”디렉터리 내에서 상대적 모듈 import를 <em>마치</em> 하나의 디렉터리에 같이 병합 한 것처럼 해석할 수 있습니다.</p> <p>예를 들어 이 프로젝트 구조를 생각해보세요:</p> <pre data-language=\"typescript\"> src\n └── views\n     └── view1.ts (imports './template1')\n     └── view2.ts\n\n generated\n └── templates\n         └── views\n             └── template1.ts (imports './view2')</pre> <p><code>src/views</code> 안의 파일들은 UI 컨트롤을 위한 유저 코드입니다. <code>generated/templated</code> 안의 파일들은, 빌드의 일부로써 템플릿 생성기에 의해 자동-생성된 UI 템플릿 바인딩 코드입니다. 빌드 스텝은 <code>/src/view</code>와 <code>/generated/templates/views</code>를 출력에서 같은 디렉터리로 복사합니다. 런타임에서, 뷰는 템플릿이 옆에 있다고 기대할 것이기 때문에, <code>\"./template\"</code>처럼 상대적인 이름을 import에서 사용해야 합니다.</p> <p>컴파일러에게 이 관계를 지정하기 위해서, <code>\"rootDirs\"</code>를 사용합니다. <code>\"rootDirs\"</code>는 내용물이 런타임에 병합할 것으로 예상되는 <em>roots</em> 의 목록을 지정합니다. 그래서 다음의 예제에서, <code>tsconfig.json</code> 파일은 다음과 같아야 합니다:</p> <pre data-language=\"json\">{\n  \"compilerOptions\": {\n    \"rootDirs\": [\n      \"src/views\",\n      \"generated/templates/views\"\n    ]\n  }\n}</pre> <p>컴파일러가 <code>rootDirs</code> 중 하나의 하위 폴더에서 상대적 모듈 import를 볼 때마다, 각 <code>rootDirs</code>의 엔트리에서 이 import를 찾으려고 할 것입니다.</p> <p><code>rootDirs</code>의 유연함은 논리적으로 병합되는 물리적 소스 디렉터리의 목록을 지정하는데 제한되지 않습니다. 제공되는 배열은 아마 존재 여부에 관계없이 임의의 수의 ad hoc, 임의의 디렉터리 이름을 포함할 수 있습니다. 이는 컴파일러에게 조건부 포함과 프로젝트 전용 로더 플러그인과 같은 복잡한 번들링과 런타임 기능을 안전한 방법으로 캡처할 수 있게 해줍니다.</p> <p><code>./#{locale}/messages</code>와 같은 상대 모듈 경로의 일부로 <code>#{locale}</code>와 같은 특수 경로 토큰을 보간하여 빌드 툴이 로케일 전용 번들을 자동으로 생성하는 국제화 시나리오를 고려해봅시다. 이 가상의 설정에서 툴이 지원하는 로케일을 열거하고, 추상 경로를 <code>./zh/messages</code>, <code>./de/messages</code> 등으로 매핑 합니다.</p> <p>각 모듈은 문자열 배열을 export 한다고 가정합니다. 예를 들어 <code>./zh/messages</code>는 다음을 포함합니다:</p> <pre data-language=\"ts\">export default [\n    \"您好吗\",\n    \"很高兴认识你\"\n];</pre> <p><code>rootDirs</code>를 활용하여 컴파일러에게 이 매핑에 대해 알려주어 심지어 디렉터리가 존재하지 않아도 안전하게 <code>./#{locale}/messages</code>를 해석할 수 있도록 합니다. 예를 들어, 다음과 같은 <code>tsconfig.json</code>를 보십시오:</p> <pre data-language=\"json\">{\n  \"compilerOptions\": {\n    \"rootDirs\": [\n      \"src/zh\",\n      \"src/de\",\n      \"src/#{locale}\"\n    ]\n  }\n}</pre> <p>컴파일러는 이제 ‘./#{locale}/messages’<code>를 './zh/messages'</code>로 해석하여 설계 시간 지원을 타협하지 않고 로케일에 관계없는 방법으로 개발할 수 있습니다.</p> <h2 id=\"모듈-해석-추적-tracing-module-resolution\" style=\"position:relative;\">모듈 해석 추적 (Tracing module resolution)</h2> <p>앞에서 논의한 바와 같이 컴파일러는 모듈을 해석할 때 현재 폴더 외부의 파일을 방문할 수 있습니다. 이는 모듈이 해석되지 않거나 잘못된 정의로 해석된 이유를 진단할 때 어려울 수 있습니다. ‘—traceResolution’을 사용하여 컴파일러 모듈 해석 추적을 활성화하면 모듈 해석 과정 중에 발생한 작업에 대한 인사이트를 얻을 수 있습니다.</p> <p><code>typescript</code> 모듈을 사용하는 예제 애플리케이션이 있다고 해봅시다. <code>app.ts</code>는 <code>import * as ts from \"typescript\"</code> 같은 import가 있습니다.</p> <pre data-language=\"typescript\">│   tsconfig.json\n├───node_modules\n│   └───typescript\n│       └───lib\n│               typescript.d.ts\n└───src\n        app.ts</pre> <p><code>--traceResolution</code>으로 컴파일러를 호출</p> <pre data-language=\"shell\">tsc --traceResolution</pre> <p>다음과 같은 출력이 발생:</p> <pre data-language=\"txt\">======== Resolving module 'typescript' from 'src/app.ts'. ========\nModule resolution kind is not specified, using 'NodeJs'.\nLoading module 'typescript' from 'node_modules' folder.\nFile 'src/node_modules/typescript.ts' does not exist.\nFile 'src/node_modules/typescript.tsx' does not exist.\nFile 'src/node_modules/typescript.d.ts' does not exist.\nFile 'src/node_modules/typescript/package.json' does not exist.\nFile 'node_modules/typescript.ts' does not exist.\nFile 'node_modules/typescript.tsx' does not exist.\nFile 'node_modules/typescript.d.ts' does not exist.\nFound 'package.json' at 'node_modules/typescript/package.json'.\n'package.json' has 'types' field './lib/typescript.d.ts' that references 'node_modules/typescript/lib/typescript.d.ts'.\nFile 'node_modules/typescript/lib/typescript.d.ts' exist - use it as a module resolution result.\n======== Module name 'typescript' was successfully resolved to 'node_modules/typescript/lib/typescript.d.ts'. ========</pre> <h4 id=\"주의사항-things-to-look-out-for\" style=\"position:relative;\">주의사항 (Things to look out for)</h4> <ul> <li>import의 이름과 위치</li> </ul> <blockquote> <p>======== <strong>‘src/app.ts’</strong> 에서 <strong>‘typesciprt’</strong> 모듈 해석. ========</p> </blockquote> <ul> <li>컴파일러가 따르는 전략</li> </ul> <blockquote> <p>모듈 해석 종류가 지정되지 않으면, <strong>‘NodeJs</strong> 사용.</p> </blockquote> <ul> <li>npm 패키지에서 types 로딩</li> </ul> <blockquote> <p>‘package.json’은 ‘node_modules/typescript/lib/typescript.d.ts’를 참조하는 <strong>‘types’</strong> 필드 ‘./lib/typescript.d.ts’가 있습니다.</p> </blockquote> <ul> <li>최종 결과</li> </ul> <blockquote> <p>======== 모듈 이름 ‘typescript’는 ‘node_modules/typescript/lib/typescript.d.ts’로 <strong>성공적으로 해석</strong> 되었습니다. ========</p> </blockquote> <h2 id=\"--noresolve-사용하기-using---noresolve\" style=\"position:relative;\">\n<code>--noResolve</code> 사용하기 (Using <code>--noResolve</code>)</h2> <p>일반적으로 컴파일러는 컴파일 과정을 시작하기 전에 모든 모듈 import를 해석하려고 합니다. 파일의 <code>import</code>를 성공적으로 해석할 때마다, 파일은 나중에 컴파일러가 처리할 파일 세트에 추가됩니다.</p> <p><code>--noResolve</code> 컴파일러 옵션은 명령 줄에 전달하지 않은 파일은 컴파일에 “추가” 하지 않도록 지시합니다. 여전히 파일에 모듈을 해석하려고 하지만, 파일이 지정되지 않았으면, 그 파일은 포함하지 않습니다.</p> <p>예를 들어:</p> <h4 id=\"appts\" style=\"position:relative;\">app.ts</h4> <pre data-language=\"ts\">import * as A from \"moduleA\" // 성공, 'moduleA'가 명령줄로 전달됨\nimport * as B from \"moduleB\" // Error TS2307: Cannot find module 'moduleB.</pre> <pre data-language=\"shell\">tsc app.ts moduleA.ts --noResolve</pre> <p><code>--noResolve</code>를 사용한 <code>app.ts</code>의 컴파일은 다음과 같은 결과가 나옵니다:</p> <ul> <li>명령 줄로 전달했기 때문에 <code>moduleA</code>는 정확하게 찾음.</li> <li>전달하지 않았기 때문에 <code>moduleB</code>를 찾는데 실패함.</li> </ul> <h2 id=\"공통-질문-common-questions\" style=\"position:relative;\">공통 질문 (Common Questions)</h2> <h3 id=\"제외-목록에-있는-모듈을-여전히-컴파일러가-선택하는-이유는-무엇인가-why-does-a-module-in-the-exclude-list-still-get-picked-up-by-the-compiler\" style=\"position:relative;\">제외 목록에 있는 모듈을 여전히 컴파일러가 선택하는 이유는 무엇인가? (Why does a module in the exclude list still get picked up by the compiler?)</h3> <p><code>tsconfig.json</code>은 폴더를 “프로젝트”로 바꿉니다. <code>\"exclude\"</code> 나 <code>\"files\"</code> 엔트리를 지정하지 않으면, <code>tsconfig.json</code>를 포함하는 폴더 안의 모든 파일과 모든 하위-디렉터리가 컴파일에 포함됩니다. 만약 일부 파일을 제외하고 싶으면 <code>\"exclude\"</code>를 사용하고, 컴파일러가 찾도록 하게 하는 대신 모든 파일을 지정하고 싶으면, <code>\"files\"</code>를 사용하십시오.</p> <p><code>tsconfig.json</code>의 자동 포함입니다. 위에서 논의한 내장 모듈 해석이 아닙니다. 컴파일러는 파일을 모듈 import 대상으로 식별한 경우, 이전 단계에서 제외되었는지에 관계없이 컴파일에 포함하게 됩니다.</p> <p>그래서 컴파일에 파일은 제외하기 위해서는, 그 파일을 제외하고 그 파일에 <code>import</code>나 <code>/// &lt;reference path=\"...\"\" /&gt;</code> 지시문이 있는 <strong>모든</strong> 파일을 제외해야 합니다.</p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2012-2023 Microsoft<br>Licensed under the Apache License, Version 2.0.<br>\n    <a href=\"https://www.typescriptlang.org/ko/docs/handbook/module-resolution.html\" class=\"_attribution-link\">https://www.typescriptlang.org/ko/docs/handbook/module-resolution.html</a>\n  </p>\n</div>\n","typescript-in-5-minutes-func":"<h1>TypeScript for Functional Programmers</h1>\n<p>TypeScript는 웹에 전통적인 객체 지향 프로그램를 가져오기 위해서 마이크로소프트 프로그래머들이 JavaScript에 전통적인 객체 지향 타입을 가져오기 위한 시도로 시작되었습니다. 개발되어 가면서 TypeScript의 타입 시스템은 네이티브 자바스크립터가 작성한 모델 코드로 발전되었습니다. 결과적인 시스템은 강력하면서 흥미롭고 지저분합니다.</p> <p>이 소개는 TypeScript를 배우고자 하는 Haskell 또는 ML 프로그래머를 위해 만들어졌습니다. Haskell 타입 시스템과 TypeScript 타입 시스템의 차이를 설명합니다. 또한 JavaScript 코드의 모델링에서 발생하는 TypeScript 타입 시스템의 독특한 특징을 설명합니다.</p> <p>이 소개에서는 객체 지향 프로그래밍을 다루지 않습니다. 실제로, TypeScript의 객체 지향 프로그램은 OO 기능이 있는 다른 인기 언어의 프로그램과 유사합니다.</p> <h1 id=\"전제조건-prerequisites\" style=\"position:relative;\">전제조건 (Prerequisites)</h1> <p>본 서론에서는 다음 사항을 알고 있다고 가정합니다:</p> <ul> <li>JavaScript로 프로그래밍 하기 위한 핵심 개념.</li> <li>C 계열 언어의 타입 구문.</li> </ul> <p>JavaScript의 핵심 개념을 배우고 싶다면 <a href=\"http://shop.oreilly.com/product/9780596517748.do\">JavaScript: The Good Parts</a>를 추천합니다. 많은 가변성을 가진 call-by-value 렉시컬한 스코프 언어로 프로그램을 작성하는 방법을 알고 있다면 굳이 책을 안 읽어도 상관없습니다. <a href=\"https://people.csail.mit.edu/jaffer/r4rs.pdf\">R<sup>4</sup>RS Scheme</a>가 좋은 예입니다.</p> <p><a href=\"http://www.stroustrup.com/4th.html\">C++ 프로그래밍 언어</a>는 C-스타일 타입 구문에 대해서 배우기 좋습니다. C++ 달리 TypeScript는 후위 타입을 사용합니다, 예를 들면: <code>string x</code> 대신에 <code>x: string</code>.</p> <h1 id=\"haskell에는-없는-개념-concepts-not-in-haskell\" style=\"position:relative;\">Haskell에는 없는 개념 (Concepts not in Haskell)</h1> <h2 id=\"내장-타입-built-in-types\" style=\"position:relative;\">내장 타입 (Built-in types)</h2> <p>JavaScript에서는 8개의 내장 타입을 정의합니다:</p> <table> <thead> <tr> <th>타입</th> <th>설명</th> </tr> </thead> <tbody> <tr> <td><code>Number</code></td> <td>배정밀도 IEEE 754 부동소수점.</td> </tr> <tr> <td><code>String</code></td> <td>수정 불가능한 UTF-16 문자열.</td> </tr> <tr> <td><code>BigInt</code></td> <td>임의 정밀도 형식의 정수.</td> </tr> <tr> <td><code>Boolean</code></td> <td>\n<code>true</code> 와 <code>false</code>.</td> </tr> <tr> <td><code>Symbol</code></td> <td>보통 키로 사용하는 고유한 값.</td> </tr> <tr> <td><code>Null</code></td> <td>단위 타입과 동등.</td> </tr> <tr> <td><code>Undefined</code></td> <td>또한 단위 타입과 동등.</td> </tr> <tr> <td><code>Object</code></td> <td>레코드와 유사한 것.</td> </tr> </tbody> </table> <p><a href=\"https://developer.mozilla.org/docs/Web/JavaScript/Data_structures\">자세한 내용은 MDN 페이지를 참고하세요</a>.</p> <p>TypeScript에는 기본 내장된 타입에 해당하는 원시 타입이 있습니다:</p> <ul> <li><code>number</code></li> <li><code>string</code></li> <li><code>bigint</code></li> <li><code>boolean</code></li> <li><code>symbol</code></li> <li><code>null</code></li> <li><code>undefined</code></li> <li><code>object</code></li> </ul> <h3 id=\"다른-중요한-typescript-타입-other-important-typescript-types\" style=\"position:relative;\">다른 중요한 TypeScript 타입 (Other important TypeScript types)</h3> <table> <thead> <tr> <th>타입</th> <th>설명</th> </tr> </thead> <tbody> <tr> <td><code>unknown</code></td> <td>최상위 타입.</td> </tr> <tr> <td><code>never</code></td> <td>하위 타입.</td> </tr> <tr> <td>객체 리터럴</td> <td>예, <code>{ property: Type }</code>\n</td> </tr> <tr> <td><code>void</code></td> <td>리턴 타입으로 사용하기 위해 의도된 <code>undefined</code> 의 서브타입.</td> </tr> <tr> <td><code>T[]</code></td> <td>수정가능한 배열들, 또한 <code>Array&lt;T&gt;</code> 으로 사용가능</td> </tr> <tr> <td><code>[T, T]</code></td> <td>고정된 길이지만 수정 가능한 튜플</td> </tr> <tr> <td><code>(t: T) =&gt; U</code></td> <td>함수</td> </tr> </tbody> </table> <p>유의하세요:</p> <ol> <li> <p>함수 구문에는 매개변수 이름이 포함되어 있습니다. 익숙해지기 꽤 어렵습니다!</p> <pre data-language=\"ts\">let fst: (a: any, d: any) =&gt; any = (a, d) =&gt; a;\n// 또는 좀 더 정확하게 말하자면:\nlet snd: &lt;T, U&gt;(a: T, d: U) =&gt; U = (a, d) =&gt; d;</pre> </li> <li> <p>객체 리터럴 타입 구문이 객체 리터럴 값 구문과 꽤 유사합니다:</p> <pre data-language=\"ts\">let o: { n: number; xs: object[] } = { n: 1, xs: [] };</pre> </li> <li> <p><code>[T, T]</code> 는 <code>T[]</code> 의 서브타입입니다. Haskell과 달리, 튜플은 리스트와 관련이 없습니다.</p> </li> </ol> <h3 id=\"박스-형태-타입-boxed-types\" style=\"position:relative;\">박스 형태 타입 (Boxed types)</h3> <p>JavaScript는 프로그래머들이 해당 타입에 접근할 수 있는 메서드를 포함하는 원시타입을 동등하게 박스해 왔습니다. 예를 들면, 원시 형태의 <code>number</code> 과 박스 형태 타입의 <code>Number</code>의 다른 점을 TypeScript는 반영해왔습니다. 박스 형태 타입은 메서드가 원시 타입을 반환할 때 아주 드물게 필요합니다.</p> <pre data-language=\"ts\">(1).toExponential();\n// 동등하게\nNumber.prototype.toExponential.call(1);</pre> <p>숫자 리터럴에서 메서드를 호출하려면 파서를 지원하기 위해 메서드를 괄호 안에 넣어야 한다는 점에 유의하십시오.</p> <h2 id=\"점진적인-타이핑-gradual-typing\" style=\"position:relative;\">점진적인 타이핑 (Gradual typing)</h2> <p>TypeScript는 표현식의 타입을 알 수 없을 때마다 <code>any</code> 타입을 사용합니다. <code>Dynamic</code>와 비교하면,<code>any</code> 는 타입이라고 부르기에 과하다고 할 수도 있습니다. 이 타입이 나타날 때마다 타입을 체크하지 않습니다. 예를 들어, <code>any[]</code> 에 어떤 값이든 체크하지 않고 넣어도 상관없습니다:</p> <pre data-language=\"ts\">// tsconfig.json 파일에 \"noImplicitAny\": false 를 삽입, anys: any[]\nconst anys = [];\nanys.push(1);\nanys.push(\"oh no\");\nanys.push({ anything: \"goes\" });</pre> <p>그리고 <code>any</code> 타입은 어디서든 간에 사용가능합니다:</p> <pre data-language=\"ts\">anys.map(anys[1]); // 오 안되죠, \"oh no\" 함수가 아닙니다.</pre> <p><code>any</code> 전염될 수 있는데, 역시 — 만약에 <code>any</code> 타입의 표현식과 함께 변수를 초기화하면, 변수 역시 <code>any</code> 타입을 가집니다.</p> <pre data-language=\"ts\">let sepsis = anys[0] + anys[1]; // 어떤 의미로도 가능합니다.</pre> <p>TypeScript가 <code>any</code>를 제공할 때 에러를 발생시키려면, <code>tsconfig.json</code>에서 <code>\"noImplicitAny\": true</code> 또는 <code>\"strict\": true</code>를 설정해야 합니다.</p> <h2 id=\"구조적인-타이핑-structural-typing\" style=\"position:relative;\">구조적인 타이핑 (Structural typing)</h2> <p>비록 Haskell과 대부분의 ML은 구조적으로 타이핑하지 않지만, 구조적 타이핑은 대부분의 함수형 프로그래머에게는 익숙한 개념입니다. 기본 형태는 아주 간단합니다:</p> <pre data-language=\"ts\">// @strict: false\nlet o = { x: \"hi\", extra: 1 }; // 성공\nlet o2: { x: string } = o; // 성공</pre> <p>여기서, 객체 리터럴 <code>{ x: \"hi\", extra : 1 }</code>에 매치되는 <code>{ x : string, extra : number }</code> 가 있습니다. 이 타입은 필수 프로퍼티가 모두 있고 해당 프로퍼티에 할당 가능한 타입이 있으므로 <code>{ x : string }</code> 에 할당할 수 있습니다. 나머지 프로퍼티는 할당을 막지 않고, <code>{x : string}</code>의 서브타입으로 만듭니다.</p> <p>네임드 타입들은 타입에서 이름을 붙일 뿐입니다. 할당을 위해서라면 타입 별칭 <code>One</code> 과 인터페이스 타입 <code>Two</code> 사이에는 별 다른 점이 없습니다. 둘 다 <code>p: string</code> 프로퍼티를 가지고 있습니다. (단, 타입 별칭은 재귀 정의와 타입 매개변수에 관련한 인터페이스에서는 다르게 동작합니다.)</p> <pre data-language=\"ts\">// @errors: 2322\ntype One = { p: string };\ninterface Two {\n  p: string;\n}\nclass Three {\n  p = \"Hello\";\n}\n\nlet x: One = { p: \"hi\" };\nlet two: Two = x;\ntwo = new Three();</pre> <h2 id=\"유니언-unions\" style=\"position:relative;\">유니언 (Unions)</h2> <p>TypeScript에서 유니언 타입은 태그되지 않습니다. 다르게 말하면, Haskell에서 <code>data</code> 와 달리 유니언은 구별하지 않습니다. 그러나 다른 프로퍼티나 내장된 태그를 사용하는 유니언으로 타입을 구별할 수 있습니다.</p> <pre data-language=\"ts\">function start(\n  arg: string | string[] | (() =&gt; string) | { s: string }\n): string {\n  // JavaScript에서 아주 일반적입니다\n  if (typeof arg === \"string\") {\n    return commonCase(arg);\n  } else if (Array.isArray(arg)) {\n    return arg.map(commonCase).join(\",\");\n  } else if (typeof arg === \"function\") {\n    return commonCase(arg());\n  } else {\n    return commonCase(arg.s);\n  }\n\n  function commonCase(s: string): string {\n    // 마지막으로, 다른 문자열로 변환합니다\n    return s;\n  }\n}</pre> <p><code>string</code>, <code>Array</code> 와 <code>Function</code> 은 타입 조건자가 내장되어 있고, <code>else</code> 브랜치를 위한 객체 타입은 편의를 위해 남겨두는 게 좋습니다. 그러나 런타임에 구별하기 어려운 유니언을 생성할 수 있습니다. 새로운 코드의 경우, 구별하는 유니언만 구축하는 게 가장 좋습니다.</p> <p>다음 타입들은 조건자를 가지고 있다:</p> <table> <thead> <tr> <th>타입</th> <th>조건자</th> </tr> </thead> <tbody> <tr> <td>string</td> <td><code>typeof s === \"string\"</code></td> </tr> <tr> <td>number</td> <td><code>typeof n === \"number\"</code></td> </tr> <tr> <td>bigint</td> <td><code>typeof m === \"bigint\"</code></td> </tr> <tr> <td>boolean</td> <td><code>typeof b === \"boolean\"</code></td> </tr> <tr> <td>symbol</td> <td><code>typeof g === \"symbol\"</code></td> </tr> <tr> <td>undefined</td> <td><code>typeof undefined === \"undefined\"</code></td> </tr> <tr> <td>function</td> <td><code>typeof f === \"function\"</code></td> </tr> <tr> <td>array</td> <td><code>Array.isArray(a)</code></td> </tr> <tr> <td>object</td> <td><code>typeof o === \"object\"</code></td> </tr> </tbody> </table> <p>함수와 배열은 런타임에서 객체이지만 고유의 조건자를 가지고 있다는 걸 기록합시다.</p> <h3 id=\"교집합\" style=\"position:relative;\">교집합</h3> <p>유니언과 더불어 TypeScript은 교집합까지 가지고 있습니다:</p> <pre data-language=\"ts\">type Combined = { a: number } &amp; { b: string };\ntype Conflicting = { a: number } &amp; { a: string };</pre> <p><code>Combined</code> 은 마치 하나의 객체 리터럴 타입으로 작성된 것 처럼 <code>a</code> 와 <code>b</code> 두 개의 속성을 가지고 있습니다. 교집합과 유니언은 재귀적인 케이스에서 충돌을 일으켜서 <code>Conflicting.a: number &amp; string</code> 입니다.</p> <h2 id=\"유닛-타입-unit-types\" style=\"position:relative;\">유닛 타입 (Unit types)</h2> <p>유닛 타입은 정확히 하나의 원시 값을 포함하고 있는 원시 타입의 서브타입입니다. 예를 들면, 문자열 <code>\"foo\"</code> 는 타입 <code>\"foo\"</code>를 가지고 있습니다. JavaScript는 내장된 enum이 없기 때문에 잘 알려진 문자열 세트를 대신해서 쓰는게 흔합니다. 문자열 리터럴 타입 유니언은 TypeScript에서 이 패턴을 따라갑니다:</p> <pre data-language=\"ts\">declare function pad(s: string, n: number, direction: \"left\" | \"right\"): string;\npad(\"hi\", 10, \"left\");</pre> <p>필요한 경우에 컴파일러로 확장가능합니다_ — 상위 타입으로 변환합니다 — 원시 타입에서 유닛 타입으로, <code>string</code>에서 <code>\"foo\"</code>으로 수정가능할 때 일어나며, 수정가능한 변수를 일부 사용할 때 제대로 동작하지 않을 수 있습니다:</p> <pre data-language=\"ts\">// @errors: 2345\ndeclare function pad(s: string, n: number, direction: \"left\" | \"right\"): string;\n// ---cut---\nlet s = \"right\";\npad(\"hi\", 10, s); // 오류: 'string'은 '\"left\" | \"right\"'에 할당할 수 없습니다.</pre> <p>이런 에러가 나타날 수 있습니다:</p> <p><em>-</em> <code>\"right\": \"right\"</code> <em>-</em> <code>s: string</code> 은 <code>\"right\"</code> 가 수정가능한 변수에 할당될 때 <code>string</code> 으로 확장이 가능합니다. <em>-</em> <code>string</code> 은 <code>\"left\" | \"right\"</code>에 할당할 수 없습니다.</p> <p><code>s</code>에 타입 표기를 사용하여 해결 가능하지만, 그 결과 <code>\"left\" | \"right\"</code> 타입이 아닌 변수가 <code>s</code>에 할당되는 것을 방지하게 됩니다.</p> <pre data-language=\"ts\">declare function pad(s: string, n: number, direction: \"left\" | \"right\"): string;\n// ---cut---\nlet s: \"left\" | \"right\" = \"right\";\npad(\"hi\", 10, s);</pre> <h1 id=\"haskell과-비슷한-개념-concepts-similar-to-haskell\" style=\"position:relative;\">Haskell과 비슷한 개념 (Concepts similar to Haskell)</h1> <h2 id=\"문맥적인-타이핑-contextual-typing\" style=\"position:relative;\">문맥적인 타이핑 (Contextual typing)</h2> <p>TypeScript는 변수 선언과 같이 타입을 추론할 수 있는 몇 가지 분명한 방법이 있습니다:</p> <pre data-language=\"ts\">let s = \"I'm a string!\";</pre> <p>하지만 다른 C-계열 언어로 작업한 적이 있다면 예상하지 못했던 다른 방법으로 타입 추론이 가능합니다:</p> <pre data-language=\"ts\">declare function map&lt;T, U&gt;(f: (t: T) =&gt; U, ts: T[]): U[];\nlet sns = map((n) =&gt; n.toString(), [1, 2, 3]);</pre> <p>여기에서, 이 예시의 <code>n: number</code>에서 또한, <code>T</code> 과 <code>U</code>는 호출 전에 추론되지 않았음에도 불구하고. 실제로 <code>[1,2,3]</code> 으로 <code>T=number</code>을 추론한 다음에, <code>n =&gt; n.toString()</code>의 리턴 타입으로 <code>U=string</code>을 추론하여, <code>sns</code>가 <code>string[]</code> 타입을 가지도록 합니다.</p> <p>추론은 어떤 순서로든 작동하지만, intellisense는 왼쪽에서 오른쪽으로만 작동하므로, TypeScript는 배열과 함께 <code>map</code>을 먼저 선언하는 것을 선호합니다:</p> <pre data-language=\"ts\">declare function map&lt;T, U&gt;(ts: T[], f: (t: T) =&gt; U): U[];</pre> <p>문맥적인 타이핑은 또한 객체 리터럴을 통해 재귀적으로 작동하며, 그렇지 않으면 <code>string</code>이나 <code>number</code>로 추론 가능한 유닛 타입으로 작동합니다. 그리고 문맥을 통해서 리턴 타입을 추론할 수 있습니다:</p> <pre data-language=\"ts\">declare function run&lt;T&gt;(thunk: (t: T) =&gt; void): T;\nlet i: { inference: string } = run((o) =&gt; {\n  o.inference = \"INSERT STATE HERE\";\n});</pre> <p><code>o</code> 의 타입은 <code>{ inference: string }</code> 으로 결정되었습니다. 왜냐하면</p> <ol> <li>선언 이니셜라이저는 선언 타입: <code>{ inference: string }</code>에 따라서 문맥적으로 타입이 정해집니다.</li> <li>호출의 리턴 타입은 추론을 위해 문맥적인 타입을 사용하기 때문에, 컴파일러는 <code>T={ inference: string }</code>으로 추론합니다.</li> <li>화살표 함수는 매개변수에 타입을 지정하기 위해 문맥적인 타입을 사용하므로, 컴파일러는 <code>o: { inference: string }</code>를 제공합니다.</li> </ol> <p>입력하는 동안, <code>o.</code> 를 타이핑 후에, 실제 프로그램에 있는 다른 속성과 함께 속성 <code>inference</code> 으로 보완할 수 있습니다. 이 기능은 TypeScript의 추론을 통해 통합적인 타입 추론 엔진처럼 보이겠지만, 그렇지 않습니다.</p> <h2 id=\"타입-별칭-type-aliases\" style=\"position:relative;\">타입 별칭 (Type aliases)</h2> <p>타입 별칭은 Haskell의 <code>type</code>과 마찬가지로 단순한 별칭입니다. 컴파일러는 소스 코드에서 사용된 별칭 이름을 사용하려고 시도하지만 항상 성공하지는 않습니다.</p> <pre data-language=\"ts\">type Size = [number, number];\nlet x: Size = [101.1, 999.9];</pre> <p><code>newtype</code>과 가장 유사한 것은 <em>태그된 교차 타입(tagged intersection)</em> 입니다:</p> <pre data-language=\"ts\">type FString = string &amp; { __compileTimeOnly: any };</pre> <p><code>FString</code>은 컴파일러가 실제로는 존재하지 않는 <code>__compileTimeOnly</code>라는 프로퍼티를 가지고 있다고 생각하는 점을 제외하면 일반 문자열과 같습니다. <code>FString</code>은 여전히 <code>string</code>에 할당 가능하지만, 그 반대는 불가능하다는 것을 의미합니다.</p> <h2 id=\"판별-유니언-discriminated-unions\" style=\"position:relative;\">판별 유니언 (Discriminated Unions)</h2> <p><code>data</code>와 가장 유사한 것은 보통 TypeScript에서 판별 유니언이라 불리는, 판별 프로퍼티를 갖는 타입의 유니언입니다:</p> <pre data-language=\"ts\">type Shape =\n  | { kind: \"circle\"; radius: number }\n  | { kind: \"square\"; x: number }\n  | { kind: \"triangle\"; x: number; y: number };</pre> <p>Haskell과 달리, 태그 또는 판별은 각각 객체 타입에서 단지 속성에 불구합니다. 특이 케이스는 다른 유닛 타입과 함께 동일한 속성을 가집니다. 아직 평범한 유니언타입입니다; 리드하는 <code>|</code> 는 유니언 타입 구문의 선택적인 부분입니다. 유니언을 사용하는 평범한 JavaScript 코드로 구별가능합니다:</p> <pre data-language=\"ts\">type Shape =\n  | { kind: \"circle\"; radius: number }\n  | { kind: \"square\"; x: number }\n  | { kind: \"triangle\"; x: number; y: number };\n\nfunction area(s: Shape) {\n  if (s.kind === \"circle\") {\n    return Math.PI * s.radius * s.radius;\n  } else if (s.kind === \"square\") {\n    return s.x * s.x;\n  } else {\n    return (s.x * s.y) / 2;\n  }\n}</pre> <p><code>area</code> 의 리턴 타입은 <code>number</code> 를 나타내는데, TypeScript가 함수가 전체라는 걸 알고 있기 때문에 유의해야할 필요가 있습니다. 몇몇 특이 케이스가 커버되지 않으면 <code>area</code> 의 리턴 타입은 <code>number | undefined</code> 으로 대신될 것입니다.</p> <p>또한, Haskell과 달리 흔한 속성들은 어떤 유니언에도 나타나며, 그래서 유용하게 여러 개의 유니언 구분가능합니다:</p> <pre data-language=\"ts\">type Shape =\n  | { kind: \"circle\"; radius: number }\n  | { kind: \"square\"; x: number }\n  | { kind: \"triangle\"; x: number; y: number };\n// ---cut---\nfunction height(s: Shape) {\n  if (s.kind === \"circle\") {\n    return 2 * s.radius;\n  } else {\n    // s.kind: \"square\" | \"triangle\"\n    return s.x;\n  }\n}</pre> <h2 id=\"타입-매개변수-type-parameters\" style=\"position:relative;\">타입 매개변수 (Type Parameters)</h2> <p>대부분의 C-계열 언어처럼, TypeScript는 타입 매개변수의 선언을 요구합니다:</p> <pre data-language=\"ts\">function liftArray&lt;T&gt;(t: T): Array&lt;T&gt; {\n  return [t];\n}</pre> <p>대소문자에 대한 요구 조건은 없지만, 타입 매개 변수는 일반적으로 단일 대문자입니다. 타입 매개 변수는 타입 클래스 제약과 비슷하게 동작하는 타입으로 제한될 수 있습니다.</p> <pre data-language=\"ts\">function firstish&lt;T extends { length: number }&gt;(t1: T, t2: T): T {\n  return t1.length &gt; t2.length ? t1 : t2;\n}</pre> <p>TypeScript는 일반적으로 인자 타입에 기반하여 호출로부터 타입 인자를 추론할 수 있기 때문에 대게 타입 인자를 필요로 하지 않습니다.</p> <p>왜냐하면 TypeScript는 구조적이기 때문에, 이름 기반의 시스템만큼 타입 매개 변수를 필요로 하지 않습니다. 특히 함수를 다형성으로 만들 필요는 없습니다. 타입 매개변수는 매개변수를 같은 타입으로 제한하는 것처럼 타입 정보를 <em>전파하는데만</em> 쓰여야 합니다:</p> <pre data-language=\"ts\">function length&lt;T extends ArrayLike&lt;unknown&gt;&gt;(t: T): number {}\n\nfunction length(t: ArrayLike&lt;unknown&gt;): number {}</pre> <p>첫 번째 <code>length</code>에서 T는 필요하지 않습니다; 오직 한 번만 참조되며, 다른 매개변수나 리턴 값의 타입을 제한하는데 사용되지 않는다는 것을 알아둬야 합니다.</p> <h3 id=\"상위-유형의-타입-higher-kinded-types\" style=\"position:relative;\">상위 유형의 타입 (Higher-kinded types)</h3> <p>TypeScript는 상위 유형의 타입이 없습니다. 그러므로 다음과 같이 하는 건 허용하지 않습니다:</p> <pre data-language=\"ts\">function length&lt;T extends ArrayLike&lt;unknown&gt;, U&gt;(m: T&lt;U&gt;) {}</pre> <h3 id=\"포인트-프리-프로그래밍-point-free-programming\" style=\"position:relative;\">포인트-프리 프로그래밍 (Point-free programming)</h3> <p>포인트-프리 프로그래밍은 — 커링 및 함수 합성의 과도한 사용 — JavaScript에서 가능하지만 장황할 수 있습니다. TypeScript에서 포인트-프리 프로그래밍에 대한 타입 추론이 실패하는 경우가 많으므로, 값 매개변수 대신 타입 매개변수를 지정하게 됩니다. 그 결과는 너무 장황해서 보통 포인트-프리 프로그래밍은 피하는 게 좋습니다.</p> <h2 id=\"모듈-시스템-module-system\" style=\"position:relative;\">모듈 시스템 (Module system)</h2> <p><code>import</code> 또는 <code>export</code>가 포함된 파일이 암시적으로 모듈이라는 점을 제외하면 JavaScript의 최신 모듈 구문은 Haskell과 약간 유사합니다:</p> <pre data-language=\"ts\">import { value, Type } from \"npm-package\";\nimport { other, Types } from \"./local-package\";\nimport * as prefix from \"../lib/third-package\";</pre> <p>commonjs 모듈로 가져올 수 있습니다 — node.js’ 모듈 시스템으로 사용된 모듈:</p> <pre data-language=\"ts\">import f = require(\"single-function-package\");</pre> <p>export 목록으로 내보낼 수 있습니다:</p> <pre data-language=\"ts\">export { f };\n\nfunction f() {\n  return g();\n}\nfunction g() {} // g is not exported</pre> <p>또는 개별적으로 표시해서:</p> <pre data-language=\"ts\">export function f { return g() }\nfunction g() { }</pre> <p>후자의 스타일이 더 일반적이지만 같은 파일 내에서도 둘 다 허용됩니다.</p> <h2 id=\"readonly-와-const-readonly-and-const\" style=\"position:relative;\">\n<code>readonly</code> 와 <code>const</code> (<code>readonly</code> and <code>const</code>)</h2> <p>JavaScript에서, 수정 가능함이 기본이지만, <em>참조</em>가 수정 불가능함을 선언하기 위해 <code>const</code>로 변수를 선언할 수 있습니다. 참조 대상은 여전히 수정 가능합니다:</p> <pre data-language=\"js\">const a = [1, 2, 3];\na.push(102); // ):\na[0] = 101; // D:</pre> <p>TypeScript는 추가적으로 프로퍼티에 <code>readonly</code> 제어자를 사용할 수 있습니다.</p> <pre data-language=\"ts\">interface Rx {\n  readonly x: number;\n}\nlet rx: Rx = { x: 1 };\nrx.x = 12; // error</pre> <p>매핑된 타입 <code>Readonly&lt;T&gt;</code> 은 모든 프로퍼티를 <code>readonly</code> 으로 만들어 버립니다:</p> <pre data-language=\"ts\">interface X {\n  x: number;\n}\nlet rx: Readonly&lt;X&gt; = { x: 1 };\nrx.x = 12; // error</pre> <p>그리고 부작용을 일으키는 메서드를 제거하고 배열 인덱스에 대한 변경을 방지하는 특정 <code>ReadonlyArray&lt;T&gt;</code> 타입과, 이 타입에 대한 특수 구문이 있습니다:</p> <pre data-language=\"ts\">let a: ReadonlyArray&lt;number&gt; = [1, 2, 3];\nlet b: readonly number[] = [1, 2, 3];\na.push(102); // error\nb[0] = 101; // error</pre> <p>배열과 객체 리터럴에서 동작하는 const-assertion만 사용할 수 있습니다:</p> <pre data-language=\"ts\">let a = [1, 2, 3] as const;\na.push(102); // error\na[0] = 101; // error</pre> <p>그러나 이러한 기능들은 기본적인 기능이 아니므로 TypeScript 코드에 일관적으로 사용하지 않아도 됩니다.</p> <h2 id=\"다음-단계-next-steps\" style=\"position:relative;\">다음 단계 (Next Steps)</h2> <p>이 문서는 일상적인 코드에서 높은 수준의 구문과 타입에 대한 개요를 담고 있습니다. 여기서부터는 아래를 참고하시면 됩니다:</p> <p><em>-</em> 전체 핸드북을 <a href=\"https://www.typescriptlang.org/docs/handbook/intro.html\">처음부터 끝까지</a> 읽으세요 (30m) <em>-</em> <a href=\"https://www.typescriptlang.org/play#show-examples\">Playground 예시</a>를 보세요.</p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2012-2023 Microsoft<br>Licensed under the Apache License, Version 2.0.<br>\n    <a href=\"https://www.typescriptlang.org/ko/docs/handbook/typescript-in-5-minutes-func.html\" class=\"_attribution-link\">https://www.typescriptlang.org/ko/docs/handbook/typescript-in-5-minutes-func.html</a>\n  </p>\n</div>\n","typescript-in-5-minutes":"<h1>TypeScript for JavaScript Programmers</h1>\n<p>현대 프로그래밍 언어에서 TypeScript와 JavaScript의 관계는 다소 독특합니다. TypeScript은 JavaScript 위에 레이어로서 자리잡고 있는데, JavaScript의 기능들을 제공하면서 그 위에 자체 레이어를 추가합니다. 이 레이어가 TypeScript 타입 시스템입니다.</p> <p>JavaScript는 이미 <code>string</code>, <code>number</code>, <code>object</code>, <code>undefined</code> 같은 원시 타입을 가지고 있지만, 전체 코드베이스에 일관되게 할당되었는지는 미리 확인해 주지 않습니다. TypeScript는 이 레이어로서 동작합니다.</p> <p>이는 이미 존재하고 잘 동작하는 JavaScript 코드는 동시에 TypeScript 코드라는 의미지만, TypeScript의 타입 검사기는 사용자가 생각한 일과 JavaScript가 실제로 하는 일 사이의 불일치를 강조할 수 있습니다.</p> <p>이 튜토리얼은 TypeScript가 추가하는 타입 시스템 언어 확장을 이해하는데 중점을 두고 타입 시스템에 대한 5분 개요를 제공합니다.</p> <h2 id=\"타입-추론-types-by-inference\" style=\"position:relative;\">타입 추론 (Types by Inference)</h2> <p>TypeScript는 JavaScript 언어를 알고 있으며 대부분의 경우 타입을 생성해줄 것입니다. 예를 들어 변수를 생성하면서 동시에 특정 값에 할당하는 경우, TypeScript는 그 값을 해당 변수의 타입으로 사용할 것입니다.</p> <pre data-language=\"ts\">let helloWorld = \"Hello World\";\n//  ^?</pre> <p>JavaScript가 동작하는 방식을 이해함으로써 TypeScript는 JavaScript 코드를 받아들이면서 타입을 가지는 타입 시스템을 구축할 수 있습니다. 이는 코드에서 타입을 명시하기 위해 추가로 문자를 사용할 필요가 없는 타입 시스템을 제공합니다. 이것이 위의 예제에서 TypeScript가 <code>helloWorld</code>가 <code>string</code>임을 알게 되는 방식입니다.</p> <p>JavaScript와 함께 VS Code를 사용하고 작업을 할 때 편집기의 자동 완성 기능을 사용해왔을 것입니다. 이는 TypeScript에 필수불가결한 JavaScript에 대한 이해가 JavaScript 작업을 개선하기 위해 내부적으로 사용되었기 때문입니다.</p> <h2 id=\"타입-정의하기-defining-types\" style=\"position:relative;\">타입 정의하기 (Defining Types)</h2> <p>JavaScript는 다양한 디자인 패턴을 가능하게 하는 동적 언어입니다. 몇몇 디자인 패턴은 자동으로 타입을 제공하기 힘들 수 있는데 (동적 프로그래밍을 사용하고 있을 것이기 때문에) 이러한 경우에 TypeScript는 TypeScript에게 타입이 무엇이 되어야 하는지 명시 가능한 JavaScript 언어의 확장을 지원합니다.</p> <p>다음은 <code>name: string</code>과 <code>id: number</code>을 포함하는 추론 타입을 가진 객체를 생성하는 예제입니다.</p> <pre data-language=\"ts\">const user = {\n  name: \"Hayes\",\n  id: 0,\n};</pre> <p>이 객체의 형태를 명시적으로 나타내기 위해서는 <code>interface</code> 로 선언합니다.</p> <pre data-language=\"ts\">interface User {\n  name: string;\n  id: number;\n}</pre> <p>이제 변수 선언 뒤에 <code>: TypeName</code>의 구문을 사용해 JavaScript 객체가 새로운 <code>interface</code>의 형태를 따르고 있음을 선언할 수 있습니다.</p> <pre data-language=\"ts\">interface User {\n  name: string;\n  id: number;\n}\n// ---cut---\nconst user: User = {\n  name: \"Hayes\",\n  id: 0,\n};</pre> <p>해당 인터페이스에 맞지 않는 객체를 생성하면 TypeScript는 경고를 줍니다.</p> <pre data-language=\"ts\">// @errors: 2322\ninterface User {\n  name: string;\n  id: number;\n}\n\nconst user: User = {\n  username: \"Hayes\",\n  id: 0,\n};</pre> <p>JavaScript는 클래스와 객체 지향 프로그래밍을 지원하기 때문에, TypeScript 또한 동일합니다. - 인터페이스는 클래스로도 선언할 수 있습니다.</p> <pre data-language=\"ts\">interface User {\n  name: string;\n  id: number;\n}\n\nclass UserAccount {\n  name: string;\n  id: number;\n\n  constructor(name: string, id: number) {\n    this.name = name;\n    this.id = id;\n  }\n}\n\nconst user: User = new UserAccount(\"Murphy\", 1);</pre> <p>인터페이스는 함수에서 매개변수와 리턴 값을 명시하는데 사용되기도 합니다.</p> <pre data-language=\"ts\">// @noErrors\ninterface User {\n  name: string;\n  id: number;\n}\n// ---cut---\nfunction getAdminUser(): User {\n  //...\n}\n\nfunction deleteUser(user: User) {\n  // ...\n}</pre> <p>JavaScript에서 사용할 수 있는 적은 종류의 원시 타입이 이미 있습니다.: <code>boolean</code>, <code>bigint</code>, <code>null</code>, <code>number</code>, <code>string</code>, <code>symbol</code>, <code>object</code>와 <code>undefined</code>는 인터페이스에서 사용할 수 있습니다. TypeScript는 몇 가지를 추가해 목록을 확장합니다. 예를 들어, <code>any</code> (무엇이든 허용합니다), <a href=\"https://www.typescriptlang.org/en/play#example/unknown-and-never\"><code>unknown</code></a> (이 타입을 사용하는 사람이 타입이 무엇인지 선언했는가를 확인하십시오), <a href=\"https://www.typescriptlang.org/en/play#example/unknown-and-never\"><code>never</code></a> (이 타입은 발생될 수 없습니다) <code>void</code> (<code>undefined</code>를 리턴하거나 리턴 값이 없는 함수).</p> <p>타입을 구축하기 위한 두 가지 구문이 있다는 것을 꽤 빠르게 알 수 있을 것입니다.: <a href=\"https://www.typescriptlang.org/play/?e=83#example/types-vs-interfaces\">Interfaces and Types</a> - <code>interface</code>를 우선적으로 사용하고 특정 기능이 필요할 때 <code>type</code>을 사용해야 합니다.</p> <h2 id=\"타입-구성-composing-types\" style=\"position:relative;\">타입 구성 (Composing Types)</h2> <p>객체들을 조합하여 더 크고 복잡한 객체를 만드는 방법과 유사하게 TypeScript에 타입으로 이를 수행하는 도구가 있습니다. 여러가지 타입을 이용하여 새 타입을 작성하기 위해 일상적인 코드에서 가장 많이 사용되는 두 가지 코드로는 유니언(Union)과 제네릭(Generic)이 있습니다.</p> <h3 id=\"유니언-unions\" style=\"position:relative;\">유니언 (Unions)</h3> <p>유니언은 타입이 여러 타입 중 하나일 수 있음을 선언하는 방법입니다. 예를 들어, <code>boolean</code> 타입을 <code>true</code> 또는 <code>false</code>로 설명할 수 있습니다:</p> <pre data-language=\"typescript\">type MyBool = true | false;</pre> <p><em>참고:</em> <code>MyBool</code>위에 마우스를 올린다면, <code>boolean</code>으로 분류된 것을 볼 수 있습니다 - 구조적 타입 시스템의 프로퍼티며, 나중에 살펴보겠습니다.</p> <p>유니언 타입이 가장 많이 사용된 사례 중 하나는 값이 다음과 같이 허용되는 <code>string</code> 또는 <code>number</code>의 <a href=\"https://www.typescriptlang.org/docs/handbook/literal-types.html\">리터럴</a>집합을 설명하는 것입니다:</p> <pre data-language=\"typescript\">type WindowStates = \"open\" | \"closed\" | \"minimized\";\ntype LockStates = \"locked\" | \"unlocked\";\ntype OddNumbersUnderTen = 1 | 3 | 5 | 7 | 9;</pre> <p>유니언은 다양한 타입을 처리하는 방법을 제공하는데, 예를 들어 <code>array</code> 또는 <code>string</code>을 받는 함수가 있을 수 있습니다.</p> <pre data-language=\"typescript\">function getLength(obj: string | string[]) {\n  return obj.length;\n}</pre> <p>TypeScript는 코드가 시간에 따라 변수가 변경되는 방식을 이해하며, 이러한 검사를 사용해 타입을 골라낼 수 있습니다.</p> <table> <thead> <tr> <th>Type</th> <th>Predicate</th> </tr> </thead> <tbody> <tr> <td>string</td> <td><code>typeof s === \"string\"</code></td> </tr> <tr> <td>number</td> <td><code>typeof n === \"number\"</code></td> </tr> <tr> <td>boolean</td> <td><code>typeof b === \"boolean\"</code></td> </tr> <tr> <td>undefined</td> <td><code>typeof undefined === \"undefined\"</code></td> </tr> <tr> <td>function</td> <td><code>typeof f === \"function\"</code></td> </tr> <tr> <td>array</td> <td><code>Array.isArray(a)</code></td> </tr> </tbody> </table> <p>예를 들어, <code>typeof obj === \"string\"</code>을 이용하여 <code>string</code>과 <code>array</code>를 구분할 수 있으며 TypeScript는 객체가 다른 코드 경로에 있음을 알게 됩니다.</p>  <pre data-language=\"typescript\">function wrapInArray(obj: string | string[]) {\n  if (typeof obj === \"string\") {\n    return [obj];\n//          ^?\n  } else {\n    return obj;\n  }\n}</pre> <h3 id=\"제네릭-generics\" style=\"position:relative;\">제네릭 (Generics)</h3> <p>TypeScript 제네릭 시스템에 대해 자세히 알아볼 수 있지만, 1분 정도의 수준 높은 설명을 하기 위해, 제네릭은 타입에 변수를 제공하는 방법입니다.</p> <p>배열이 일반적인 예시이며, 제네릭이 없는 배열은 어떤 것이든 포함할 수 있습니다. 제네릭이 있는 배열은 배열 안의 값을 설명할 수 있습니다.</p> <pre data-language=\"ts\">type StringArray = Array&lt;string&gt;;\ntype NumberArray = Array&lt;number&gt;;\ntype ObjectWithNameArray = Array&lt;{ name: string }&gt;;</pre> <p>제네릭을 사용하는 고유 타입을 선언할 수 있습니다:</p> <pre data-language=\"typescript\">// @errors: 2345\ninterface Backpack&lt;Type&gt; {\n  add: (obj: Type) =&gt; void;\n  get: () =&gt; Type;\n}\n\n// 이 줄은 TypeScript에 `backpack`이라는 상수가 있음을 알리는 지름길이며\n// const backpack: Backpack&lt;string&gt;이 어디서 왔는지 걱정할 필요가 없습니다.\ndeclare const backpack: Backpack&lt;string&gt;;\n\n// 위에서 Backpack의 변수 부분으로 선언해서, object는 string입니다.\nconst object = backpack.get();\n\n// backpack 변수가 string이므로, add 함수에 number를 전달할 수 없습니다.\nbackpack.add(23);</pre> <h2 id=\"구조적-타입-시스템-structural-type-system\" style=\"position:relative;\">구조적 타입 시스템 (Structural Type System)</h2> <p>TypeScript의 핵심 원칙 중 하나는 타입 검사가 값이 있는 <em>형태</em>에 집중한다는 것입니다. 이는 때때로 “덕 타이핑(duck typing)” 또는 “구조적 타이핑” 이라고 불립니다.</p> <p>구조적 타입 시스템에서 두 객체가 같은 형태를 가지면 같은 것으로 간주됩니다.</p> <pre data-language=\"typescript\">interface Point {\n  x: number;\n  y: number;\n}\n\nfunction printPoint(p: Point) {\n  console.log(`${p.x}, ${p.y}`);\n}\n\n// \"12, 26\"를 출력합니다\nconst point = { x: 12, y: 26 };\nprintPoint(point);</pre> <p><code>point</code>변수는 <code>Point</code>타입으로 선언된 적이 없지만, TypeScript는 타입 검사에서 <code>point</code>의 형태와 <code>Point</code>의 형태를 비교합니다. 둘 다 같은 형태이기 때문에, 통과합니다.</p> <p>형태 일치에는 일치시킬 객체의 필드의 하위 집합만 필요합니다.</p> <pre data-language=\"typescript\">// @errors: 2345\ninterface Point {\n  x: number;\n  y: number;\n}\n\nfunction printPoint(p: Point) {\n  console.log(`${p.x}, ${p.y}`);\n}\n// ---cut---\nconst point3 = { x: 12, y: 26, z: 89 };\nprintPoint(point3); // prints \"12, 26\"\n\nconst rect = { x: 33, y: 3, width: 30, height: 80 };\nprintPoint(rect); // prints \"33, 3\"\n\nconst color = { hex: \"#187ABF\" };\n\nprintPoint(color);</pre> <p>마지막으로, 정확하게 마무리 짓기 위해, 구조적으로 클래스와 객체가 형태를 따르는 방법에는 차이가 없습니다:</p> <pre data-language=\"typescript\">// @errors: 2345\ninterface Point {\n  x: number;\n  y: number;\n}\n\nfunction printPoint(p: Point) {\n  console.log(`${p.x}, ${p.y}`);\n}\n// ---cut---\nclass VirtualPoint {\n  x: number;\n  y: number;\n\n  constructor(x: number, y: number) {\n    this.x = x;\n    this.y = y;\n  }\n}\n\nconst newVPoint = new VirtualPoint(13, 56);\nprintPoint(newVPoint); // prints \"13, 56\"</pre> <p>객체 또는 클래스에 필요한 모든 속성이 존재한다면, TypeScript는 구현 세부 정보에 관계없이 일치하게 봅니다.</p> <h2 id=\"다음-단계-next-steps\" style=\"position:relative;\">다음 단계 (Next Steps)</h2> <p>해당 문서는 일상적인 코드에서 사용하는 구문 및 도구의 종류에 대한 수준 높은 5분 개요입니다. 여기에서:</p> <ul> <li>전체 핸드북을 <a href=\"https://www.typescriptlang.org/docs/handbook/intro.html\">처음부터 끝까지</a> 읽으세요(30분)</li> <li>\n<a href=\"https://www.typescriptlang.org/play#show-examples\">Playground 예시</a>를 탐색하세요.</li> </ul><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2012-2023 Microsoft<br>Licensed under the Apache License, Version 2.0.<br>\n    <a href=\"https://www.typescriptlang.org/ko/docs/handbook/typescript-in-5-minutes.html\" class=\"_attribution-link\">https://www.typescriptlang.org/ko/docs/handbook/typescript-in-5-minutes.html</a>\n  </p>\n</div>\n","typescript-in-5-minutes-oop":"<h1>TypeScript for Java/C# Programmers</h1>\n<p>TypeScript는 C#, Java와 같이 정적 타이핑을 사용하는 언어에 익숙한 프로그래머들에게 인기 있는 선택입니다.</p> <p>TypeScript의 타입 시스템은 더 나은 코드 완성, 오류의 조기 발견, 프로그램 부분 간의 더 명확한 통신과 같이 정적 타이핑이 가지는 많은 이점을 제공합니다. TypeScript는 이러한 개발자에게 친숙한 기능을 많이 제공하지만, JavaScript(또한 TypeScript도 마찬가지로)가 기존의 객체 지향 프로그래밍(OOP) 언어와 어떤 차이가 있는지 다시 살펴볼 필요가 있습니다. 이러한 차이점을 이해하는 것은 더 나은 JavaScript 코드를 작성하는데 도움을 줄 것이고, C#/Java에서 TypeScript로 바로 입문한 프로그래머가 겪는 흔한 함정을 피할 수 있을 것입니다.</p> <h2 id=\"javascript-함께-배우기-co-learning-javascript\" style=\"position:relative;\">JavaScript 함께 배우기 (Co-learning JavaScript)</h2> <p>만약 JavaScript에 이미 익숙하지만 주로 Java또는 C#을 사용하는 프로그래머라면, 이 소개 페이지는 흔히 접할 수 있는 오해와 함정에 대한 설명에 도움을 줄 수 있습니다. TypeScript 모델이 유형화하는 방법 중 일부는 Java나 C#과 상당히 다르며, TypeScript를 학습하는 데에 있어 이 부분을 염두에 두는 것이 중요합니다.</p> <p>만약 JavaScript를 처음 접하는 Java나 C# 프로그래머라면, JavaScript의 런타임 동작을 이해하기 위해 우선적으로 타입을 <em>제외한</em> JavaScript의 일부분을 배우는 것이 좋습니다. TypeScript는 코드를 <em>실행하는</em> 방식을 바꾸지 않기 때문에, 실제로 무언가 동작하는 코드를 작성하기 위해서는 여전히 JavaScript가 어떻게 작동하는지 배워야 합니다!</p> <p>TypeScript가 JavaScript와 동일한 <em>런타임</em>을 사용하므로, 특정한 런타임 동작(문자열을 숫자로 변환하기, 경고 표시, 디스크에 파일 쓰기 등)을 구현하려는 리소스는 항상 TypeScript 프로그램에 똑같이 잘 적용된다는 점을 기억하는 것은 매우 중요합니다. TypeScript에 특정된 리소스에만 제한을 두지 마십시오!</p> <h2 id=\"클래스-다시-생각하기-rethinking-the-class\" style=\"position:relative;\">클래스 다시 생각하기 (Rethinking the Class)</h2> <p>C#과 Java는 <em>의무적 OOP</em> 언어라고 부릅니다. 이러한 언어에서 <em>클래스</em>는 코드 구성의 기본 단위일 뿐만 아니라 런타임 시 모든 데이터 <em>그리고</em> 동작의 기본적인 컨테이너입니다. 기능과 데이터를 전부 클래스에 담도록 강제하는 것은 일부 문제에 대해선 좋은 도메인 모델이 될 수 있지만, 모든 도메인이 이러한 방식으로 표현될 <em>필요</em>는 없습니다.</p> <h3 id=\"자유로운-함수와-데이터-free-functions-and-data\" style=\"position:relative;\">자유로운 함수와 데이터 (Free Functions and Data)</h3> <p>JavaScript에서 함수는 어디에나 있을 수 있고, 데이터를 미리 정의된 ‘class’나 ‘struct’에 속하지 않고 자유롭게 전달할 수 있습니다. 이러한 유연성은 매우 강력합니다. OOP 계층과 상관 없이 데이터를 처리하는 “자유로운” (클래스와 연관되지 않은) 함수는 프로그램을 JavaScript로 작성하는 모델로 선호됩니다.</p> <h3 id=\"정적-클래스-static-classes\" style=\"position:relative;\">정적 클래스 (Static Classes)</h3> <p>추가적으로, C#과 Java의 싱글턴과 정적 클래스 같은 특정 구조는 TypeScript에서 필요하지 않습니다.</p> <h2 id=\"typescript의-oop-oop-in-typescript\" style=\"position:relative;\">TypeScript의 OOP (OOP in TypeScript)</h2> <p>즉, 원한다면 계속 클래스를 사용해도 됩니다! 일부 문제는 기존의 OOP 계층으로 해결하기 적합하며, TypeScript가 JavaScript의 클래스를 지원하므로 이러한 모델을 더 효과적으로 만듭니다. TypeScript는 인터페이스, 상속, 정적 메서드 구현과 같은 많은 일반적인 패턴을 지원합니다.</p> <p>우리는 이 가이드의 뒷부분에서 클래스를 다룰 것입니다.</p> <h2 id=\"타입-다시-생각하기-rethinking-types\" style=\"position:relative;\">타입 다시 생각하기 (Rethinking Types)</h2> <p>TypeScript의 <em>타입</em>에 대한 이해는 사실 C#이나 Java와 상당히 다릅니다. 몇 가지 차이점을 살펴봅시다.</p> <h3 id=\"이름으로-구체화된-타입-시스템-nominal-reified-type-systems\" style=\"position:relative;\">이름으로 구체화된 타입 시스템 (Nominal Reified Type Systems)</h3> <p>C#과 Java에서 주어진 값과 객체는 ‘null’, 원시 타입, 또는 정의된 클래스 타입 중 정확하게 하나의 타입을 가집니다. 런타임 시점에서 정확한 타입을 묻기 위해 <code>value.GetType()</code> 또는 <code>value.getClass()</code>와 같은 메서드를 호출할 수 있습니다. 이러한 타입의 정의는 특정한 이름을 갖고 클래스의 어딘가 존재하며, 명시적인 상속관계나 공통적으로 구현된 인터페이스가 없는 이상 두 클래스가 유사한 형태를 가졌다 해도 서로 대체하여 사용할 수 없습니다.</p> <p>이러한 양상은 <em>reified, nominal</em> 타입 시스템을 설명합니다. 코드에서 사용한 타입은 런타임 시점에 존재하며, 타입은 구조가 아닌 선언을 통해 연관 지어집니다.</p> <h3 id=\"집합으로서의-타입-types-as-sets\" style=\"position:relative;\">집합으로서의 타입 (Types as Sets)</h3> <p>C# 또는 Java에서 런타임 타입과 해당 컴파일 타임 선언 사이의 일대일 대응관계는 중요합니다.</p> <p>TypeScript에서 타입은 공통의 무언가를 공유하는 <em>값의 집합</em>으로 생각하는 것이 좋습니다. 타입은 집합에 불과하기 때문에, 특정한 값은 동시에 <em>수많은</em> 집합에 속할 수 있습니다.</p> <p>일단 타입을 집합으로 생각하기 시작하면, 특정 연산이 매우 자연스러워집니다. 예를 들어, C#에서는 ‘string’과 ‘int’ <em>둘 다 가능한</em> 타입이 존재하지 않기 때문에 이 값을 인자로 전달하는 것은 이상합니다.</p> <p>TypeScript에서 모든 타입이 단순히 집합이라는 것을 깨닫는 순간 이는 매우 자연스러워집니다. ‘string’ 집합 또는 ‘number’ 집합에 속할 수 있는 값을 어떻게 설명하시겠습니까? 이 값은 단순히 그 집합들의 <em>유니언</em>: ‘string | number’에 속합니다.</p> <p>TypeScript는 집합론에 의거해 타입을 이용하는 여러 방법을 제공하며, 타입을 집합으로 생각하는 것이 더 직관적입니다.</p> <h3 id=\"삭제된-구조적-타입-erased-structural-types\" style=\"position:relative;\">삭제된 구조적 타입 (Erased Structural Types)</h3> <p>TypeScript에서, 객체는 정확히 단일 타입이 <em>아닙니다</em>. 예를 들어 인터페이스를 만족하는 객체를 생성할 때, 둘 사이의 선언적인 관계가 없더라도 해당 인터페이스가 예상되는 곳에 해당 객체를 사용할 수 있습니다.</p> <pre data-language=\"typescript\">interface Pointlike {\n  x: number;\n  y: number;\n}\ninterface Named {\n  name: string;\n}\n\nfunction printPoint(point: Pointlike) {\n  console.log(\"x = \" + point.x + \", y = \" + point.y);\n}\n\nfunction printName(x: Named) {\n  console.log(\"Hello, \" + x.name);\n}\n\nconst obj = {\n  x: 0,\n  y: 0,\n  name: \"Origin\",\n};\n\nprintPoint(obj);\nprintName(obj);</pre> <p>TypeScript의 타입 시스템은 명목이 아닌 <em>구조적</em>입니다: <code>obj</code>는 숫자인 <code>x</code>와 <code>y</code> 프로퍼티를 가지고 있으므로, <code>Pointlike</code>로써 사용될 수 있습니다. 타입 간의 관계는 특정 관계로 선언되었는지가 아닌, 포함된 프로퍼티에 의해 결정됩니다.</p> <p>TypeScript의 타입 시스템은 또한 <em>구체화되지 않았습니다</em>: 런타임에 <code>obj</code>가 <code>Pointlike</code>임을 알려주지 않습니다. 사실, <code>Pointlike</code> 타입은 런타임에 <em>어떤 형태로도</em> 존재하지 않습니다.</p> <p><em>집합으로서의 타입</em> 개념으로 보면, <code>obj</code>를 <code>Pointlike</code> 값 집합이나 <code>Named</code> 값 집합의 멤버로 간주할 수 있습니다.</p> <h3 id=\"구조적-타입화의-결과-consequences-of-structural-typing\" style=\"position:relative;\">구조적 타입화의 결과 (Consequences of Structural Typing)</h3> <p>객체지향 프로그래머는 종종 구조적 타입화의 두 가지 측면에 놀라곤 합니다.</p> <h4 id=\"빈-타입-empty-types\" style=\"position:relative;\">빈 타입 (Empty Types)</h4> <p>첫 번째로 <em>빈 타입</em>은 예상을 무시하는 것처럼 보입니다:</p> <pre data-language=\"typescript\">class Empty {}\n\nfunction fn(arg: Empty) {\n  // 무엇인가를 하나요?\n}\n\n// 오류는 없지만, '빈' 타입은 아니지 않나요?\nfn({ k: 10 });</pre> <p>TypeScript는 주어진 인수가 유효한 <code>Empty</code>인지 확인하여 <code>fn</code>의 호출이 유효한지를 검사합니다 <code>{ k: 10 }</code>과 <code>class Empty { }</code>의 _구조를 확인하여 유효성을 검사합니다. <code>Empty</code>에 프로퍼티가 없으므로 <code>Empty</code>가 수행하는 <em>모든</em> 프로퍼티가 <code>{ k: 10 }</code>에 속해있습니다. 그러므로, 유효한 호출입니다:</p> <p>놀랍지만, 최종적으로 명목적인 객체지향프로그래밍 언어와 매우 비슷하게 사용됩니다. 파생 클래스와 파생 클래스의 기본 사이의 자연스러운 하위 타입 관계가 파괴되기 때문에, 하위 클래스는 <em>삭제</em>할 수 없습니다. 구조적 타입 시스템은 호환 가능한 유형의 속성을 갖는 측면에서 하위 타입을 설명하므로 위의 관계를 암시적으로 구별합니다</p> <h4 id=\"동일한-타입-identical-types\" style=\"position:relative;\">동일한 타입 (Identical Types)</h4> <p>또 다른 빈번한 놀라움의 원인은 동일한 타입에 기인합니다:</p> <pre data-language=\"ts\">class Car {\n  drive() {\n    // hit the gas\n  }\n}\nclass Golfer {\n  drive() {\n    // hit the ball far\n  }\n}\n\n// No error?\nlet w: Car = new Golfer();</pre> <p>다시 말하지만, 오류가 아닌 이유는 클래스의 <em>구조</em>가 동일하기 때문입니다. 잠재적인 혼란의 이유가 될 수도 있겠지만, 사실 상관없는 클래스가 동일한 경우는 일반적이지 않습니다.</p> <p>차후에 클래스 챕터에서 클래스가 서로 어떻게 관련되는지에 대해 자세히 알아볼 것입니다.</p> <h3 id=\"반영-reflection\" style=\"position:relative;\">반영 (Reflection)</h3> <p>객체지향 프로그래머는 제네릭을 포함하여 어떤 값의 유형이라도 다룰(query)수 있음에 익숙합니다.</p> <pre data-language=\"csharp\">// C#\nstatic void PrintType&lt;T&gt;() {\n    Console.WriteLine(typeof(T).Name);\n}</pre> <p>TypeScript의 타입 시스템이 완벽히 지워졌으므로, 제네릭 타입 인자의 인스턴스화와 같은 정보는 런타임에 사용할 수 없습니다.</p> <p>JavaScript에는 <code>typeof</code>와 <code>instanceof</code>와 같은 제한된 원시요소가 있지만, 이런 연산자는 타입이 지워진 코드의 출력에 존재하므로 여전히 작동함을 알아야 합니다. 예를 들어, <code>typeof (new Car())</code>는 <code>Car</code>나 <code>\"Car\"</code>가 아닌 <code>\"object\"</code>입니다.</p> <hr> <p>지금까지 개요였고, 여기에서 <a href=\"https://www.typescriptlang.org/docs/handbook/intro.html\">핸드북</a>을 읽거나 또는 <a href=\"https://www.typescriptlang.org/play#show-examples\">Playground 예제</a>를 탐색하세요.</p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2012-2023 Microsoft<br>Licensed under the Apache License, Version 2.0.<br>\n    <a href=\"https://www.typescriptlang.org/ko/docs/handbook/typescript-in-5-minutes-oop.html\" class=\"_attribution-link\">https://www.typescriptlang.org/ko/docs/handbook/typescript-in-5-minutes-oop.html</a>\n  </p>\n</div>\n","declaration-merging":"<h1>Declaration Merging</h1>\n<h2 id=\"소개-introduction\" style=\"position:relative;\">소개 (Introduction)</h2> <p>TypeScript의 독특한 개념 중 일부는 타입 레벨에서 JavaScript 객체의 형태를 설명합니다. TypeScript만의 특별한 예로 ‘선언 병합’의 개념이 있습니다. 이 개념을 이해하면 기존의 JavaScript 작업을 할 때 이점이 많아질 것입니다. 또한 고급 추상화 개념으로의 문을 열어줄 것입니다.</p> <p>본론으로 돌아가서, “선언 병합”은 컴파일러가 같은 이름으로 선언된 개별적인 선언 두 개를 하나의 정의로 합치는 것을 의미합니다. 이 병합된 정의는 원래 두 선언의 특성을 모두 갖습니다. 병합할 선언이 몇 개든 병합할 수 있습니다; 두 개의 선언만 합치도록 제한하지 않습니다.</p> <h2 id=\"기본-사용법-basic-concepts\" style=\"position:relative;\">기본 사용법 (Basic Concepts)</h2> <p>TypeScript에서, 선언은 네임스페이스, 타입 또는 값 3개의 그룹 중 적어도 하나의 엔티티를 생성합니다. 네임스페이스-생성 선언은 점 표기법을 사용하여 접근할 이름을 가진 네임 스페이스를 생성합니다. 타입-생성 선언은 주어진 이름에 바인딩 되고 선언된 형태로 표시된 타입을 생성합니다. 마지막으로, 값-생성 선언은 JavaScript에서 확인할 수 있는 출력값을 생성합니다.</p> <table> <thead> <tr> <th>선언 타입</th> <th align=\"center\">네임 스페이스</th> <th align=\"center\">타입</th> <th align=\"center\">값</th> </tr> </thead> <tbody> <tr> <td>네임 스페이스</td> <td align=\"center\">X</td> <td align=\"center\"></td> <td align=\"center\">X</td> </tr> <tr> <td>클래스</td> <td align=\"center\"></td> <td align=\"center\">X</td> <td align=\"center\">X</td> </tr> <tr> <td>열거형</td> <td align=\"center\"></td> <td align=\"center\">X</td> <td align=\"center\">X</td> </tr> <tr> <td>인터페이스</td> <td align=\"center\"></td> <td align=\"center\">X</td> <td align=\"center\"></td> </tr> <tr> <td>타입 별칭</td> <td align=\"center\"></td> <td align=\"center\">X</td> <td align=\"center\"></td> </tr> <tr> <td>함수</td> <td align=\"center\"></td> <td align=\"center\"></td> <td align=\"center\">X</td> </tr> <tr> <td>변수</td> <td align=\"center\"></td> <td align=\"center\"></td> <td align=\"center\">X</td> </tr> </tbody> </table> <p>각 선언으로 생성된 결과를 이해하는 것은 선언 병합을 할 때 병합된 결과물을 이해하는 데 도움이 됩니다.</p> <h2 id=\"인터페이스-병합-merging-interfaces\" style=\"position:relative;\">인터페이스 병합 (Merging Interfaces)</h2> <p>가장 단순하고 일반적인 선언 병합의 타입은 인터페이스 병합입니다. 가장 기본적인 수준에서, 병합은 두 선언의 멤버를 같은 이름의 단일 인터페이스로 기계적으로 결합합니다.</p> <pre data-language=\"ts\">interface Box {\n  height: number;\n  width: number;\n}\n\ninterface Box {\n  scale: number;\n}\n\nlet box: Box = { height: 5, width: 6, scale: 10 };</pre> <p>인터페이스의 비-함수 멤버는 고유해야 합니다. 만약 고유하지 않으면, 모두 같은 타입이어야 합니다. 인터페이스가 동일한 이름의 비-함수 멤버를 선언하지만 다른 타입으로 선언하는 경우 컴파일러는 error를 발생시킵니다.</p> <p>함수 멤버의 경우, 이름이 같은 각 함수 멤버는 같은 함수의 오버로드 하는 것으로 처리합니다. 또한 중요한 것은 인터페이스 A와 이후 인터페이스 A를 병합하는 경우에, 두 번째 인터페이스가 첫 번째 인터페이스보다 더 높은 우선순위를 갖게 됩니다.</p> <p>예를 들어:</p> <pre data-language=\"ts\">interface Cloner {\n  clone(animal: Animal): Animal;\n}\n\ninterface Cloner {\n  clone(animal: Sheep): Sheep;\n}\n\ninterface Cloner {\n  clone(animal: Dog): Dog;\n  clone(animal: Cat): Cat;\n}</pre> <p>위의 세 인터페이스를 아래와 같은 단일 선언으로 병합할 수 있습니다:</p> <pre data-language=\"ts\">interface Cloner {\n  clone(animal: Dog): Dog;\n  clone(animal: Cat): Cat;\n  clone(animal: Sheep): Sheep;\n  clone(animal: Animal): Animal;\n}</pre> <p>각 그룹의 요소는 동일한 순서를 유지하지만, 그룹 자체는 나중에 오버로드 될수록 첫 번째에 위치하는 것에 유의하세요.</p> <p>이 규칙엔 특수 시그니처(specialized signatures)라는 예외가 존재합니다. 만약 <em>단일</em> 문자열 리터럴 타입(예. 문자열 리터럴이 유니온이 아닌 경우)인 매개변수가 있을 경우, 시그니처는 병합된 오버로드 목록의 맨 위로 올라오게 됩니다.</p> <p>예를 들어, 아래의 인터페이스들이 병합됩니다:</p> <pre data-language=\"ts\">interface Document {\n  createElement(tagName: any): Element;\n}\ninterface Document {\n  createElement(tagName: \"div\"): HTMLDivElement;\n  createElement(tagName: \"span\"): HTMLSpanElement;\n}\ninterface Document {\n  createElement(tagName: string): HTMLElement;\n  createElement(tagName: \"canvas\"): HTMLCanvasElement;\n}</pre> <p><code>Document</code>의 병합된 선언 결과는 다음과 같습니다:</p> <pre data-language=\"ts\">interface Document {\n  createElement(tagName: \"canvas\"): HTMLCanvasElement;\n  createElement(tagName: \"div\"): HTMLDivElement;\n  createElement(tagName: \"span\"): HTMLSpanElement;\n  createElement(tagName: string): HTMLElement;\n  createElement(tagName: any): Element;\n}</pre> <h2 id=\"네임스페이스-병합-merging-namespaces\" style=\"position:relative;\">네임스페이스 병합 (Merging Namespaces)</h2> <p>인터페이스와 마찬가지로 같은 이름의 네임스페이스는 네임스페이스 멤버와 병합합니다. 네임스페이스가 네임스페이스와 값 둘 다 만들기 때문에, 두 가지가 병합되는 방법을 이해해야 합니다.</p> <p>네임스페이스를 병합하기 위해서, 각 네임스페이스에 선언된 export 된 인터페이스로부터 타입 정의가 병합되며, 내부에 병합된 인터페이스 정의가 있는 단일 네임스페이스가 형성됩니다.</p> <p>네임스페이스 값을 병합하려면, 각 선언 위치에 이미 지정된 이름의 네임스페이스가 있을 경우에, 기존 네임스페이스에 두 번째 네임스페이스의 export 된 멤버를 첫 번째에 추가하여 네임스페이스 값이 확장됩니다.</p> <p>이러한 예제인 <code>Animals</code> 의 선언 병합:</p> <pre data-language=\"ts\">namespace Animals {\n  export class Zebra {}\n}\n\nnamespace Animals {\n  export interface Legged {\n    numberOfLegs: number;\n  }\n  export class Dog {}\n}</pre> <p>다음과 같습니다:</p> <pre data-language=\"ts\">namespace Animals {\n  export interface Legged {\n    numberOfLegs: number;\n  }\n\n  export class Zebra {}\n  export class Dog {}\n}</pre> <p>이러한 네임스페이스 병합의 모델은 좋은 출발점이지만, 우리는 export 되지 않은 멤버에게 어떤 일이 발생하는지 이해해야 합니다. export 되지 않은 멤버는 원래 네임스페이스(병합되지 않은 네임스페이스)에서만 볼 수 있습니다. 이는 병합 후에 다른 선언으로 병합된 멤버는 export 되지 않은 멤버를 볼 수 없다는 것을 의미합니다.</p> <p>아래의 예제에서 더 명확하게 확인할 수 있습니다:</p> <pre data-language=\"ts\">namespace Animal {\n  let haveMuscles = true;\n\n  export function animalsHaveMuscles() {\n    return haveMuscles;\n  }\n}\n\nnamespace Animal {\n  export function doAnimalsHaveMuscles() {\n    return haveMuscles; // 오류, haveMuscles가 여기에 접근할 수 없기 때문에\n  }\n}</pre> <p><code>haveMuscles</code> 가 export 되지 않아서, 동일하게 병합되지 않은 네임스페이스를 공유하는 <code>animalsHaveMuscles</code> 함수만 이 심벌을 볼 수 있습니다. <code>doAnimalsHaveMuscles</code> 함수가, 병합된 <code>Animal</code> 네임스페이스의 멤버일지라도, export 되지 않은 멤버는 볼 수 없습니다.</p> <h2 id=\"클래스-함수-열거형과-네임-스페이스-병합-merging-namespaces-with-classes-functions-and-enums\" style=\"position:relative;\">클래스, 함수, 열거형과 네임 스페이스 병합 (Merging Namespaces with Classes, Functions, and Enums)</h2> <p>네임 스페이스는 다른 타입의 선언과 병합할 수 있을 정도로 유연합니다. 이를 위해서, 네임 스페이스 선언은 병합할 선언을 따라야 합니다. 결과 선언은 두 선언 타입의 프로퍼티를 모두 갖습니다. TypeScript는 이를 통해 JavaScript와 다른 프로그래밍 언어에서의 패턴을 모델링 합니다.</p> <h2 id=\"네임-스페이스와-클래스-병합-merging-namespaces-with-classes\" style=\"position:relative;\">네임 스페이스와 클래스 병합 (Merging Namespaces with Classes)</h2> <p>이 부분은 내부 클래스를 설명하는 방법을 말합니다.</p> <pre data-language=\"ts\">class Album {\n  label: Album.AlbumLabel;\n}\nnamespace Album {\n  export class AlbumLabel {}\n}</pre> <p>병합된 멤버의 가시성 규칙은 <a href=\"declaration-merging#merging-namespaces\">Merging Namespaces</a> 세션에서 설명한 것과 같으므로, <code>AlbumLabel</code>클래스를 export해야 병합된 클래스를 볼 수 있습니다. 최종 결과는 다른 클래스 내에서 관리되는 클래스입니다. 또한 네임 스페이스를 사용하여 기존 클래스에 더 많은 정적 멤버를 추가할 수도 있습니다.</p> <p>내부 클래스 패턴 이외에도, JavaScript에서 함수를 생성하고 프로퍼티를 추가함으로써 함수를 확장하는 것에도 익숙할 것입니다. TypeScript는 선언 병합을 통해 타입을 안전하게 보존하며 정의할 수 있습니다.</p> <pre data-language=\"ts\">function buildLabel(name: string): string {\n  return buildLabel.prefix + name + buildLabel.suffix;\n}\n\nnamespace buildLabel {\n  export let suffix = \"\";\n  export let prefix = \"Hello, \";\n}\n\nconsole.log(buildLabel(\"Sam Smith\"));</pre> <p>마찬가지로 네임스페이스는 정적 멤버의 열거형을 확장할 수 있습니다:</p> <pre data-language=\"ts\">enum Color {\n  red = 1,\n  green = 2,\n  blue = 4,\n}\n\nnamespace Color {\n  export function mixColor(colorName: string) {\n    if (colorName == \"yellow\") {\n      return Color.red + Color.green;\n    } else if (colorName == \"white\") {\n      return Color.red + Color.green + Color.blue;\n    } else if (colorName == \"magenta\") {\n      return Color.red + Color.blue;\n    } else if (colorName == \"cyan\") {\n      return Color.green + Color.blue;\n    }\n  }\n}</pre> <h2 id=\"허용되지-않은-병합-disallowed-merges\" style=\"position:relative;\">허용되지 않은 병합 (Disallowed Merges)</h2> <p>TypeScript에서 모든 병합이 허용되는 것은 아닙니다. 클래스는 다른 클래스나 변수와 병합할 수 없습니다. 클래스 병합을 대체하는 것에 대한 정보는 <a href=\"https://www.typescriptlang.org/docs/handbook/mixins.html\">Mixins in TypeScript</a> 섹션에서 볼 수 있습니다.</p> <h2 id=\"모듈-보강-module-augmentation\" style=\"position:relative;\">모듈 보강 (Module Augmentation)</h2> <p>JavaScript는 모듈 병합을 지원하지 않지만 기존 객체를 import 하고 업데이트함으로써 패치할 수 있습니다. 쉬운 Observable 예를 살펴보겠습니다:</p> <pre data-language=\"ts\">// observable.ts\nexport class Observable&lt;T&gt; {\n  // ... 연습을 위해 남겨둠 ...\n}\n\n// map.ts\nimport { Observable } from \"./observable\";\nObservable.prototype.map = function (f) {\n  // ... 연습을 위해 남겨둠\n};</pre> <p>이는 TypeScript에서 잘 동작하지만, 컴파일러는 <code>Observable.prototype.map</code>에 대해 알지 못합니다. 모듈 보강을 통해 컴파일러에게 정보를 알려줄 수 있습니다:</p> <pre data-language=\"ts\">// observable.ts\nexport class Observable&lt;T&gt; {\n  // ... 연습을 위해 남겨둠 ...\n}\n\n// map.ts\nimport { Observable } from \"./observable\";\ndeclare module \"./observable\" {\n  interface Observable&lt;T&gt; {\n    map&lt;U&gt;(f: (x: T) =&gt; U): Observable&lt;U&gt;;\n  }\n}\nObservable.prototype.map = function (f) {\n  // ... 연습을 위해 남겨둠\n};\n\n// consumer.ts\nimport { Observable } from \"./observable\";\nimport \"./map\";\nlet o: Observable&lt;number&gt;;\no.map((x) =&gt; x.toFixed());</pre> <p>모듈 이름은 <code>import</code>/<code>export</code>의 모듈 지정자와 같은 방법으로 해석됩니다. 자세한 내용은 <a href=\"https://www.typescriptlang.org/docs/handbook/modules.html\">모듈</a>을 참고하세요. 그다음 보강된 선언은 마치 원본과 같은 파일에서 선언된 것처럼 병합됩니다.</p> <p>그러나, 두 가지 제한 사항을 명심하세요:</p> <ol> <li>보강에 새로운 최상위 선언을 할 수 없습니다 — 기존 선언에 대한 패치만 가능합니다.</li> <li>Default exports는 보강할 수 없으며, 이름을 갖는 export만 보강할 수 있습니다(해당 이름으로 확장시켜야 하며, <code>default</code>는 예약어입니다 - 자세한 내용은 <a href=\"https://github.com/Microsoft/TypeScript/issues/14080\">#14080</a>을 참고하세요)</li> </ol> <h2 id=\"전역-보강-global-augmentation\" style=\"position:relative;\">전역 보강 (Global augmentation)</h2> <p>모듈 내부에서 전역 스코프에 선언을 추가할 수 있습니다:</p> <pre data-language=\"ts\">// observable.ts\nexport class Observable&lt;T&gt; {\n  // ... 연습을 위해 남겨둠 ...\n}\n\ndeclare global {\n  interface Array&lt;T&gt; {\n    toObservable(): Observable&lt;T&gt;;\n  }\n}\n\nArray.prototype.toObservable = function () {\n  // ...\n};</pre> <p>전역 보강은 모듈 보강과 동일한 동작과 한계를 가지고 있습니다.</p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2012-2023 Microsoft<br>Licensed under the Apache License, Version 2.0.<br>\n    <a href=\"https://www.typescriptlang.org/ko/docs/handbook/declaration-merging.html\" class=\"_attribution-link\">https://www.typescriptlang.org/ko/docs/handbook/declaration-merging.html</a>\n  </p>\n</div>\n","namespaces-and-modules":"<h1>Namespaces and Modules</h1>\n<p>이 글에서는 TypeScript에서 모듈과 네임스페이스를 사용하여 코드를 구성하는 다양한 방법을 간략하게 설명합니다. 또한 네임스페이스와 모듈에 관한 몇 가지 고급 주제와 TypeScript에서 네임스페이스와 모듈을 사용할 때 흔히 마주치는 위험성을 살펴볼 것입니다.</p> <p>ES 모듈에 대한 자세한 내용은 <a href=\"modules.md\">모듈</a> 문서를 참고하세요. TypeScript 네임스페이스에 대한 자세한 내용은 <a href=\"namespaces.md\">네임스페이스</a> 문서를 참고하세요.</p> <p>참고: <em>매우</em> 오래된 버전의 TypeScript 네임스페이스는 이전의 JavaScript 모듈 시스템인 ‘내부 모듈’이라고 불렸습니다.</p> <h1 id=\"모듈-사용하기-using-modules\" style=\"position:relative;\">모듈 사용하기 (Using Modules)</h1> <p>모듈에는 코드와 선언 둘 다 포함될 수 있습니다.</p> <p>모듈은 또한 모듈 로더(예: CommonJs/Require.js)에 대한 의존성이나 ES 모듈이 지원하는 런타임을 가지고 있습니다. 모듈은 더 나은 코드 재사용성을 위해, 강력한 고립성과 번들링을 위한 향상된 도구를 제공합니다.</p> <p>또한 Node.js 애플리케이션의 경우 모듈이 기본적인 방법이며, 코드를 구조화하는 데 있어 권장하는 접근법이라는 점을 유의해야 합니다.</p> <p>ECMAScript 2015부터, 모듈은 언어에서 기본적으로 내재한 부분이며, 모든 호환 엔진 구현은 모듈을 지원해야 합니다. 따라서, 새로운 프로젝트의 경우 코드를 구성하는 방법으로 모듈을 권장합니다.</p> <h1 id=\"네임스페이스-사용하기-using-namespaces\" style=\"position:relative;\">네임스페이스 사용하기 (Using Namespaces)</h1> <p>네임스페이스는 코드를 구성하는 TypeScript만의 고유한 방법입니다. 네임스페이스는 간단히 전역 네임스페이스에서 JavaScript 객체로 이름 붙여집니다. 이러한 점 덕분에 네임스페이스를 아주 단순한 구조로 사용할 수 있습니다. 모듈과 달리, 여러 개의 파일을 포괄할 수 있으며, <code>--outFile</code>을 사용해 연결할 수 있습니다. 네임스페이스는 웹 애플리케이션에서 코드를 구조화하기에 좋은 방법이며, 모든 의존성은 HTML 페이지의 <code>&lt;script&gt;</code> 태그로 포함합니다.</p> <p>특히 대규모 애플리케이션의 경우, 이 방법은 모든 전역 네임스페이스가 오염되는 경우와 마찬가지로 컴포넌트의 의존성을 식별하기 힘들게 만들 수 있습니다.</p> <h1 id=\"네임스페이스와-모듈의-위험성-pitfalls-of-namespaces-and-modules\" style=\"position:relative;\">네임스페이스와 모듈의 위험성 (Pitfalls of Namespaces and Modules)</h1> <p>여기서는 네임스페이스와 모듈을 사용할 때 자주 발생하는 다양한 위험성과 그 해결책을 알아보겠습니다.</p> <h2 id=\"-reference를-사용한-모듈\" style=\"position:relative;\">\n<code>/// &lt;reference&gt;</code>를 사용한 모듈</h2> <p>일반적인 실수는 모듈 파일을 참조하기 위해 <code>import</code>문 대신 <code>/// &lt;reference ... /&gt;</code> 구문을 사용하는 것입니다. 이 둘의 차이를 이해하기 위해, 우선 <code>import</code> 경로에 위치한 모듈에 대한 타입 정보를 컴파일러가 어떻게 찾아내는지를 이해해야 합니다. (예를 들어, <code>import x from \"...\";</code>, <code>import x = require(\"...\");</code> 등 안의 <code>...</code>)</p> <p>컴파일러는 <code>.ts</code>, <code>.tsx</code>를 찾은 다음 적절한 경로에 위치한 <code>.d.ts</code>를 찾습니다. 만약 특정 파일을 찾지 못한다면, 컴파일러는 <em>앰비언트 모듈(ambient module) 선언</em>을 탐색할 것입니다. <code>.d.ts</code> 파일안에 이것들을 선언해야 한다는 점을 기억하세요.</p> <ul> <li> <p><code>myModules.d.ts</code></p> <pre data-language=\"ts\">// 모듈이 아닌 .d.ts 파일 또는 .ts 파일:\ndeclare module \"SomeModule\" {\n    export function fn(): string;\n}</pre> </li> <li> <p><code>myOtherModule.ts</code></p> <pre data-language=\"ts\">/// &lt;reference path=\"myModules.d.ts\" /&gt;\nimport * as m from \"SomeModule\";</pre> </li> </ul> <p>위의 reference 태그는 앰비언트 모듈(ambient module) 선언이 포함된 선언 파일의 위치를 지정하는 데 필요합니다. 이 방법은 여러 TypeScript 샘플에서 사용하는 <code>node.d.ts</code>파일을 사용하는 방법입니다.</p> <h2 id=\"불필요한-네임스페이스-needless-namespacing\" style=\"position:relative;\">불필요한 네임스페이스 (Needless Namespacing)</h2> <p>네임스페이스를 사용하던 프로그램을 모듈로 변경하면, 파일은 다음과 같은 모습이 되기 쉽습니다:</p> <ul> <li> <p><code>shapes.ts</code></p> <pre data-language=\"ts\">export namespace Shapes {\n    export class Triangle { /* ... */ }\n    export class Square { /* ... */ }\n}</pre> </li> </ul> <p>최상위 모듈 <code>Shapes</code>는 아무런 의미 없이 <code>Triangle</code>과 <code>Square</code>을 감싸고 있습니다. 이런 점은 모듈 사용자에게 혼동과 짜증을 유발합니다:</p> <ul> <li> <p><code>shapeConsumer.ts</code></p> <pre data-language=\"ts\">import * as shapes from \"./shapes\";\nlet t = new shapes.Shapes.Triangle(); // shapes.Shapes?</pre> </li> </ul> <p>TypeScript 모듈의 중요한 특징 중 하나는 서로 다른 두 개의 모듈이 절대 같은 스코프 안에 이름을 제공하지 않는다는 점입니다. 모듈 사용자가 어떤 이름을 할당할지를 결정하기 때문에, 네임스페이스 내부에서 내보내는 심벌을 미리 감싸줄 필요가 없습니다.</p> <p>모듈 내용의 네임스페이스를 설정하지 않아도 되는 이유를 다시 말하면, 네임스페이스를 지정하는 일반적인 목적은 구조의 논리적 그룹을 제공하고 이름 충돌을 방지하기 위함입니다. 모듈 파일이 이미 스스로 논리적 그룹을 형성하고 있기 때문에, 최상위 이름은 이를 가져오는 코드에 의해 정의되고, 내보내는 객체를 위한 추가적인 모듈 계층을 사용할 필요가 없습니다.</p> <p>다음은 수정된 예입니다:</p> <ul> <li> <p><code>shapes.ts</code></p> <pre data-language=\"ts\">export class Triangle { /* ... */ }\nexport class Square { /* ... */ }</pre> </li> <li> <p><code>shapeConsumer.ts</code></p> <pre data-language=\"ts\">import * as shapes from \"./shapes\";\nlet t = new shapes.Triangle();</pre> </li> </ul> <h2 id=\"모듈의-트레이드-오프-trade-offs-of-modules\" style=\"position:relative;\">모듈의 트레이드-오프 (Trade-offs of Modules)</h2> <p>JS 파일과 모듈이 일대일 대응인 것처럼, TypeScript는 모듈 소스 파일과 이 파일에서 생성된 JS 파일도 일대일 대응입니다. 이러한 특성 때문에 어떤 모듈 시스템을 사용하느냐에 따라서 여러 모듈 소스 파일을 합치는 작업이 불가능할 수 있습니다. 예를 들어, <code>commonjs</code> 또는 <code>umd</code>를 대상으로 하는 동안에는 <code>outFile</code> 옵션을 사용할 수 없지만, TypeScript 1.8 이후부터, <code>amd</code> 또는 <code>system</code>를 대상으로 하는 경우에는 <code>outFile</code> 옵션을 <a href=\"release%20notes/typescript%201.8.md#concatenate-amd-and-system-modules-with---outfile\">사용할 수 있게 되었습니다</a>.</p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2012-2023 Microsoft<br>Licensed under the Apache License, Version 2.0.<br>\n    <a href=\"https://www.typescriptlang.org/ko/docs/handbook/namespaces-and-modules.html\" class=\"_attribution-link\">https://www.typescriptlang.org/ko/docs/handbook/namespaces-and-modules.html</a>\n  </p>\n</div>\n","symbols":"<h1>Symbols</h1>\n<p>ECMAScript 2015부터, <code>symbol</code> 은 <code>number</code> 와 <code>string</code> 과 같은 기본 데이터 타입입니다.</p> <p><code>symbol</code> 값은 <code>Symbol</code> 생성자를 호출함으로써 생성됩니다.</p> <pre data-language=\"ts\">let sym1 = Symbol();\n\nlet sym2 = Symbol(\"key\"); // 선택적 문자열 키</pre> <p>심벌은 불변하고 유일합니다.</p> <pre data-language=\"ts\">let sym2 = Symbol(\"key\");\nlet sym3 = Symbol(\"key\");\n\nsym2 === sym3; // false, 심벌은 유일하다.</pre> <p>문자열처럼, 심벌은 객체 프로퍼티의 키로써 사용될 수 있습니다.</p> <pre data-language=\"ts\">const sym = Symbol();\n\nlet obj = {\n  [sym]: \"value\",\n};\n\nconsole.log(obj[sym]); // \"value\"</pre> <p>또한 심벌은 초기화된 프로퍼티 선언과 결합되어 객체 프로퍼티와 클래스 멤버를 선언할 수 있습니다.</p> <pre data-language=\"ts\">const getClassNameSymbol = Symbol();\n\nclass C {\n  [getClassNameSymbol]() {\n    return \"C\";\n  }\n}\n\nlet c = new C();\nlet className = c[getClassNameSymbol](); // \"C\"</pre> <h2 id=\"잘-알려진-심벌-well-known-symbols\" style=\"position:relative;\">잘 알려진 심벌 (Well-known Symbols)</h2> <p>사용자 정의 심벌 외에, 잘 알려진 내장 심벌이 있습니다. 내장 심벌은 언어 내부의 동작을 나타내는데 사용됩니다.</p> <p>아래는 잘 알려진 심벌의 목록입니다:</p> <h2 id=\"symbolhasinstance\" style=\"position:relative;\"><code>Symbol.hasInstance</code></h2> <p>생성자가 객체를 생성자의 인스턴스 중 하나로 인식하는지 확인하는 메서드. instanceof 연산자로 호출됩니다.</p> <h2 id=\"symbolisconcatspreadable\" style=\"position:relative;\"><code>Symbol.isConcatSpreadable</code></h2> <p>객체가 자신의 배열 요소를 Array.prototype.concat를 사용하여 직렬화할 수 있는지 나타내는 Boolean 값.</p> <h2 id=\"symboliterator\" style=\"position:relative;\"><code>Symbol.iterator</code></h2> <p>객체의 기본 반복자를 반환하는 메서드. for-of 문으로 호출됩니다.</p> <h2 id=\"symbolmatch\" style=\"position:relative;\"><code>Symbol.match</code></h2> <p>정규 표현식과 문자열을 비교하는 정규 표현식 메서드. <code>String.prototype.match</code> 메서드로 호출됩니다.</p> <h2 id=\"symbolreplace\" style=\"position:relative;\"><code>Symbol.replace</code></h2> <p>문자열에서 일치하는 부분 문자열을 치환하는 정규 표현식 메서드. <code>String.prototype.replace</code> 메서드로 호출됩니다.</p> <h2 id=\"symbolsearch\" style=\"position:relative;\"><code>Symbol.search</code></h2> <p>정규 표현식과 매치되는 문자열의 인덱스를 반환하는 정규 표현식 메서드. <code>String.prototype.search</code> 메서드로 호출됩니다.</p> <h2 id=\"symbolspecies\" style=\"position:relative;\"><code>Symbol.species</code></h2> <p>파생된 객체를 생성하는데 사용하는 생성자 함수의 중요한 속성.</p> <h2 id=\"symbolsplit\" style=\"position:relative;\"><code>Symbol.split</code></h2> <p>정규 표현식과 매치되는 인덱스들에 위치한 문자열을 나누는 정규 표현식 메서드. <code>String.prototype.split</code> 메서드로 호출됩니다.</p> <h2 id=\"symboltoprimitive\" style=\"position:relative;\"><code>Symbol.toPrimitive</code></h2> <p>객체를 대응되는 기본 값으로 변환하는 메서드.<br> <code>ToPrimitive</code> 추상 연산으로 호출됩니다.</p> <h2 id=\"symboltostringtag\" style=\"position:relative;\"><code>Symbol.toStringTag</code></h2> <p>객체의 기본 문자열 형식을 만드는데 사용되는 문자열 값. 내장 메서드인 <code>Object.prototype.toString</code> 로 호출됩니다.</p> <h2 id=\"symbolunscopables\" style=\"position:relative;\"><code>Symbol.unscopables</code></h2> <p>자신의 프로퍼티 이름이 연결된 개체의 ‘with’ 환경 바인딩에서 제외되는 프로퍼티 이름인 객체.</p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2012-2023 Microsoft<br>Licensed under the Apache License, Version 2.0.<br>\n    <a href=\"https://www.typescriptlang.org/ko/docs/handbook/symbols.html\" class=\"_attribution-link\">https://www.typescriptlang.org/ko/docs/handbook/symbols.html</a>\n  </p>\n</div>\n","modules":"<h1>Modules</h1>\n<p>ECMAScript 2015부터 JavaScript에는 모듈 개념이 있습니다. TypeScript는 이 개념을 공유합니다.</p> <p>모듈은 전역 스코프가 아닌 자체 스코프 내에서 실행됩니다; 즉 모듈 내에서 선언된 변수, 함수, 클래스 등은 <a href=\"#export\"><code>export</code> 양식</a> 중 하나를 사용하여 명시적으로 export 하지 않는 한 모듈 외부에서 보이지 않습니다. 반대로 다른 모듈에서 export 한 변수, 함수, 클래스, 인터페이스 등을 사용하기 위해서는 <a href=\"#import\"><code>import</code> 양식</a> 중 하나를 사용하여 import 해야 합니다.</p> <p>모듈은 선언형입니다; 모듈 간의 관계는 파일 수준의 imports 및 exports 관점에서 지정됩니다.</p> <p>모듈은 모듈 로더를 사용하여 다른 모듈을 import 합니다. 런타임 시 모듈 로더는 모듈을 실행하기 전에 모듈의 모든 의존성을 찾고 실행해야 합니다. JavaScript에서 사용하는 유명한 모듈 로더로는 <a href=\"https://en.wikipedia.org/wiki/CommonJS\">CommonJS</a> 모듈 용 Node.js의 로더와 웹 애플리케이션의 <a href=\"https://github.com/amdjs/amdjs-api/blob/master/AMD.md\">AMD</a> 모듈 용 <a href=\"https://requirejs.org/\">RequireJS</a> 로더가 있습니다.</p> <p>ECMAScript 2015와 마찬가지로 TypeScript는 최상위 수준의 <code>import</code> 혹은 <code>export</code>가 포함된 모든 파일을 모듈로 간주합니다. 반대로 최상위 수준의 <code>import</code> 혹은 <code>export</code> 선언이 없는 파일은 전역 스코프에서 사용할 수 있는 스크립트로 처리됩니다(모듈에서도 마찬가지).</p> <h1 id=\"export\" style=\"position:relative;\">Export</h1> <h2 id=\"선언-export-하기-exporting-a-declaration\" style=\"position:relative;\">선언 export 하기 (Exporting a declaration)</h2> <p><code>export</code> 키워드를 추가하여 모든 선언 (변수, 함수, 클래스, 타입 별칭, 인터페이스)를 export 할 수 있습니다.</p> <h5 id=\"stringvalidatorts\" style=\"position:relative;\">StringValidator.ts</h5> <pre data-language=\"ts\">export interface StringValidator {\n    isAcceptable(s: string): boolean;\n}</pre> <h5 id=\"zipcodevalidatorts\" style=\"position:relative;\">ZipCodeValidator.ts</h5> <pre data-language=\"ts\">import { StringValidator } from \"./StringValidator\";\n\nexport const numberRegexp = /^[0-9]+$/;\n\nexport class ZipCodeValidator implements StringValidator {\n    isAcceptable(s: string) {\n        return s.length === 5 &amp;&amp; numberRegexp.test(s);\n    }\n}</pre> <h2 id=\"export-문-export-statements\" style=\"position:relative;\">Export 문 (Export statements)</h2> <p>Export 문은 사용자를 위해 export 할 이름을 바꿔야 할 때 편리합니다. 위의 예제는 다음과 같이 작성할 수 있습니다:</p> <pre data-language=\"ts\">class ZipCodeValidator implements StringValidator {\n    isAcceptable(s: string) {\n        return s.length === 5 &amp;&amp; numberRegexp.test(s);\n    }\n}\nexport { ZipCodeValidator };\nexport { ZipCodeValidator as mainValidator };</pre> <h2 id=\"re-export-하기-re-exports\" style=\"position:relative;\">Re-export 하기 (Re-exports)</h2> <p>종종 모듈은 다른 모듈을 확장하고 일부 기능을 부분적으로 노출합니다. Re-export 하기는 지역적으로 import 하거나, 지역 변수를 도입하지 않습니다.</p> <h5 id=\"parseintbasedzipcodevalidatorts\" style=\"position:relative;\">ParseIntBasedZipCodeValidator.ts</h5> <pre data-language=\"ts\">export class ParseIntBasedZipCodeValidator {\n    isAcceptable(s: string) {\n        return s.length === 5 &amp;&amp; parseInt(s).toString() === s;\n    }\n}\n\n// 기존 validator의 이름을 변경 후 export\nexport {ZipCodeValidator as RegExpBasedZipCodeValidator} from \"./ZipCodeValidator\";</pre> <p>선택적으로, 하나의 모듈은 하나 혹은 여러 개의 모듈을 감쌀 수 있고, <code>export * from \"module\"</code> 구문을 사용해 export 하는 것을 모두 결합할 수 있습니다.</p> <h5 id=\"allvalidatorsts\" style=\"position:relative;\">AllValidators.ts</h5> <pre data-language=\"ts\">export * from \"./StringValidator\"; // 'StringValidator' 인터페이스를 내보냄\nexport * from \"./ZipCodeValidator\";  // 'ZipCodeValidator' 와 const 'numberRegexp' 클래스를 내보냄\nexport * from \"./ParseIntBasedZipCodeValidator\"; // 'ParseIntBasedZipCodeValidator' 클래스를 내보냄\n                                                 // 'ZipCodeValidator.ts' 모듈 에 있는\n                                                 // 'ZipCodeValidator' 클래스를\n                                                 // 'RegExpBasedZipCodeValidator' 라는 별칭으로 다시 내보냄</pre> <h1 id=\"import\" style=\"position:relative;\">Import</h1> <p>import는 모듈에서 export 만큼 쉽습니다. export 한 선언은 아래의 <code>import</code> 양식 중 하나를 사용하여 import 합니다:</p> <h2 id=\"모듈에서-단일-export를-import-하기-import-a-single-export-from-a-module\" style=\"position:relative;\">모듈에서 단일 export를 import 하기 (Import a single export from a module)</h2> <pre data-language=\"ts\">import { ZipCodeValidator } from \"./ZipCodeValidator\";\n\nlet myValidator = new ZipCodeValidator();</pre> <p>이름을 수정해서 import 할 수 있습니다.</p> <pre data-language=\"ts\">import { ZipCodeValidator as ZCV } from \"./ZipCodeValidator\";\nlet myValidator = new ZCV();</pre> <h2 id=\"전체-모듈을-단일-변수로-import-해서-모듈-exports-접근에-사용하기-import-the-entire-module-into-a-single-variable-and-use-it-to-access-the-module-exports\" style=\"position:relative;\">전체 모듈을 단일 변수로 import 해서, 모듈 exports 접근에 사용하기 (Import the entire module into a single variable, and use it to access the module exports)</h2> <pre data-language=\"ts\">import * as validator from \"./ZipCodeValidator\";\nlet myValidator = new validator.ZipCodeValidator();</pre> <h2 id=\"부수효과만을-위해-모듈-import-하기-import-a-module-for-side-effects-only\" style=\"position:relative;\">부수효과만을 위해 모듈 import 하기 (Import a module for side-effects only)</h2> <p>권장되지는 않지만, 일부 모듈은 다른 모듈에서 사용할 수 있도록 일부 전역 상태로 설정합니다. 이러한 모듈은 어떤 exports도 없거나, 사용자가 exports에 관심이 없습니다. 이러한 모듈을 import 하기 위해, 다음처럼 사용하세요:</p> <pre data-language=\"ts\">import \"./my-module.js\"</pre> <h2 id=\"타입-import-하기-importing-types\" style=\"position:relative;\">타입 import 하기 (Importing Types)</h2> <p>TypeScript 3.8 이전에는 <code>import</code>를 사용하여 타입을 import 할 수 있었습니다. TypeScript 3.8에서는 <code>import</code> 문 혹은 <code>import type</code>을 사용하여 타입을 import 할 수 있습니다.</p> <pre data-language=\"ts\">// 동일한 import를 재사용하기\nimport {APIResponseType} from \"./api\";\n\n// 명시적으로 import type을 사용하기\nimport type {APIResponseType} from \"./api\";</pre> <p><code>import type</code>은 항상 JavaScript에서 제거되며, 바벨 같은 도구는 <code>isolatedModules</code> 컴파일러 플래그를 통해 코드에 대해 더 나은 가정을 할 수 있습니다. <a href=\"https://devblogs.microsoft.com/typescript/announcing-typescript-3-8-beta/#type-only-imports-exports\">3.8 릴리즈 정보</a>에서 더 많은 정보를 읽을 수 있습니다.</p> <h1 id=\"default-exports\" style=\"position:relative;\">Default exports</h1> <p>각 모듈은 선택적으로 <code>default</code> export를 export 할 수 있습니다. default export는 <code>default</code> 키워드로 표시됩니다; 모듈당 하나의 <code>default</code> export만 가능합니다. <code>default</code> export는 다른 import 양식을 사용하여 import 합니다.</p> <p><code>default</code> exports는 정말 편리합니다. 예를 들어 jQuery와 같은 라이브러리는 <code>jQuery</code> 혹은 <code>$</code>와 같은 default export를 가질 수 있으며, <code>$</code>나 <code>jQuery</code>와 같은 이름으로 import할 수 있습니다.</p> <h5 id=\"jquerydts\" style=\"position:relative;\"><a href=\"https://github.com/DefinitelyTyped/DefinitelyTyped/blob/master/types/jquery/JQuery.d.ts\">JQuery.d.ts</a></h5> <pre data-language=\"ts\">declare let $: JQuery;\nexport default $;</pre> <h5 id=\"appts\" style=\"position:relative;\">App.ts</h5> <pre data-language=\"ts\">import $ from \"jquery\";\n\n$(\"button.continue\").html( \"Next Step...\" );</pre> <p>클래스 및 함수 선언은 default exports로 직접 작성될 수 있습니다. default export 클래스 및 함수 선언 이름은 선택사항 입니다.</p> <h5 id=\"zipcodevalidatorts-1\" style=\"position:relative;\">ZipCodeValidator.ts</h5> <pre data-language=\"ts\">export default class ZipCodeValidator {\n    static numberRegexp = /^[0-9]+$/;\n    isAcceptable(s: string) {\n        return s.length === 5 &amp;&amp; ZipCodeValidator.numberRegexp.test(s);\n    }\n}</pre> <h5 id=\"testts\" style=\"position:relative;\">Test.ts</h5> <pre data-language=\"ts\">import validator from \"./ZipCodeValidator\";\n\nlet myValidator = new validator();</pre> <p>혹은</p> <h5 id=\"staticzipcodevalidatorts\" style=\"position:relative;\">StaticZipCodeValidator.ts</h5> <pre data-language=\"ts\">const numberRegexp = /^[0-9]+$/;\n\nexport default function (s: string) {\n    return s.length === 5 &amp;&amp; numberRegexp.test(s);\n}</pre> <h5 id=\"testts-1\" style=\"position:relative;\">Test.ts</h5> <pre data-language=\"ts\">import validate from \"./StaticZipCodeValidator\";\n\nlet strings = [\"Hello\", \"98052\", \"101\"];\n\n// validate 함수 사용하기\nstrings.forEach(s =&gt; {\n  console.log(`\"${s}\" ${validate(s) ? \"matches\" : \"does not match\"}`);\n});</pre> <p><code>default</code> exports는 값도 가능합니다:</p> <h5 id=\"onetwothreets\" style=\"position:relative;\">OneTwoThree.ts</h5> <pre data-language=\"ts\">export default \"123\";</pre> <h5 id=\"logts\" style=\"position:relative;\">Log.ts</h5> <pre data-language=\"ts\">import num from \"./OneTwoThree\";\n\nconsole.log(num); // \"123\"</pre> <h2 id=\"x로-모두-export-하기-export-all-as-x\" style=\"position:relative;\">x로 모두 export 하기 (Export all as x)</h2> <p>TypeScript 3.8에서는 다음 이름이 다른 모듈로 re-export 될 때 단축어처럼 <code>export * as ns</code>를 사용할 수 있습니다:</p> <pre data-language=\"ts\">export * as utilities from \"./utilities\";</pre> <p>모듈에서 모든 의존성을 가져와 export한 필드로 만들면, 다음과 같이 import할 수 있습니다:</p> <pre data-language=\"ts\">import { utilities } from \"./index\";</pre> <h1 id=\"export-와-import--require-export--and-import--require\" style=\"position:relative;\">\n<code>export =</code>와 <code>import = require()</code> (<code>export =</code> and <code>import = require()</code>)</h1> <p>CommonJS와 AMD 둘 다 일반적으로 모듈의 모든 exports를 포함하는 <code>exports</code> 객체의 개념을 가지고 있습니다.</p> <p>또한 <code>exports</code> 객체를 사용자 정의 단일 객체로 대체하는 기능도 지원합니다. default exports는 이 동작에서 대체 역할을 합니다; 하지만 둘은 호환되지는 않습니다. TypeScript는 기존의 CommonJS와 AMD 워크플로우를 모델링 하기 위해 <code>export =</code>를 지원합니다.</p> <p><code>export =</code> 구문은 모듈에서 export되는 단일 객체를 지정합니다. 클래스, 인터페이스, 네임스페이스, 함수 혹은 열거형이 될 수 있습니다.</p> <p><code>export = </code>를 사용하여 모듈을 export할 때, TypeScript에 특정한 <code>import module = require(\"module\")</code>를 사용하여 모듈을 가져와야 합니다.</p> <h5 id=\"zipcodevalidatorts-2\" style=\"position:relative;\">ZipCodeValidator.ts</h5> <pre data-language=\"ts\">let numberRegexp = /^[0-9]+$/;\nclass ZipCodeValidator {\n    isAcceptable(s: string) {\n        return s.length === 5 &amp;&amp; numberRegexp.test(s);\n    }\n}\nexport = ZipCodeValidator;</pre> <h5 id=\"testts-2\" style=\"position:relative;\">Test.ts</h5> <pre data-language=\"ts\">import zip = require(\"./ZipCodeValidator\");\n\n// 시험용 샘플\nlet strings = [\"Hello\", \"98052\", \"101\"];\n\n// 사용할 Validators\nlet validator = new zip();\n\n// 각 문자열이 각 validator를 통과했는지 보여줍니다\nstrings.forEach(s =&gt; {\n  console.log(`\"${ s }\" - ${ validator.isAcceptable(s) ? \"matches\" : \"does not match\" }`);\n});</pre> <h1 id=\"모듈을-위한-코드-생성-code-generation-for-modules\" style=\"position:relative;\">모듈을 위한 코드 생성 (Code Generation for Modules)</h1> <p>컴파일 중에는 지정된 모듈 대상에 따라 컴파일러는 Node.js (<a href=\"http://wiki.commonjs.org/wiki/CommonJS\">CommonJS</a>), require.js (<a href=\"https://github.com/amdjs/amdjs-api/wiki/AMD\">AMD</a>), <a href=\"https://github.com/umdjs/umd\">UMD</a>, <a href=\"https://github.com/systemjs/systemjs\">SystemJS</a>, 또는 <a href=\"http://www.ecma-international.org/ecma-262/6.0/#sec-modules\">ECMAScript 2015 native modules</a> (ES6) 모듈-로딩 시스템에 적합한 코드를 생성합니다. 생성된 코드의 <code>define</code>, <code>require</code> 그리고 <code>register</code> 호출 기능에 대한 자세한 정보는 각 모듈 로더의 문서를 확인하세요.</p> <p>이 간단한 예제는 import 및 export 하기 중에 사용된 이름이 모듈 로딩 코드로 변환되는 방법을 보여줍니다.</p> <h5 id=\"simplemodulets\" style=\"position:relative;\">SimpleModule.ts</h5> <pre data-language=\"ts\">import m = require(\"mod\");\nexport let t = m.something + 1;</pre> <h5 id=\"amd--requirejs-simplemodulejs\" style=\"position:relative;\">AMD / RequireJS SimpleModule.js</h5> <pre data-language=\"js\">define([\"require\", \"exports\", \"./mod\"], function (require, exports, mod_1) {\n    exports.t = mod_1.something + 1;\n});</pre> <h5 id=\"commonjs--node-simplemodulejs\" style=\"position:relative;\">CommonJS / Node SimpleModule.js</h5> <pre data-language=\"js\">var mod_1 = require(\"./mod\");\nexports.t = mod_1.something + 1;</pre> <h5 id=\"umd-simplemodulejs\" style=\"position:relative;\">UMD SimpleModule.js</h5> <pre data-language=\"js\">(function (factory) {\n    if (typeof module === \"object\" &amp;&amp; typeof module.exports === \"object\") {\n        var v = factory(require, exports); if (v !== undefined) module.exports = v;\n    }\n    else if (typeof define === \"function\" &amp;&amp; define.amd) {\n        define([\"require\", \"exports\", \"./mod\"], factory);\n    }\n})(function (require, exports) {\n    var mod_1 = require(\"./mod\");\n    exports.t = mod_1.something + 1;\n});</pre> <h5 id=\"system-simplemodulejs\" style=\"position:relative;\">System SimpleModule.js</h5> <pre data-language=\"js\">System.register([\"./mod\"], function(exports_1) {\n    var mod_1;\n    var t;\n    return {\n        setters:[\n            function (mod_1_1) {\n                mod_1 = mod_1_1;\n            }],\n        execute: function() {\n            exports_1(\"t\", t = mod_1.something + 1);\n        }\n    }\n});</pre> <h5 id=\"native-ecmascript-2015-modules-simplemodulejs\" style=\"position:relative;\">Native ECMAScript 2015 modules SimpleModule.js</h5> <pre data-language=\"js\">import { something } from \"./mod\";\nexport var t = something + 1;</pre> <h1 id=\"간단한-예제-simple-example\" style=\"position:relative;\">간단한 예제 (Simple Example)</h1> <p>아래에서는 각 모듈에서 단일 이름으로 export 하기 위해 이전 예제에서 사용한 Validator 구현을 통합합니다.</p> <p>컴파일 하려면, 명령 줄에서 모듈 대상을 지정해야 합니다. Node.js의 경우, <code>--module commonjs</code>를 사용하세요; require.js의 경우 <code>--module amd</code>를 사용하세요. 예를 들면:</p> <pre data-language=\"typescript\">tsc --module commonjs Test.ts</pre> <p>컴파일이 되면, 각 모듈은 별도의 <code>.js</code>파일이 됩니다. 참조 태그와 마찬가지로, 컴파일러는 <code>import</code>문을 따라 의존적인 파일들을 컴파일 합니다.</p> <h5 id=\"validationts\" style=\"position:relative;\">Validation.ts</h5> <pre data-language=\"ts\">export interface StringValidator {\n    isAcceptable(s: string): boolean;\n}</pre> <h5 id=\"lettersonlyvalidatorts\" style=\"position:relative;\">LettersOnlyValidator.ts</h5> <pre data-language=\"ts\">import { StringValidator } from \"./Validation\";\n\nconst lettersRegexp = /^[A-Za-z]+$/;\n\nexport class LettersOnlyValidator implements StringValidator {\n    isAcceptable(s: string) {\n        return lettersRegexp.test(s);\n    }\n}</pre> <h5 id=\"zipcodevalidatorts-3\" style=\"position:relative;\">ZipCodeValidator.ts</h5> <pre data-language=\"ts\">import { StringValidator } from \"./Validation\";\n\nconst numberRegexp = /^[0-9]+$/;\n\nexport class ZipCodeValidator implements StringValidator {\n    isAcceptable(s: string) {\n        return s.length === 5 &amp;&amp; numberRegexp.test(s);\n    }\n}</pre> <h5 id=\"testts-3\" style=\"position:relative;\">Test.ts</h5> <pre data-language=\"ts\">import { StringValidator } from \"./Validation\";\nimport { ZipCodeValidator } from \"./ZipCodeValidator\";\nimport { LettersOnlyValidator } from \"./LettersOnlyValidator\";\n\n// 시험용 샘플\nlet strings = [\"Hello\", \"98052\", \"101\"];\n\n// 사용할 validator\nlet validators: { [s: string]: StringValidator; } = {};\nvalidators[\"ZIP code\"] = new ZipCodeValidator();\nvalidators[\"Letters only\"] = new LettersOnlyValidator();\n\n// 각 문자열이 validator를 통과하는지 보여줌\nstrings.forEach(s =&gt; {\n    for (let name in validators) {\n        console.log(`\"${ s }\" - ${ validators[name].isAcceptable(s) ? \"matches\" : \"does not match\" } ${ name }`);\n    }\n});</pre> <h1 id=\"선택적-모듈-로딩과-기타-고급-로딩-시나리오-optional-module-loading-and-other-advanced-loading-scenarios\" style=\"position:relative;\">선택적 모듈 로딩과 기타 고급 로딩 시나리오 (Optional Module Loading and Other Advanced Loading Scenarios)</h1> <p>상황에 따라 특정 조건에서만 모듈을 로드하도록 만들 수 있습니다. TypeScript에서는 아래에 있는 패턴을 사용하여 이 시나리오와 다른 고급 로딩 시나리오를 구현하여 타입의 안전성을 잃지 않고 모듈 로더를 직접 호출할 수 있습니다.</p> <p>컴파일러는 노출된 JavaScript 안에서 각 모듈의 사용 여부를 감지합니다. 모듈 식별자가 표현식이 아닌 타입 표시로만 사용된다면 그 모듈에 대한 <code>require</code> 호출은 발생하지 않습니다. 사용하지 않는 참조를 제거하면 성능을 최적화할 수 있으며, 해당 모듈을 선택적으로 로딩 할 수 있습니다.</p> <p>이 패턴의 핵심 아이디어는 <code>import id = require(\"...\")</code> 문을 통해 모듈로 노출된 타입에 접근이 가능하다는 것입니다. 아래 <code>if</code> 블록에 보이는 것처럼, 모듈 로더는 (<code>require</code>을 통해) 동적으로 호출됩니다. 이 기능은 참조-제거 최적화를 활용하므로 필요할 때만 모듈을 로드할 수 있습니다. 해당 패턴이 동작하려면 <code>import</code>를 통해 정의된 심벌은 오직 타입 위치(즉, JavaScript로 방출되는 위치에서는 사용 안 함)에서만 사용되는 것이 중요합니다.</p> <p>타입 안전성을 유지하기 위해, <code>typeof</code> 키워드를 사용할 수 있습니다. <code>typeof</code> 키워드는 타입 위치에서 사용될 때는 값의 타입, 이 경우에는 모듈의 타입을 생성합니다.</p> <h5 id=\"nodejs에서-동적-모듈-로딩-dynamic-module-loading-in-nodejs\" style=\"position:relative;\">Node.js에서 동적 모듈 로딩 (Dynamic Module Loading in Node.js)</h5> <pre data-language=\"ts\">declare function require(moduleName: string): any;\n\nimport { ZipCodeValidator as Zip } from \"./ZipCodeValidator\";\n\nif (needZipValidation) {\n    let ZipCodeValidator: typeof Zip = require(\"./ZipCodeValidator\");\n    let validator = new ZipCodeValidator();\n    if (validator.isAcceptable(\"...\")) { /* ... */ }\n}</pre> <h5 id=\"샘플-requirejs에서-동적-모듈-로딩-sample-dynamic-module-loading-in-requirejs\" style=\"position:relative;\">샘플: require.js에서 동적 모듈 로딩 (Sample: Dynamic Module Loading in require.js)</h5> <pre data-language=\"ts\">declare function require(moduleNames: string[], onLoad: (...args: any[]) =&gt; void): void;\n\nimport * as Zip from \"./ZipCodeValidator\";\n\nif (needZipValidation) {\n    require([\"./ZipCodeValidator\"], (ZipCodeValidator: typeof Zip) =&gt; {\n        let validator = new ZipCodeValidator.ZipCodeValidator();\n        if (validator.isAcceptable(\"...\")) { /* ... */ }\n    });\n}</pre> <h5 id=\"샘플-systemjs에서-동적-모듈-로딩-sample-dynamic-module-loading-in-systemjs\" style=\"position:relative;\">샘플: System.js에서 동적 모듈 로딩 (Sample: Dynamic Module Loading in System.js)</h5> <pre data-language=\"ts\">declare const System: any;\n\nimport { ZipCodeValidator as Zip } from \"./ZipCodeValidator\";\n\nif (needZipValidation) {\n    System.import(\"./ZipCodeValidator\").then((ZipCodeValidator: typeof Zip) =&gt; {\n        var x = new ZipCodeValidator();\n        if (x.isAcceptable(\"...\")) { /* ... */ }\n    });\n}</pre> <h1 id=\"다른-javascript-라이브러리와-함께-사용하기-working-with-other-javascript-libraries\" style=\"position:relative;\">다른 JavaScript 라이브러리와 함께 사용하기 (Working with Other JavaScript Libraries)</h1> <p>TypeScript로 작성되지 않은 라이브러리의 형태를 설명하려면, 라이브러리를 노출하는 API를 선언해야 합니다.</p> <p>우리는 구현을 정의하지 않은 선언을 “ambient”라고 부릅니다. 이 선언들은 일반적으로 <code>.d.ts</code> 파일에 정의되어 있습니다. C/C++에 익숙하다면, <code>.h</code> 파일이라고 생각할 수 있습니다. 몇 가지 예제를 살펴보겠습니다.</p> <h2 id=\"ambient-모듈-ambient-modules\" style=\"position:relative;\">Ambient 모듈 (Ambient Modules)</h2> <p>Node.js에서는 대부분의 작업은 하나 이상의 모듈을 로드하여 수행합니다. 최상위-레벨의 내보내기 선언으로 각 모듈을 <code>.d.ts</code> 파일로 정의할 수 있지만, 더 큰 하나의 <code>.d.ts</code> 파일로 모듈들을 작성하는 것이 더 편리합니다. 이를 위해, ambient 네임스페이스와 유사한 구조를 사용하지만, 나중에 import 할 수 있는 인용된 모듈 이름과 <code>module</code> 키워드를 사용합니다. 예를 들면:</p> <h5 id=\"nodedts-간단한-발췌\" style=\"position:relative;\">node.d.ts (간단한 발췌)</h5> <pre data-language=\"ts\">declare module \"url\" {\n    export interface Url {\n        protocol?: string;\n        hostname?: string;\n        pathname?: string;\n    }\n\n    export function parse(urlStr: string, parseQueryString?, slashesDenoteHost?): Url;\n}\n\ndeclare module \"path\" {\n    export function normalize(p: string): string;\n    export function join(...paths: any[]): string;\n    export var sep: string;\n}</pre> <p>이제 <code>/// &lt;reference&gt;</code> <code>node.d.ts</code>를 수행한 다음, <code>import url = require(\"url\");</code> 또는 <code>import * as URL from \"url\"</code>을 사용하여 모듈을 로드할 수 있습니다.</p> <pre data-language=\"ts\">/// &lt;reference path=\"node.d.ts\"/&gt;\nimport * as URL from \"url\";\nlet myUrl = URL.parse(\"http://www.typescriptlang.org\");</pre> <h3 id=\"속기-ambient-모듈-shorthand-ambient-modules\" style=\"position:relative;\">속기 ambient 모듈 (Shorthand ambient modules)</h3> <p>새로운 모듈을 사용하기 전에 선언을 작성하지 않는 경우, 속기 선언(shorthand declaration)을 사용하여 빠르게 시작할 수 있습니다.</p> <h5 id=\"declarationsdts\" style=\"position:relative;\">declarations.d.ts</h5> <pre data-language=\"ts\">declare module \"hot-new-module\";</pre> <p>속기 모듈로부터 모든 imports는 <code>any</code> 타입을 가집니다.</p> <pre data-language=\"ts\">import x, {y} from \"hot-new-module\";\nx(y);</pre> <h3 id=\"와일드카드-모듈-선언-wildcard-module-declarations\" style=\"position:relative;\">와일드카드 모듈 선언 (Wildcard module declarations)</h3> <p><a href=\"https://github.com/systemjs/systemjs/blob/master/docs/overview.md#plugin-syntax\">SystemJS</a>나 <a href=\"https://github.com/amdjs/amdjs-api/blob/master/LoaderPlugins.md\">AMD</a>와 같은 모듈 로더는 비-JavaScript 내용을 import 할 수 있습니다. 이 둘은 일반적으로 접두사 또는 접미사를 사용하여 특수한 로딩 의미를 표시합니다. 이러한 경우를 다루기 위해 와일드카드 모듈 선언을 사용할 수 있습니다.</p> <pre data-language=\"ts\">declare module \"*!text\" {\n    const content: string;\n    export default content;\n}\n// 일부는 다른 방법으로 사용합니다.\ndeclare module \"json!*\" {\n    const value: any;\n    export default value;\n}</pre> <p>이제 <code>\"*!text\"</code> 나 <code>\"json!*\"</code>와 일치하는 것들을 import 할 수 있습니다.</p> <pre data-language=\"ts\">import fileContent from \"./xyz.txt!text\";\nimport data from \"json!http://example.com/data.json\";\nconsole.log(data, fileContent);</pre> <h3 id=\"umd-모듈-umd-modules\" style=\"position:relative;\">UMD 모듈 (UMD modules)</h3> <p>일부 라이브러리는 많은 모듈 로더에서 사용되거나, 모듈 로딩 (전역 변수) 없이 사용되도록 설계되었습니다. 이를 <a href=\"https://github.com/umdjs/umd\">UMD</a> 모듈이라고 합니다. 이러한 라이브러리는 import나 전역 변수를 통해 접근할 수 있습니다. 예를 들면:</p> <h5 id=\"math-libdts\" style=\"position:relative;\">math-lib.d.ts</h5> <pre data-language=\"ts\">export function isPrime(x: number): boolean;\nexport as namespace mathLib;</pre> <p>라이브러리는 모듈 내에서 import로 사용할 수 있습니다:</p> <pre data-language=\"ts\">import { isPrime } from \"math-lib\";\nisPrime(2);\nmathLib.isPrime(2); // 오류: 모듈 내부에서 전역 정의를 사용할 수 없습니다.</pre> <p>전역 변수로도 사용할 수 있지만, 스크립트 내에서만 사용할 수 있습니다. (스크립트는 imports나 exports가 없는 파일입니다.)</p> <pre data-language=\"ts\">mathLib.isPrime(2);</pre> <h1 id=\"모듈-구조화에-대한-지침-guidance-for-structuring-modules\" style=\"position:relative;\">모듈 구조화에 대한 지침 (Guidance for structuring modules)</h1> <h2 id=\"가능한-최상위-레벨에-가깝게-export-하기-export-as-close-to-top-level-as-possible\" style=\"position:relative;\">가능한 최상위-레벨에 가깝게 export 하기 (Export as close to top-level as possible)</h2> <p>모듈의 사용자가 export 모듈을 사용할 때 가능한 마찰이 적어야 합니다. 중첩 수준을 과도하게 추가하면 다루기 힘들어지는 경향이 있으므로, 어떻게 구조를 구성할지 신중하게 생각해야 합니다.</p> <p>모듈에서 네임스페이스를 export 하는 것은 너무 많은 중첩 레이어를 추가하는 예입니다. 네임스페이스는 때때로 용도가 있지만, 모듈을 사용할 때 추가적인 레벨의 간접 참조를 추가합니다. 이것은 사용자에게 금방 고통스러운 지점이 될 수 있고, 일반적으로 불필요합니다.</p> <p>export 한 클래스의 정적 메서드에도 비슷한 문제가 있습니다 - 클래스 자체에 중첩 레이어가 추가됩니다. 표현이나 의도를 명확하게 유용한 방식으로 높이지 않는 한 간단하게 헬퍼 함수를 export 하는 것을 고려하세요.</p> <h3 id=\"단일-class나-function을--export-할-경우-export-default를-사용하세요-if-youre-only-exporting-a-single-class-or-function-use-export-default\" style=\"position:relative;\">단일 <code>class</code>나 <code>function</code>을 export 할 경우, <code>export default</code>를 사용하세요 (If you’re only exporting a single <code>class</code> or <code>function</code>, use <code>export default</code>)</h3> <p>“최상위-레벨에 가까운 export”가 모듈 사용자의 마찰을 줄여주는 것처럼, default export를 도입하는 것도 마찬가지입니다. 모듈의 주요 목적이 한 개의 특정 export를 저장하는 것이라면, default export로 export 하는 것을 고려하세요. 이렇게 하면 import 하기와 실제로 import를 사용하기가 더 쉬워집니다. 예를 들면:</p> <h4 id=\"myclassts\" style=\"position:relative;\">MyClass.ts</h4> <pre data-language=\"ts\">export default class SomeType {\n  constructor() { ... }\n}</pre> <h4 id=\"myfuncts\" style=\"position:relative;\">MyFunc.ts</h4> <pre data-language=\"ts\">export default function getThing() { return \"thing\"; }</pre> <h4 id=\"consumerts\" style=\"position:relative;\">Consumer.ts</h4> <pre data-language=\"ts\">import t from \"./MyClass\";\nimport f from \"./MyFunc\";\nlet x = new t();\nconsole.log(f());</pre> <p>이것은 사용자에게 최적입니다. 타입에 원하는 이름(이 경우에는 <code>t</code>)을 지정할 수 있고 객체를 찾기 위해 과도한 점을 찍지 않아도 됩니다.</p> <h3 id=\"여러-객체를-export-하는-경우-최상위-레벨에-두세요-if-youre-exporting-multiple-objects-put-them-all-at-top-level\" style=\"position:relative;\">여러 객체를 export 하는 경우, 최상위-레벨에 두세요 (If you’re exporting multiple objects, put them all at top-level)</h3> <h4 id=\"mythingsts\" style=\"position:relative;\">MyThings.ts</h4> <pre data-language=\"ts\">export class SomeType { /* ... */ }\nexport function someFunc() { /* ... */ }</pre> <p>반대로 import 할 때:</p> <h3 id=\"import-한-이름을-명시적으로-나열-explicitly-list-imported-names\" style=\"position:relative;\">import 한 이름을 명시적으로 나열 (Explicitly list imported names)</h3> <h4 id=\"consumerts-1\" style=\"position:relative;\">Consumer.ts</h4> <pre data-language=\"ts\">import { SomeType, someFunc } from \"./MyThings\";\nlet x = new SomeType();\nlet y = someFunc();</pre> <h3 id=\"많은-것을-import-하는-경우-네임스페이스-import-패턴을-사용하세요-use-the-namespace-import-pattern-if-youre-importing-a-large-number-of-things\" style=\"position:relative;\">많은 것을 import 하는 경우, 네임스페이스 import 패턴을 사용하세요 (Use the namespace import pattern if you’re importing a large number of things)</h3> <h4 id=\"mylargemodulets\" style=\"position:relative;\">MyLargeModule.ts</h4> <pre data-language=\"ts\">export class Dog { ... }\nexport class Cat { ... }\nexport class Tree { ... }\nexport class Flower { ... }</pre> <h4 id=\"consumerts-2\" style=\"position:relative;\">Consumer.ts</h4> <pre data-language=\"ts\">import * as myLargeModule from \"./MyLargeModule.ts\";\nlet x = new myLargeModule.Dog();</pre> <h2 id=\"상속을-위한-re-export-하기-re-export-to-extend\" style=\"position:relative;\">상속을 위한 re-export 하기 (Re-export to extend)</h2> <p>종종 모듈의 기능을 확장해야 할 필요가 있습니다. 일반적인 JS 패턴은 JQuery 확장이 작동하는 방식과 유사하게 *확장(extensions)*으로 기존의 객체를 보강하는 것입니다. 앞에서 언급했듯이 모듈은 전역 네임스페이스 객체와 같이 <em>병합(merge)</em> 하지 않습니다. 여기서 추천하는 방법은 기존의 객체를 <em>변형하지 않고</em> 새로운 기능을 제공하는 개체를 export 하는 것입니다.</p> <p><code>Calculator.ts</code> 모듈에 정의된 간단한 계산기 구현을 생각해보세요. 이 모듈도 입력 문자열 목록을 전달하고 결과를 작성하여 계산기의 기능을 테스트할 수 있는 헬퍼 함수를 export 합니다.</p> <h4 id=\"calculatorts\" style=\"position:relative;\">Calculator.ts</h4> <pre data-language=\"ts\">export class Calculator {\n    private current = 0;\n    private memory = 0;\n    private operator: string;\n\n    protected processDigit(digit: string, currentValue: number) {\n        if (digit &gt;= \"0\" &amp;&amp; digit &lt;= \"9\") {\n            return currentValue * 10 + (digit.charCodeAt(0) - \"0\".charCodeAt(0));\n        }\n    }\n\n    protected processOperator(operator: string) {\n        if ([\"+\", \"-\", \"*\", \"/\"].indexOf(operator) &gt;= 0) {\n            return operator;\n        }\n    }\n\n    protected evaluateOperator(operator: string, left: number, right: number): number {\n        switch (this.operator) {\n            case \"+\": return left + right;\n            case \"-\": return left - right;\n            case \"*\": return left * right;\n            case \"/\": return left / right;\n        }\n    }\n\n    private evaluate() {\n        if (this.operator) {\n            this.memory = this.evaluateOperator(this.operator, this.memory, this.current);\n        }\n        else {\n            this.memory = this.current;\n        }\n        this.current = 0;\n    }\n\n    public handleChar(char: string) {\n        if (char === \"=\") {\n            this.evaluate();\n            return;\n        }\n        else {\n            let value = this.processDigit(char, this.current);\n            if (value !== undefined) {\n                this.current = value;\n                return;\n            }\n            else {\n                let value = this.processOperator(char);\n                if (value !== undefined) {\n                    this.evaluate();\n                    this.operator = value;\n                    return;\n                }\n            }\n        }\n        throw new Error(`Unsupported input: '${char}'`);\n    }\n\n    public getResult() {\n        return this.memory;\n    }\n}\n\nexport function test(c: Calculator, input: string) {\n    for (let i = 0; i &lt; input.length; i++) {\n        c.handleChar(input[i]);\n    }\n\n    console.log(`result of '${input}' is '${c.getResult()}'`);\n}</pre> <p>노출된 <code>test</code> 함수를 사용하는 간단한 계산기 테스트입니다.</p> <h4 id=\"testcalculatorts\" style=\"position:relative;\">TestCalculator.ts</h4> <pre data-language=\"ts\">import { Calculator, test } from \"./Calculator\";\n\n\nlet c = new Calculator();\ntest(c, \"1+2*33/11=\"); // 9 출력</pre> <p>10이 아닌 숫자를 입력받을 수 있도록 이것을 상속하여 <code>ProgrammerCalculator.ts</code>을 만들어보겠습니다.</p> <h4 id=\"programmercalculatorts\" style=\"position:relative;\">ProgrammerCalculator.ts</h4> <pre data-language=\"ts\">import { Calculator } from \"./Calculator\";\n\nclass ProgrammerCalculator extends Calculator {\n    static digits = [\"0\", \"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\", \"A\", \"B\", \"C\", \"D\", \"E\", \"F\"];\n\n    constructor(public base: number) {\n        super();\n        const maxBase = ProgrammerCalculator.digits.length;\n        if (base &lt;= 0 || base &gt; maxBase) {\n            throw new Error(`base has to be within 0 to ${maxBase} inclusive.`);\n        }\n    }\n\n    protected processDigit(digit: string, currentValue: number) {\n        if (ProgrammerCalculator.digits.indexOf(digit) &gt;= 0) {\n            return currentValue * this.base + ProgrammerCalculator.digits.indexOf(digit);\n        }\n    }\n}\n\n// 새로 상속된 calculator를 Calculator로 export 하기\nexport { ProgrammerCalculator as Calculator };\n\n// 또한 헬퍼 함수도 export 하기\nexport { test } from \"./Calculator\";</pre> <p>새로운 <code>ProgrammerCalculator</code> 모듈은 <code>Calculator</code> 모듈과 유사한 API 형태를 export 하지만, 원래 모듈의 객체를 보강하지는 않습니다. 다음은 ProgrammerCalculator 클래스에 대한 테스트입니다:</p> <h4 id=\"testprogrammercalculatorts\" style=\"position:relative;\">TestProgrammerCalculator.ts</h4> <pre data-language=\"ts\">import { Calculator, test } from \"./ProgrammerCalculator\";\n\nlet c = new Calculator(2);\ntest(c, \"001+010=\"); // 3 출력</pre> <h2 id=\"모듈에서-네임스페이스를-사용하지-마세요-do-not-use-namespaces-in-modules\" style=\"position:relative;\">모듈에서 네임스페이스를 사용하지 마세요 (Do not use namespaces in modules)</h2> <p>모듈 기반 구성을 처음 적용할 때, 일반적으로 추가적인 네임스페이스 계층에서 exports를 래핑 하는 경향이 있습니다. 모듈에는 자체 스코프가 있으며, export된 선언만 모듈 외부에서 볼 수 있습니다. 이를 염두에 두고 네임스페이스는 모듈을 다룰 때 거의 값을 변경하지 않습니다.</p> <p>구성 전면에서 네임스페이스는 논리적으로 관련된 개체와 타입을 전역 스코프로 그룹화하는데 편리합니다. 예를 들어, C#의 경우, System.Collections에서 모든 컬렉션 타입을 찾을 수 있습니다. 타입을 계층적 네임스페이스로 구성하여 해당 타입의 사용자에게 “발견”할 수 있는 좋은 경험을 제공합니다. 반면, 모듈은 이미 파일 시스템에 반드시 존재합니다. 경로와 파일 이름으로 해석하기 위해서, 논리적 구성 체계를 사용할 수 있습니다. 리스트 모듈이 있는 /collections/generic/ 폴더를 사용할 수 있습니다.</p> <p>네임스페이스는 전역 스코프에서 네이밍 충돌을 피하기 위해 중요합니다. 예를 들어, <code>My.Application.Customer.AddForm</code>과 <code>My.Application.Order.AddForm</code> — 두 타입의 이름은 같지만 다른 네임스페이스를 가지고 있습니다. 그러나 이것은 모듈에서 문제가 되지 않습니다. 모듈 내에서 두 개의 객체가 같은 이름을 가질만한 이유는 없습니다. 사용 측면에서 특정 모듈의 사용자는 모듈을 참조하는데 사용할 이름을 선택하므로 우연한 이름 충돌은 불가능합니다.</p> <blockquote> <p>모듈과 네임스페이스에 대한 자세한 내용은 <a href=\"namespaces-and-modules.md\">Namespaces and Modules</a>를 참고하세요</p> </blockquote> <h2 id=\"위험-신호-red-flags\" style=\"position:relative;\">위험 신호 (Red Flags)</h2> <p>다음은 모두 모듈 구조화에 대한 위험 신호입니다. 다음 중 하나라도 파일에 적용되는 경우 외부 모듈의 네임스페이스를 만들려고 하지 않았는지 다시 확인하세요:</p> <ul> <li>오직 최상위-레벨 선언만 <code>export namespace Foo { ... }</code>인 파일 (<code>Foo</code>를 제거하고 모든 것을 ‘상위’ 레벨로 이동하세요)</li> <li>최상위-레벨 위치에 동일한 <code>export namespace Foo {</code>를 가진 여러 파일 (하나의 <code>Foo</code>로 결합될 거라 생각하지 마세요!)</li> </ul><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2012-2023 Microsoft<br>Licensed under the Apache License, Version 2.0.<br>\n    <a href=\"https://www.typescriptlang.org/ko/docs/handbook/modules.html\" class=\"_attribution-link\">https://www.typescriptlang.org/ko/docs/handbook/modules.html</a>\n  </p>\n</div>\n","declaration-files/introduction":"<h1>Introduction</h1>\n<p>이 가이드는 고품질의 TypeScript 선언 파일을 작성하는 방법을 알려주기 위해 작성되었습니다.</p> <p>이 가이드는, TypeScript 언어에 대한 기본 지식이 있다고 가정합니다. 만약 기본 지식이 없다면, <a href=\"https://www.typescriptlang.org/docs/handbook/basic-types.html\">TypeScript 핸드북</a>을 반드시 읽고 기본 개념, 특히 타입과 모듈에 익숙해져야 합니다.</p> <h1 id=\"섹션-sections\" style=\"position:relative;\">섹션 (Sections)</h1> <p>이 가이드는 다음 섹션들로 구성됩니다.</p> <h2 id=\"라이브러리-구조-library-structures\" style=\"position:relative;\">라이브러리 구조 (Library Structures)</h2> <p><a href=\"https://www.typescriptlang.org/docs/handbook/declaration-files/library-structures.html\">라이브러리 구조</a>는 일반적인 라이브러리 포맷과 각 포맷에 대한 올바른 선언 파일을 작성하는 방법에 대해 알려줍니다. 기존 파일을 수정하는 경우라면, 이 섹션을 읽으실 필요는 없습니다. 새로운 선언 파일을 작성해야 한다면 라이브러리의 포맷이 선언 파일 작성에 어떻게 영향을 미치는지 올바르게 이해하기 위해 반드시 읽어야 합니다.</p> <h2 id=\"예제를-통해-by-example\" style=\"position:relative;\">예제를 통해 (By Example)</h2> <p>많은 경우, 기본 라이브러리 예제만 있을 때, 선언 파일을 작성해야 합니다. <a href=\"https://www.typescriptlang.org/docs/handbook/declaration-files/by-example.html\">예제를 통해</a> 섹션은 많은 API 패턴들과 각 패턴들의 선언을 작성하는 방법을 보여줍니다. 이 가이드는 TypeScript의 모든 언어 구성에 아직 익숙하지 않은 TypeScript 초심자에 초점을 맞추고 있습니다.</p> <h2 id=\"해야-할-것과-하지-말아야-할-것-dos-and-donts\" style=\"position:relative;\">해야 할 것과 하지 말아야 할 것 (“Do”s and “Don’t”s)</h2> <p>선언 파일의 많은 실수들은 쉽게 피할 수 있습니다. <a href=\"https://www.typescriptlang.org/docs/handbook/declaration-files/do-s-and-don-ts.html\">해야 할 것과 하지 말아야 할 것</a> 섹션은 흔한 오류들을 식별하고, 감지하는 방법과, 수정하는 방법을 설명합니다. 흔한 실수들을 피하기 위해 반드시 모두가 이 섹션을 읽어야 합니다.</p> <h2 id=\"깊게-들어가기-deep-dive\" style=\"position:relative;\">깊게 들어가기 (Deep Dive)</h2> <p>선언 파일이 동작하는 메커니즘에 관심 있는 숙련된 사용자들에게, <a href=\"https://www.typescriptlang.org/docs/handbook/declaration-files/deep-dive.html\">깊게 들어가기</a> 섹션은 선언 작성의 많은 고급 개념을 설명해 주고, 이 개념들을 활용하여 깔끔하고 더 직관적인 선언 파일을 만드는 방법을 보여줍니다.</p> <h2 id=\"템플릿-templates\" style=\"position:relative;\">템플릿 (Templates)</h2> <p><a href=\"https://www.typescriptlang.org/docs/handbook/declaration-files/templates.html\">템플릿</a>에서는 새로운 파일을 작성할 때, 유용한 시작점을 제공하는 여러 선언 파일들을 찾을 수 있습니다. <a href=\"https://www.typescriptlang.org/docs/handbook/declaration-files/library-structures.html\">라이브러리 구조</a> 문서를 참고하여 어떤 템플릿 파일을 사용할지 알아보세요.</p> <h2 id=\"npm에-배포하기-publish-to-npm\" style=\"position:relative;\">npm에 배포하기 (Publish to npm)</h2> <p><a href=\"https://www.typescriptlang.org/docs/handbook/declaration-files/publishing.html\">배포</a> 섹션은 선언 파일을 npm 패키지에 배포하는 방법과, 의존성 패키지를 관리하는 방법을 설명합니다.</p> <h2 id=\"선언-파일을-찾고-설치하기-find-and-install-declaration-files\" style=\"position:relative;\">선언 파일을 찾고 설치하기 (Find and Install Declaration Files)</h2> <p>JavaScript 라이브러리 사용자를 위해, <a href=\"https://www.typescriptlang.org/docs/handbook/declaration-files/consumption.html\">소비</a> 섹션은 해당 선언 파일을 찾고 설치하는 몇 가지 간단한 방법을 제공합니다.</p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2012-2023 Microsoft<br>Licensed under the Apache License, Version 2.0.<br>\n    <a href=\"https://www.typescriptlang.org/ko/docs/handbook/declaration-files/introduction.html\" class=\"_attribution-link\">https://www.typescriptlang.org/ko/docs/handbook/declaration-files/introduction.html</a>\n  </p>\n</div>\n","migrating-from-javascript":"<h1>Migrating from JavaScript</h1>\n<p>TypeScript는 공백 상태가 아닙니다. JavaScript 생태계를 바탕으로 구축되었으며, 오늘날 많은 JavaScript가 존재합니다. JavaScript 코드 베이스를 TypeScript로 변환하는 것은 다소 지루하지만 어렵진 않습니다. 이 튜토리얼에서 어떻게 시작하는지 살펴보겠습니다. TypeScript 코드를 작성하기 위해 핸드북을 충분히 읽었다고 가정하고 설명하겠습니다.</p> <p>React 프로젝트를 변환하고자 한다면, <a href=\"https://github.com/Microsoft/TypeScript-React-Conversion-Guide#typescript-react-conversion-guide\">React 변환 가이드</a>를 먼저 읽어보는 것을 추천합니다.</p> <h1 id=\"디렉토리-설정하기-setting-up-your-directories\" style=\"position:relative;\">디렉토리 설정하기 (Setting up your Directories)</h1> <p>일반 JavaScript로 작성하는 경우, <code>src</code>, <code>lib</code> 또는 <code>dist</code> 디렉터리에 있는 <code>.js</code> 파일이 JavaScript를 직접 실행한 다음, 원하는 대로 실행했을 가능성이 높습니다.</p> <p>이 경우, 작성한 파일은 TypeScript에 입력으로 사용되고, 그로 인한 출력을 실행하게 됩니다. JS에서 TS로의 전환하는 동안, TypeScript가 입력 파일을 겹쳐 쓰는 것을 방지하기 위해 입력 파일을 분리할 필요가 있습니다. 만약 출력 파일이 특정 디렉터리에 위치해야 하는 경우, 그 위치가 출력 디렉터리가 되어야 합니다.</p> <p>또한 JavaScript에서 번들링을 하거나 바벨 같은 트랜스파일러를 사용하는 것처럼, 중간 단계를 실행할 수 있습니다. 이러한 경우, 이렇게 설정된 폴더 구조를 가지고 있을 수 있습니다.</p> <p>이 시점부터, 디렉터리가 다음과 같이 설정되었다고 가정하겠습니다:</p> <pre data-language=\"text\">projectRoot\n├── src\n│   ├── file1.js\n│   └── file2.js\n├── built\n└── tsconfig.json</pre> <p>만약 <code>src</code> 디렉터리 바깥에 <code>tests</code> 폴더가 존재한다면, <code>src</code>와 <code>tests</code> 내부에 각각 <code>tsconfig.json</code>이 존재할 수 있습니다.</p> <h1 id=\"설정-파일-작성하기-writing-a-configuration-file\" style=\"position:relative;\">설정 파일 작성하기 (Writing a Configuration File)</h1> <p>TypeScript는 어떤 파일을 포함하고, 어떤 종류의 체크가 수행되어야 하는지와 같은 프로젝트 옵션을 관리하기 위해, <code>tsconfig.json</code>이라 불리는 파일을 사용합니다. 프로젝트의 뼈대를 구성해 보겠습니다:</p> <pre data-language=\"json\">{\n    \"compilerOptions\": {\n        \"outDir\": \"./built\",\n        \"allowJs\": true,\n        \"target\": \"es5\"\n    },\n    \"include\": [\n        \"./src/**/*\"\n    ]\n}</pre> <p>TypeScript에 대한 몇 가지 사항을 명시하고 있습니다:</p> <ol> <li>\n<code>src</code> 디렉터리에서 해석되는 모든 파일을 읽습니다 (<code>include</code> 포함).</li> <li>JavaScript 파일을 입력으로 허용합니다 (<code>allowJs</code> 포함).</li> <li>\n<code>built</code> 내부의 모든 출력 파일을 내보냅니다 (<code>outDir</code> 포함).</li> <li>최신 JavaScript 구성을 ECMAScript 5와 같은 이전 버전으로 변환합니다(<code>target</code> 사용).</li> </ol> <p>이 시점에서, 프로젝트의 루트에서 <code>tsc</code>를 작동시키려면, 반드시 <code>built</code> 디렉터리에 있는 출력 파일이 표시되어야 합니다. <code>built</code> 안의 레이아웃 파일은 <code>src</code>의 레이아웃과 동일해야 합니다. 이제 프로젝트가 TypeScript로 작동할 것입니다.</p> <h2 id=\"초기-혜택-early-benefits\" style=\"position:relative;\">초기 혜택 (Early Benefits)</h2> <p>TypeScript가 프로젝트를 이해하는 것으로부터 몇 가지 큰 혜택을 받을 수 있습니다. <a href=\"https://code.visualstudio.com\">VS Code</a> 나 <a href=\"https://visualstudio.com\">Visual Studio</a> 에디터를 열어보면, 자동완성과 같은 툴링 지원을 받는 것을 볼 수 있습니다. 또한 다음 옵션이 들어 있는 특정 버그도 잡을 수 있습니다:</p> <ul> <li>함수의 마지막에 return을 빠뜨리는 것을 방지하는 <code>noImplicitReturns</code>\n</li> <li>switch 블록의 <code>case</code> 사이에 <code>break</code>를 빠뜨리는 것을 절대 잊지 않기 위한 <code>noFallthroughCasesInSwitch</code>\n</li> </ul> <p>또한 <code>allowUnreachableCode</code> 와 <code>allowUnusedLabels</code> 각각을 사용해, TypeScript는 도달할 수 없는 코드와 라벨에 대한 경고를 할 것입니다.</p> <h1 id=\"빌드-툴과-통합하기-integrating-with-build-tools\" style=\"position:relative;\">빌드 툴과 통합하기 (Integrating with Build Tools)</h1> <p>파이프라인에 더 많은 제작 단계가 있을 수 있습니다. 각각의 파일에 무언가를 연결할 수도 있습니다. 개별 빌드 도구는 다르지만, 빌드 도구의 핵심을 다루기 위해 최선을 다할 것입니다.</p> <h2 id=\"gulp\" style=\"position:relative;\">Gulp</h2> <p>만약 Gulp를 어떤 방식으로 사용하고 있다면, TypeScript와 <a href=\"gulp.md\">Gulp를 사용하는 방법</a>과 Browserify, Babelify, Uglify 같은 일반적인 빌드 툴과 통합하는 방법에 대한 튜토리얼이 있습니다. 그곳에서 더 많은 내용을 볼 수 있습니다.</p> <h2 id=\"webpack\" style=\"position:relative;\">Webpack</h2> <p>Webpack 통합은 꽤 간단합니다. 쉬운 디버깅을 위해 <code>source-map-loader</code>와 결합한 TypeScript 로더, <code>awesome-typescript-loader</code>를 사용할 수 있습니다. 단순히 실행하고</p> <pre data-language=\"shell\">npm install awesome-typescript-loader source-map-loader</pre> <p>다음 옵션에서 <code>webpack.config.js</code> 파일과 병합하세요:</p> <pre data-language=\"js\">module.exports = {\n    entry: \"./src/index.ts\",\n    output: {\n        filename: \"./dist/bundle.js\",\n    },\n\n    // webpack의 출력을 디버깅하기 위해 소스맵을 활성화 합니다.\n    devtool: \"source-map\",\n\n    resolve: {\n        // 해석 가능한 확장자로 '.ts' 와 '.tsx' 를 추가합니다.\n        extensions: [\"\", \".webpack.js\", \".web.js\", \".ts\", \".tsx\", \".js\"]\n    },\n\n    module: {\n        loaders: [\n            // '.ts' 나 '.tsx' 확장자로 끝나는 모든 파일은 'awesome-typescript-loader'에 의해 처리됩니다.\n            { test: /\\.tsx?$/, loader: \"awesome-typescript-loader\" }\n        ],\n\n        preLoaders: [\n            // 모든 출력 '.js' 파일은 'source-map-loader'에 의해 재처리된 소스맵을 갖습니다.\n            { test: /\\.js$/, loader: \"source-map-loader\" }\n        ]\n    },\n\n    // 다른 옵션들...\n};</pre> <p>awesome-typescript-loader는 다른 로더가 <code>.js</code> 파일을 처리하기 전에 실행되어야 한다는 점을 유의하세요.</p> <p>Webpack을 위한 또 다른 TypeScript 로더, <a href=\"https://github.com/TypeStrong/ts-loader\">ts-loader</a>도 같습니다. <a href=\"https://github.com/s-panferov/awesome-typescript-loader#differences-between-ts-loader\">여기</a>에서 둘 사이의 차이점을 읽을 수 있습니다.</p> <p><a href=\"react-&amp;-webpack.md\">React와 Webpack 튜토리얼</a>에서 Webpack 사용에 관한 예제를 볼 수 있습니다.</p> <h1 id=\"typescript-파일로-이동하기-moving-to-typescript-files\" style=\"position:relative;\">TypeScript 파일로 이동하기 (Moving to TypeScript Files)</h1> <p>이제, TypeScript 파일을 사용해 시작할 준비가 되었을 것입니다. 첫 번째 단계는 <code>.js</code> 파일을 <code>.ts</code> 파일로 이름을 바꾸는 것입니다. 파일이 JSX를 사용한다면 이름을 <code>.tsx</code>로 변경하세요.</p> <p>그 단계를 마치셨나요? 좋습니다! JavaScript에서 TypeScript로 파일을 성공적으로 마이그레이션 했습니다!</p> <p>당연히, 그것이 바로 느껴지지는 않을 것입니다. TypeScript를 지원하는 에디터로 파일을 열어보면 (또는 <code>tsc --pretty</code>를 실행하면), 특정 줄에 빨간 구불구불한 선이 나타날 것입니다. Microsoft Word 같은 에디터의 빨간 구불구불한 선처럼 생각하면 됩니다. Word가 문서를 여전히 프린트할 수 있는 것처럼, TypeScript도 여전히 코드를 해석할 수 있습니다.</p> <p>만약 그것이 너무 느슨해 보인다면, 더 엄격하게 행동할 수 있습니다. 예를 들어, 오류 발생 시 JavaScript를 TypeScript로 컴파일 <em>하지 않으려면</em>, <code>noEmitOnError</code> 옵션을 사용할 수 있습니다. 그러한 의미에서, TypeScript는 이상적인 엄격함을 갖고 있고, 원하는 만큼 그 기준을 높일 수 있습니다.</p> <p>최대한 엄격한 세팅을 사용할 계획이라면, 지금 설정하는 것이 좋습니다(<a href=\"#%EB%8D%94-%EC%97%84%EA%B2%A9%ED%95%9C-%EC%B2%B4%ED%81%AC%ED%95%98%EA%B8%B0-getting-stricter-checks\">더 엄격한 체크하기</a> 참조). 예를 들어, TypeScript가 명시적 설명 없이는 타입을 <code>any</code>로 추론하지 않기를 원한다면, 파일을 수정하기 전 <code>noImplicitAny</code>를 사용할 수 있습니다. 다소 부담스럽게 느껴질 수 있지만, 장기적으로 훨씬 이득입니다.</p> <h2 id=\"오류-제거하기-weeding-out-errors\" style=\"position:relative;\">오류 제거하기 (Weeding out Errors)</h2> <p>언급했던 것처럼, 전환 후 에러 메시지가 뜨는 것은 예상하지 못했습니다. 중요한 점은 실제로 하나하나의 오류를 어떻게 처리할 것인지 결정하는 것입니다. 종종 이것이 합법적인 버그가 될 수 있지만, 때때로 TypeScript에게 무엇을 더 잘하려고 하는지 설명해야 합니다.</p> <h3 id=\"모듈로부터-import-하기-importing-from-modules\" style=\"position:relative;\">모듈로부터 import 하기 (Importing from Modules)</h3> <p>시작할 때 <code>Cannot find name 'require'.</code>, and <code>Cannot find name 'define'.</code> 같은 에러가 많이 나타날 수 있습니다. 이러한 경우, 모듈을 사용할 수 있습니다. 아래의 선언을 통해 TypeScript에게 이러한 기능이 존재한다고 납득시킬 수 있지만</p> <pre data-language=\"ts\">// For Node/CommonJS\ndeclare function require(path: string): any;</pre> <p>또는</p> <pre data-language=\"ts\">// For RequireJS/AMD\ndeclare function define(...args: any[]): any;</pre> <p>이러한 호출을 제거하고 import를 위한 TypeScript 구문을 사용하는 것이 더 낫습니다.</p> <p>먼저, TypeScript <code>module</code> 플래그를 설정함으로써 모듈 시스템을 활성화해야 합니다. 유효한 옵션은 <code>commonjs</code>, <code>amd</code>, <code>system</code>, 그리고 <code>umd</code>입니다.</p> <p>만약 다음과 같은 Node/CommonJS 코드를 갖고 있다면:</p> <pre data-language=\"js\">var foo = require(\"foo\");\n\nfoo.doStuff();</pre> <p>또는 다음의 RequireJS/AMD 코드를 갖고 있다면:</p> <pre data-language=\"js\">define([\"foo\"], function(foo) {\n    foo.doStuff();\n})</pre> <p>그러면 다음의 TypeScript 코드를 작성해야 합니다:</p> <pre data-language=\"ts\">import foo = require(\"foo\");\n\nfoo.doStuff();</pre> <h3 id=\"선언-파일-시작하기-getting-declaration-files\" style=\"position:relative;\">선언 파일 시작하기 (Getting Declaration Files)</h3> <p>만약 TypeScript import로 전환을 시작했다면, <code>Cannot find module 'foo'.</code> 같은 오류가 발생할 수 있습니다. 여기서 문제는 라이브러리를 설명하는 <em>선언 파일</em>이 없을 가능성이 높다는 것입니다. 다행히 해결 방법은 꽤 쉽습니다. 만약 TypeScript가 <code>lodash</code> 같은 패키지에 대해 경고를 발생시키면, 그냥 작성하면 됩니다</p> <pre data-language=\"shell\">npm install -S @types/lodash</pre> <p><code>commonjs</code> 말고 다른 모듈 옵션을 사용한다면, <code>moduleResolution</code>을 <code>node</code>로 설정해야 합니다.</p> <p>그 후, lodash를 문제없이 import 할 수 있고, 정확하게 완성할 수 있습니다.</p> <h3 id=\"모듈-export-하기-exporting-from-modules\" style=\"position:relative;\">모듈 export 하기 (Exporting from Modules)</h3> <p>전형적으로, 모듈을 export 하는 것은<code>exports</code> 혹은 <code>module.exports</code> 같은 값을 프로퍼티에 추가하는 것을 포함합니다. TypeScript는 최상위-레벨의 export 문을 허용합니다. 예를 들어, 함수를 이렇게 export 했다면:</p> <pre data-language=\"js\">module.exports.feedPets = function(pets) {\n    // ...\n}</pre> <p>그것을 다음과 같이 작성할 수 있습니다:</p> <pre data-language=\"ts\">export function feedPets(pets) {\n    // ...\n}</pre> <p>때로 exports 객체를 완전히 재작성할 수 있습니다. 아래 예제처럼 즉시 호출하기 위해 이러한 흔한 패턴을 사용합니다:</p> <pre data-language=\"js\">var express = require(\"express\");\nvar app = express();</pre> <p>전에는 이렇게 작성했을 수 있습니다:</p> <pre data-language=\"js\">function foo() {\n    // ...\n}\nmodule.exports = foo;</pre> <p>TypeScript에서, 이것을 <code>export =</code> 구문을 사용하여 모델링 할 수 있습니다.</p> <pre data-language=\"ts\">function foo() {\n    // ...\n}\nexport = foo;</pre> <h3 id=\"너무-많은너무-적은-인수-too-manytoo-few-arguments\" style=\"position:relative;\">너무 많은/너무 적은 인수 (Too many/too few arguments)</h3> <p>때로 너무 많은/너무 적은 인수를 갖고 있는 함수를 호출할 때가 있습니다. 전형적인 버그이지만, 그러나 몇몇 경우, 어떠한 매개변수를 쓰는 대신 <code>arguments</code> 객체를 사용하는 함수를 선언할 수 있습니다:</p> <pre data-language=\"js\">function myCoolFunction() {\n    if (arguments.length == 2 &amp;&amp; !Array.isArray(arguments[1])) {\n        var f = arguments[0];\n        var arr = arguments[1];\n        // ...\n    }\n    // ...\n}\n\nmyCoolFunction(function(x) { console.log(x) }, [1, 2, 3, 4]);\nmyCoolFunction(function(x) { console.log(x) }, 1, 2, 3, 4);</pre> <p>이 경우, TypeScript를 사용해서 호출자에게 함수 오버로드를 사용해 <code>myCoolFunction</code>이 호출되는 방법을 알려주어야 합니다.</p> <pre data-language=\"ts\">function myCoolFunction(f: (x: number) =&gt; void, nums: number[]): void;\nfunction myCoolFunction(f: (x: number) =&gt; void, ...nums: number[]): void;\nfunction myCoolFunction() {\n    if (arguments.length == 2 &amp;&amp; !Array.isArray(arguments[1])) {\n        var f = arguments[0];\n        var arr = arguments[1];\n        // ...\n    }\n    // ...\n}</pre> <p><code>myCoolFunction</code>에 오버로드 시그니처 두 개를 추가했습니다. 첫 번째 검사는 <code>myCoolFunction</code>이 (<code>number</code>를 인수로 갖는) 함수와 <code>number</code> 배열을 가진다는 것을 명시합니다. 두 번째 검사는 <code>myCoolFunction</code>이 마찬가지로 함수를 가지고, 나머지 연산자(<code>...nums</code>)를 사용하여 그 외의 인수는 몇개의 인수든 <code>number</code>가 되어야 함을 명시합니다.</p> <h3 id=\"순차적으로-추가된-프로퍼티-sequentially-added-properties\" style=\"position:relative;\">순차적으로 추가된 프로퍼티 (Sequentially Added Properties)</h3> <p>어떤 사람들은 객체를 생성하고 다음과 같이 동적으로 프로퍼티를 추가하는 것이 미관상 더 보기 좋다고 생각합니다:</p> <pre data-language=\"js\">var options = {};\noptions.color = \"red\";\noptions.volume = 11;</pre> <p>TypeScript는 <code>options</code>을 프로퍼티가 없는 <code>{}</code>로 인식했기 때문에 <code>color</code>와 <code>volume</code>을 할당할 수 없다고 할 것입니다. 만약 선언을 리터럴 객체로 변경하면, 오류가 발생하지 않습니다:</p> <pre data-language=\"ts\">let options = {\n    color: \"red\",\n    volume: 11\n};</pre> <p>또한 <code>options</code>의 타입을 정의해야 하고 객체 리터럴에 대한 타입 단언을 추가해야 합니다.</p> <pre data-language=\"ts\">interface Options { color: string; volume: number }\n\nlet options = {} as Options;\noptions.color = \"red\";\noptions.volume = 11;</pre> <p>대신, <code>options</code>이 단순히 타입<code>any</code>를 갖는다고 명시할 수 있는데, 이 방법은 가장 쉬운 방법이지만 가장 적은 장점을 가지고 있습니다.</p> <h3 id=\"any-object-and-\" style=\"position:relative;\">\n<code>any</code>, <code>Object</code>, and <code>{}</code>\n</h3> <p><code>Object</code>는 대부분의 경우 가장 일반적인 타입이므로, 값이 어떤 프로퍼티도 가질 수 있다고 말하기 위해 <code>Object</code> 나 <code>{}</code>를 사용하고 싶을 수 있습니다. 하지만 <code>any</code>가 가장 유연한 타입이므로, 이러한 경우에는 <strong>실제로 <code>any</code>가 가장 적절한 타입 입니다</strong>.</p> <p>예를 들어, <code>Object</code>를 타입으로 선언한 경우 <code>toLowerCase()</code>같은 메서드를 호출할 수 없습니다. 더 일반적으로 사용한다는 것은 타입으로 더 적은 일을 할 수 있다는 것을 의미하지만, <code>any</code>는 어떤 일이든 할 수 있게 하는 동시에 가장 일반적인 타입이라는 점에서 특별합니다. 그것은 <code>any</code>를 호출하고, 구성하고, 프로퍼티에 접근하는 등의 일을 할 수 있다는 것을 의미합니다. 그러나 <code>any</code>를 사용하면 TypeScript가 제공하는 대부분의 타입 검사와 에디터 지원을 받을 수 없다는 것을 명심하세요.</p> <p>만약 <code>Object</code>와 <code>{}</code>로 결정이 내려지면, <code>{}</code>를 선택해야 합니다. 이 둘은 거의 같지만, 특정 난해한 상황에서 기술적으로 <code>{}</code>이 <code>Object</code>보다 더 일반적인 타입입니다.</p> <h2 id=\"더-엄격한-체크하기-getting-stricter-checks\" style=\"position:relative;\">더 엄격한 체크하기 (Getting Stricter Checks)</h2> <p>TypeScript는 프로그램에 대한 안정성과 분석을 제공하는 특정한 검사를 갖고 있습니다. TypeScript로 코드베이스를 시작하면, 향상된 안전성을 위한 검사를 활성화할 수 있습니다.</p> <h3 id=\"암시적인-any는-피하기-no-implicit-any\" style=\"position:relative;\">암시적인 <code>any</code>는 피하기 (No Implicit <code>any</code>)</h3> <p>어떤 타입이어야 하는지 TypeScript가 파악할 수 없는 경우가 있습니다. 최대한 유연하게 대응하기 위해, 그 자리에 <code>any</code>를 사용하기로 결정할 것입니다. 이것은 마이그레이션에는 좋지만, <code>any</code>를 사용한다는 것은 다른 곳에서 받을 수 있는 어떠한 타입 안정성과 툴링 지원도 받지 못한다는 것을 의미합니다. TypeScript가 이런 부분에 플래그와 에러를 띄울 수 있도록 <code>noImplicitAny</code>옵션을 사용할 수 있습니다.</p> <h3 id=\"엄격한-null--undefined-검사-strict-null--undefined-checks\" style=\"position:relative;\">엄격한 <code>null</code> &amp; <code>undefined</code> 검사 (Strict <code>null</code> &amp; <code>undefined</code> Checks)</h3> <p>기본적으로, TypeScript는 <code>null</code> 과 <code>undefined</code>이 모든 타입의 도메인에 존재한다고 가정합니다. <code>number</code>로 선언된 타입이 <code>null</code> 혹은 <code>undefined</code>이 될 수 있다는 의미입니다. <code>null</code> 과 <code>undefined</code>는 JavaScript 와 TypeScript 에서 빈번한 버그 원인이기 때문에, TypeScript 에는 이러한 문제의 걱정을 덜어주는 <code>strictNullChecks</code> 옵션이 있습니다.</p> <p><code>strictNullChecks</code>가 활성화되면, <code>null</code>과 <code>undefined</code>는 각각 <code>null</code>과 <code>undefined</code>라는 자체 유형을 가져옵니다. 어떤 것이 <code>null</code>이 <em>될 가능성이 있는</em> 상황에서, 원래 타입과 함께 유니언 타입을 사용할 수 있습니다. 예를 들어, 만약 <code>number</code>나 <code>null</code>이 될수 있는 경우, <code>number | null</code>로 타입을 작성할 수 있습니다.</p> <p>TypeScript가 <code>null</code>/<code>undefined</code>라고 생각할 수 있는 값을 갖고 있지만, 타입에 대해 더 잘 알고 있는 경우, 후위 연산자 <code>!</code>를 사용해 다르게 사용할 수 있습니다.</p> <pre data-language=\"ts\">declare var foo: string[] | null;\n\nfoo.length;  // error - 'foo' is possibly 'null'\n\nfoo!.length; // okay - 'foo!' just has type 'string[]'</pre> <p>앞으로, <code>strictNullChecks</code>를 사용할 때, 의존성이 <code>strictNullChecks</code>를 사용하도록 업데이트 되어야 할 수 있습니다.</p> <h3 id=\"this에-대한-암시적-any-피하기-no-implicit-any-for-this\" style=\"position:relative;\">\n<code>this</code>에 대한 암시적 <code>any</code> 피하기 (No Implicit <code>any</code> for <code>this</code>)</h3> <p><code>this</code> 키워드를 클래스 밖에서 사용할 때, 기본적으로 <code>any</code> 타입을 가집니다. 예를 들어, <code>Point</code> 클래스를 상상해 보세요, 그리고 메서드로 추가하고 싶은 함수를 상상해보세요:</p> <pre data-language=\"ts\">class Point {\n    constructor(public x, public y) {}\n    getDistance(p: Point) {\n        let dx = p.x - this.x;\n        let dy = p.y - this.y;\n        return Math.sqrt(dx ** 2 + dy ** 2);\n    }\n}\n// ...\n\n// 인터페이스를 다시 열어보세요.\ninterface Point {\n    distanceFromOrigin(point: Point): number;\n}\nPoint.prototype.distanceFromOrigin = function(point: Point) {\n    return this.getDistance({ x: 0, y: 0});\n}</pre> <p>위에서 언급 한 것과 같은 문제가 있습니다 - <code>getDistance</code>의 철자를 틀리기 쉽고 에러가 발생하지 않았습니다. 이러한 이유 때문에, TypeScript 에 <code>noImplicitThis</code> 옵션이 있습니다. 이 옵션이 설정되면, TypeScript는 <code>this</code>가 명시적 타입 없이 사용될 때 에러를 발생시킵니다. 해결책은 인터페이스나 함수 자체에서 명시적 타입을 전달하기 위해 <code>this</code>-매개변수를 사용하는 것입니다:</p> <pre data-language=\"ts\">Point.prototype.distanceFromOrigin = function(this: Point, point: Point) {\n    return this.getDistance({ x: 0, y: 0});\n}</pre><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2012-2023 Microsoft<br>Licensed under the Apache License, Version 2.0.<br>\n    <a href=\"https://www.typescriptlang.org/ko/docs/handbook/migrating-from-javascript.html\" class=\"_attribution-link\">https://www.typescriptlang.org/ko/docs/handbook/migrating-from-javascript.html</a>\n  </p>\n</div>\n","declaration-files/deep-dive":"<h1>Deep Dive</h1>\n<h2 id=\"정의-파일-이론-심층-분석-definition-file-theory-a-deep-dive\" style=\"position:relative;\">정의 파일 이론: 심층 분석 (Definition File Theory: A Deep Dive)</h2> <p>원하는 API 형태를 제공하는 모듈을 만드는 것은 까다로울 수 있습니다. 예를 들어, <code>new</code>의 사용에 따라 호출할 때 다른 타입을 생성하는 모듈을 원할 수 있고, 계층에 노출 된 다양한 명명된 타입을 가지고 있으며, 모듈 객체에 대한 여러 프로퍼티도 가질 수 있습니다.</p> <p>이 가이드에서는, 익숙한 API를 노출하는 복잡한 정의 파일에 대해 작성하는 도구를 제공합니다. 또한 옵션이 다양하기 때문에 여기서는 모듈 (또는 UMD) 라이브러리에 중점을 둡니다.</p> <h2 id=\"주요-컨셉-key-concepts\" style=\"position:relative;\">주요 컨셉 (Key Concepts)</h2> <p>TypeScript 작동 방식에 대해 여러 주요 개념을 이해하여 정의의 형태를 만드는 방법을 완전히 이해할 수 있습니다.</p> <h3 id=\"타입-types\" style=\"position:relative;\">타입 (Types)</h3> <p>이 가이드를 읽고 있다면, 아마도 TypeScript의 타입에 대해 이미 알고 있을 것입니다. 보다 명확하게하기 위해, 다음과 같이 <em>타입</em>이 도입됩니다:</p> <ul> <li>타입 별칭 선언 (<code>type sn = number | string;</code>)</li> <li>인터페이스 선언 (<code>interface I { x: number[]; }</code>)</li> <li>클래스 선언 (<code>class C { }</code>)</li> <li>열거형 선언 (<code>enum E { A, B, C }</code>)</li> <li>타입을 가리키는 <code>import</code> 선언</li> </ul> <p>이러한 각 선언 형태는 새로운 타입 이름을 만듭니다.</p> <h3 id=\"값-values\" style=\"position:relative;\">값 (Values)</h3> <p>타입과 마찬가지로 값이 무엇인지 이미 알고 있을 것입니다. 값은 표현식에서 참조할 수 있는 런타임 이름입니다. 예를 들어 <code>let x = 5;</code>에서는 <code>x</code>라고 불리는 값을 생성합니다.</p> <p>다시 명확하게 말하자면, 다음과 같이 값을 만듭니다:</p> <ul> <li>\n<code>let</code>, <code>const</code>, 그리고 <code>var</code> 선언</li> <li>값을 포함하는 <code>네임스페이스</code> 또는 <code>모듈</code> 선언</li> <li>\n<code>열거형</code> 선언</li> <li>\n<code>클래스</code> 선언</li> <li>값을 참조하는 <code>import</code> 선언</li> <li>\n<code>함수</code> 선언</li> </ul> <h3 id=\"네임스페이스-namespaces\" style=\"position:relative;\">네임스페이스 (Namespaces)</h3> <p>타입은 <em>네임스페이스</em> 안에 존재할 수 있습니다. 예를 들어, <code>let x: A.B.C</code> 이란 선언이 있다면, 타입 <code>C</code>는 <code>A.B</code> 네임스페이스에서 온 것 입니다.</p> <p>이 구별은 미묘하지만 중요합니다 — 여기서 <code>A.B</code>는 타입이거나 값일 필요는 없습니다.</p> <h2 id=\"간단한-조합-하나의-이름-여러-의미-simple-combinations-one-name-multiple-meanings\" style=\"position:relative;\">간단한 조합: 하나의 이름, 여러 의미 (Simple Combinations: One name, multiple meanings)</h2> <p><code>A</code>라는 이름이 있으면, <code>A</code>에 대해 타입, 값 또는 네임스페이스라는 세 가지 다른 의미를 찾을 수 있습니다. 이름을 해석하는 방법은 사용하는 컨텍스트에 따라 다릅니다. 예를 들어 <code>let m: A.A = A;</code> 선언에서, <code>A</code>는 먼저 네임스페이스로 사용 된 다음, 타입의 이름으로, 그 다음 값으로 사용됩니다. 즉 완전히 다른 선언을 의미할 수 있습니다!</p> <p>약간은 혼란스러워 보이지만, 과하게 사용하지 않는 한 실제로 매우 편리합니다. 결합 동작의 유용한 측면을 살펴 보겠습니다.</p> <h3 id=\"내부-조합-built-in-combinations\" style=\"position:relative;\">내부 조합 (Built-in Combinations)</h3> <p>영리한 사람이라면, <em>타입</em>과 <em>값</em> 목록에서 <code>클래스</code>가 둘 다 나온 것을 눈치챘을 것입니다. <code>class C { }</code> 선언은 두 가지를 만듭니다: 클래스 인스턴스의 형태를 나타내는 <em>타입</em> <code>C</code>와 클래스 생성자를 나타내는 <em>값</em> <code>C</code> 입니다. 열거형 선언도 비슷하게 동작합니다.</p> <h3 id=\"사용자-조합-user-combinations\" style=\"position:relative;\">사용자 조합 (User Combinations)</h3> <p>모듈 파일 <code>foo.d.ts</code>을 작성했습니다:</p> <pre data-language=\"ts\">export var SomeVar: { a: SomeType };\nexport interface SomeType {\n  count: number;\n}</pre> <p>그 다음 사용했습니다:</p> <pre data-language=\"ts\">import * as foo from './foo';\nlet x: foo.SomeType = foo.SomeVar.a;\nconsole.log(x.count);</pre> <p>잘 작동하지만, <code>SomeType</code>과 <code>SomeVar</code>는 이름이 같도록 밀접하게 관련되어 있다고 상상할 수 있습니다. 결합을 사용하여 같은 이름 <code>Bar</code>로 두 가지 다른 객체 (값과 타입)를 표시 할 수 있습니다:</p> <pre data-language=\"ts\">export var Bar: { a: Bar };\nexport interface Bar {\n  count: number;\n}</pre> <p>이 경우 사용하는 코드를 구조 분해할 수 있는 아주 좋은 기회입니다:</p> <pre data-language=\"ts\">import { Bar } from './foo';\nlet x: Bar = Bar.a;\nconsole.log(x.count);</pre> <p>여기서도 <code>Bar</code>를 타입과 값으로 사용했습니다. <code>Bar</code> 값을 <code>Bar</code> 타입으로 선언할 필요가 없다는 점을 유의하세요 — 저 둘은 독립적입니다.</p> <h2 id=\"고급-결합-advanced-combinations\" style=\"position:relative;\">고급 결합 (Advanced Combinations)</h2> <p>선언은 여러 개의 선언에 걸쳐 결합될 수 있습니다. 예를 들어, <code>class C { }</code>와 <code>interface C { }</code> 같이 결합할 수 있으며 둘 다 <code>C</code> 타입에 프로퍼티를 추가합니다.</p> <p>충돌을 일으키지 않는다면 충분히 합법적입니다. 일반적인 경험 법칙은 값의 이름이 <code>네임스페이스</code>로 선언되지 않는 한 항상 같은 이름의 다른 값과 충돌하고, 타입 별칭 선언(<code>type s = string</code>)으로 선언 된 경우 타입이 충돌하며, 네임스페이스와는 절대로 충돌하지 않는 것입니다.</p> <p>어떻게 사용되는지 살펴보겠습니다.</p> <h3 id=\"인터페이스를-사용하여-추가하기-adding-using-an-interface\" style=\"position:relative;\">\n<code>인터페이스</code>를 사용하여 추가하기 (Adding using an <code>interface</code>)</h3> <p><code>인터페이스</code>에 다른 <code>인터페이스</code> 선언을 사용하여 멤버를 추가할 수 있습니다:</p> <pre data-language=\"ts\">interface Foo {\n  x: number;\n}\n// ... 다른 위치 ...\ninterface Foo {\n  y: number;\n}\nlet a: Foo = ...;\nconsole.log(a.x + a.y); // 성공</pre> <p>클래스와도 같이 동작합니다:</p> <pre data-language=\"ts\">class Foo {\n  x: number;\n}\n// ... 다른 위치 ...\ninterface Foo {\n  y: number;\n}\nlet a: Foo = ...;\nconsole.log(a.x + a.y); // 성공</pre> <p>단, 타입 별칭 (<code>type s = string;</code>)에는 인터페이스를 사용해서 추가할 수 없습니다.</p> <h3 id=\"네임스페이스를-사용하여-추가하기-adding-using-a-namespace\" style=\"position:relative;\">\n<code>네임스페이스</code>를 사용하여 추가하기 (Adding using a <code>namespace</code>)</h3> <p><code>네임스페이스</code> 선언은 충돌을 일으키지 않는 방식으로 새로운 타입, 값 그리고 네임스페이스를 추가할 수 있습니다.</p> <p>예를 들어, 클래스에 정적 멤버를 추가할 수 있습니다:</p> <pre data-language=\"ts\">class C {\n}\n// ... 다른 위치 ...\nnamespace C {\n  export let x: number;\n}\nlet y = C.x; // 성공</pre> <p>위 예제에서 <code>C</code>의 <em>정적</em> 측면(생성자 함수)에 값을 추가했습니다. <em>값</em>을 추가 했고 모든 값에 대한 컨테이너가 다르기 때문입니다. (타입은 네임스페이스에 포함되고 네임스페이스는 다른 네임스페이스에 포함됩니다).</p> <p>네임스페이스 타입을 클래스에 추가할 수 있습니다:</p> <pre data-language=\"ts\">class C {\n}\n// ... 다른 위치 ...\nnamespace C {\n  export interface D { }\n}\nlet y: C.D; // 성공</pre> <p>이 예제에서 <code>namespace</code> 선언을 작성할 때까지 네임스페이스 <code>C</code>는 없었습니다. 네임스페이스 <code>C</code>는 클래스에 의해 생성된 <code>C</code>의 값 또는 타입과 충돌하지 않습니다.</p> <p>마지막으로 <code>namespace</code> 선언을 사용하여 다양한 병합을 할 수 있습니다. 특히 현실적인 예는 아니지만, 흥미로운 동작을 확인할 수 있습니다:</p> <pre data-language=\"ts\">namespace X {\n  export interface Y { }\n  export class Z { }\n}\n\n// ... 다른 위치 ...\nnamespace X {\n  export var Y: number;\n  export namespace Z {\n    export class C { }\n  }\n}\ntype X = string;</pre> <p>위 예제에서 첫 번째 블록은 다음 이름의 의미를 만듭니다:</p> <ul> <li>값 <code>X</code> (<code>네임스페이스</code> 선언은 값 <code>Z</code>를 포함하기 때문입니다)</li> <li>네임스페이스 <code>X</code> (<code>네임스페이스</code> 선언은 타입 <code>Y</code>를 포함하기 때문입니다)</li> <li>\n<code>X</code> 네임스페이스 안의 타입 <code>Y</code>\n</li> <li>\n<code>X</code> 네임스페이스 안의 타입 <code>Z</code> (클래스의 인스턴스 형태)</li> <li>\n<code>X</code> 값의 프로퍼티인 값 <code>Z</code> (클래스의 생성자 함수)</li> </ul> <p>두 번째 블록은 다음 이름의 의미를 만듭니다:</p> <ul> <li>\n<code>X</code> 값의 프로퍼티인 값 <code>Y</code> (<code>number</code> 타입)</li> <li>네임스페이스 <code>Z</code>\n</li> <li>\n<code>X</code> 값의 프로퍼티인 값 <code>Z</code>\n</li> <li>\n<code>X.Z</code> 네임스페이스 안의 타입 <code>C</code>\n</li> <li>\n<code>X.Z</code> 값의 프로퍼티인 값 <code>C</code>\n</li> <li>타입 <code>X</code>\n</li> </ul> <h2 id=\"export--or-import-사용하기-using-with-export--or-import\" style=\"position:relative;\">\n<code>export =</code> or <code>import</code> 사용하기 (Using with <code>export =</code> or <code>import</code>)</h2> <p>중요한 규칙은 <code>export</code>와 <code>import</code> 선언이 대상의 <em>모든 의미</em> 를 내보내거나 가져온다는 것 입니다.</p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2012-2023 Microsoft<br>Licensed under the Apache License, Version 2.0.<br>\n    <a href=\"https://www.typescriptlang.org/ko/docs/handbook/declaration-files/deep-dive.html\" class=\"_attribution-link\">https://www.typescriptlang.org/ko/docs/handbook/declaration-files/deep-dive.html</a>\n  </p>\n</div>\n","declaration-files/publishing":"<h1>Publishing</h1>\n<p>이 가이드를 따라 선언 파일을 작성했으므로, 이제 npm에 배포할 시간입니다. npm에 선언 파일을 배포하는 방법은 크게 두 가지가 있습니다:</p> <ol> <li>npm 패키지로 번들링하거나</li> <li>npm의 <a href=\"https://www.npmjs.com/~types\">@types organization</a>에 배포하기</li> </ol> <p>만약 패키지가 TypeScript로 작성되었다면 첫 번째 방법을 사용하는 것이 좋습니다. <code>--declaration</code> 플래그를 사용하여 선언 파일을 생성하세요. 이 방법을 사용하면, 선언과 JavaScript가 항상 일치하게 됩니다.</p> <p>만약 패키지가 TypeScript로 작성되지 않았다면 두 번째 방법을 사용하는 것이 좋습니다.</p> <h1 id=\"npm-패키지에-선언-포함하기-including-declarations-in-your-npm-package\" style=\"position:relative;\">npm 패키지에 선언 포함하기 (Including declarations in your npm package)</h1> <p>만약 패키지가 메인 <code>.js</code> 파일을 가지고 있다면, 메인 선언 파일을 <code>package.json</code>에도 표시해야 합니다. 번들링된 선언 파일을 <code>types</code> 프로퍼티로 가리키도록 하세요. 예를 들어:</p> <pre data-language=\"json\">{\n    \"name\": \"awesome\",\n    \"author\": \"Vandelay Industries\",\n    \"version\": \"1.0.0\",\n    \"main\": \"./lib/main.js\",\n    \"types\": \"./lib/main.d.ts\"\n}</pre> <p><code>\"typings\"</code> 필드는 <code>\"types\"</code>와 동의어이기 때문에 역시 사용할 수 있습니다.</p> <p>또한 <code>package.json</code>이 <code>\"files\"</code> 프로퍼티를 포함하고 있으면 <code>\"types\"</code> 프로퍼티는 무시됩니다. 이 경우 메인 선언 파일을 <code>\"files\"</code> 프로퍼티에 전달해야 합니다.</p> <p>만약 메인 선언 파일 이름이 <code>index.d.ts</code>이고 패키지의 루트에 있으면 (<code>index.js</code> 옆에) <code>\"types\"</code> 프로퍼티를 쓰지 않아도 되지만, 쓰는 것이 좋습니다.</p> <h2 id=\"의존성-dependencies\" style=\"position:relative;\">의존성 (Dependencies)</h2> <p>모든 의존성은 npm으로 관리됩니다. 의존성이 있는 모든 선언 패키지가 <code>package.json</code>에 <code>\"dependencies\"</code> 섹션 안에 알맞게 작성되어 있는지 확인하세요. 예를 들어, Browserify와 TypeScript로 작성된 패키지를 생각해봅시다.</p> <pre data-language=\"json\">{\n    \"name\": \"browserify-typescript-extension\",\n    \"author\": \"Vandelay Industries\",\n    \"version\": \"1.0.0\",\n    \"main\": \"./lib/main.js\",\n    \"types\": \"./lib/main.d.ts\",\n    \"dependencies\": {\n        \"browserify\": \"latest\",\n        \"@types/browserify\": \"latest\",\n        \"typescript\": \"next\"\n    }\n}</pre> <p>여기에서, 패키지는 <code>browserify</code>와 <code>typescript</code> 패키지에 의존성이 있습니다. <code>browserify</code>는 선언 파일이 npm 패키지에 함께 번들링 되지 않기 때문에, <code>@types/browserify</code> 선언을 의존성에 추가해야 합니다. 반면에 <code>typescript</code>는 선언 파일이 패키징되기 때문에, 별도의 의존성을 추가할 필요가 없습니다.</p> <p>이 패키지는 <code>browserify</code>와 <code>typescript</code> 패키지의 각 선언을 노출하기 때문에, <code>browserify-typescript-extension</code> 패키지는 이 의존성들을 가져야 합니다. 이 이유로, <code>\"devDependencies\"</code>가 아니라 <code>\"dependencies\"</code>를 사용합니다. 왜냐하면 <code>\"devDependencies\"</code>를 사용하면 사용자가 직접 이 패키지들을 설치해야 하기 때문입니다. 만약에 단지 명령줄 애플리케이션을 작성했고 패키지를 라이브러리로 사용하길 기대하지 않는다면, <code>devDependencies</code>를 사용해도 됩니다.</p> <h2 id=\"경고-플래그-red-flags\" style=\"position:relative;\">경고 플래그 (Red flags)</h2> <h3 id=\"-reference-path-\" style=\"position:relative;\"><code>/// &lt;reference path=\"...\" /&gt;</code></h3> <p>선언 파일에 <code>/// &lt;reference path=\"...\" /&gt;</code>를 사용하지 <em>마세요</em>.</p> <pre data-language=\"ts\">/// &lt;reference path=\"../typescript/lib/typescriptServices.d.ts\" /&gt;\n....</pre> <p>대신 <code>/// &lt;reference types=\"...\" /&gt;</code>를 사용<em>하세요</em>.</p> <pre data-language=\"ts\">/// &lt;reference types=\"typescript\" /&gt;\n....</pre> <p>더 자세한 내용을 위해 <a href=\"library-structures.md#consuming-dependencies\">의존성 사용하기</a> 섹션을 다시 보십시오.</p> <h3 id=\"의존적인-선언-패키징하기-packaging-dependent-declarations\" style=\"position:relative;\">의존적인 선언 패키징하기 (Packaging dependent declarations)</h3> <p>만약 타입 정의가 다른 패키지에 의존적이라면:</p> <ul> <li>각 파일은 유지하고 다른 패키지와 합치지 <em>마세요</em>.</li> <li>또한 작성한 패키지에 선언을 복사하지 <em>마세요</em>.</li> <li>만약 npm 타입 선언 패키지가 선언 파일을 패키징하지 않는다면, 해당 패키지에 의존<em>하세요</em>.</li> </ul> <h2 id=\"version-selection-with-typesversions\" style=\"position:relative;\">Version selection with <code>typesVersions</code>\n</h2> <p>When TypeScript opens a <code>package.json</code> file to figure out which files it needs to read, it first looks at a new field called <code>typesVersions</code>.</p> <p>A <code>package.json</code> with a <code>typesVersions</code> field might look like this:</p> <pre data-language=\"json\">{\n  \"name\": \"package-name\",\n  \"version\": \"1.0\",\n  \"types\": \"./index.d.ts\",\n  \"typesVersions\": {\n    \"&gt;=3.1\": { \"*\": [\"ts3.1/*\"] }\n  }\n}</pre> <p>This <code>package.json</code> tells TypeScript to check whether the current version of TypeScript is running. If it’s 3.1 or later, it figures out the path you’ve imported relative to the package, and reads from the package’s <code>ts3.1</code> folder. That’s what that <code>{ \"*\": [\"ts3.1/*\"] }</code> means - if you’re familiar with path mapping today, it works exactly like that.</p> <p>In the above example, if we’re importing from <code>\"package-name\"</code>, TypeScript will try to resolve from <code>[...]/node_modules/package-name/ts3.1/index.d.ts</code> (and other relevant paths) when running in TypeScript 3.1. If we import from <code>package-name/foo</code>, we’ll try to look for <code>[...]/node_modules/package-name/ts3.1/foo.d.ts</code> and <code>[...]/node_modules/package-name/ts3.1/foo/index.d.ts</code>.</p> <p>What if we’re not running in TypeScript 3.1 in this example? Well, if none of the fields in <code>typesVersions</code> get matched, TypeScript falls back to the <code>types</code> field, so here TypeScript 3.0 and earlier will be redirected to <code>[...]/node_modules/package-name/index.d.ts</code>.</p> <h2 id=\"matching-behavior\" style=\"position:relative;\">Matching behavior</h2> <p>The way that TypeScript decides on whether a version of the compiler &amp; language matches is by using Node’s <a href=\"https://github.com/npm/node-semver#ranges\">semver ranges</a>.</p> <h2 id=\"multiple-fields\" style=\"position:relative;\">Multiple fields</h2> <p><code>typesVersions</code> can support multiple fields where each field name is specified by the range to match on.</p> <pre tsconfig=\"true\" data-language=\"typescript\">{\n  \"name\": \"package-name\",\n  \"version\": \"1.0\",\n  \"types\": \"./index.d.ts\",\n  \"typesVersions\": {\n    \"&gt;=3.2\": { \"*\": [\"ts3.2/*\"] },\n    \"&gt;=3.1\": { \"*\": [\"ts3.1/*\"] }\n  }\n}</pre> <p>Since ranges have the potential to overlap, determining which redirect applies is order-specific. That means in the above example, even though both the <code>&gt;=3.2</code> and the <code>&gt;=3.1</code> matchers support TypeScript 3.2 and above, reversing the order could have different behavior, so the above sample would not be equivalent to the following.</p> <pre tsconfig=\"true\" data-language=\"typescript\">{\n  \"name\": \"package-name\",\n  \"version\": \"1.0\",\n  \"types\": \"./index.d.ts\",\n  \"typesVersions\": {\n    // NOTE: this doesn't work!\n    \"&gt;=3.1\": { \"*\": [\"ts3.1/*\"] },\n    \"&gt;=3.2\": { \"*\": [\"ts3.2/*\"] }\n  }\n}</pre> <h1 id=\"types에-배포하기-publish-to-types\" style=\"position:relative;\">\n<a href=\"https://www.npmjs.com/~types\">@types</a>에 배포하기 (Publish to <a href=\"https://www.npmjs.com/~types\">@types</a>)</h1> <p><a href=\"https://www.npmjs.com/~types\">@types</a>안에 있는 패키지들은 <a href=\"https://github.com/Microsoft/types-publisher\">타입-배포 도구</a>를 사용하여 <a href=\"https://github.com/DefinitelyTyped/DefinitelyTyped\">DefinitelyTyped</a>에서 자동으로 배포되었습니다. 선언을 @types 패키지로 배포하려면, <a href=\"https://github.com/DefinitelyTyped/DefinitelyTyped\">https://github.com/DefinitelyTyped/DefinitelyTyped</a>에 pull request를 제출하세요. <a href=\"http://definitelytyped.org/guides/contributing.html\">기여 지침 페이지</a>에서 더 자세한 내용을 찾을 수 있습니다.</p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2012-2023 Microsoft<br>Licensed under the Apache License, Version 2.0.<br>\n    <a href=\"https://www.typescriptlang.org/ko/docs/handbook/declaration-files/publishing.html\" class=\"_attribution-link\">https://www.typescriptlang.org/ko/docs/handbook/declaration-files/publishing.html</a>\n  </p>\n</div>\n","babel-with-typescript":"<h1>Using Babel with TypeScript</h1>\n<h2 id=\"babel-vs-typescript의-tsc\" style=\"position:relative;\">Babel vs TypeScript의 <code>tsc</code>\n</h2> <p>모던 JavaScript 프로젝트를 만들 때, TypeScript에서 JavaScript 파일로 변환하는 올바른 방법에 대해 고민할 수 있습니다.</p> <p>많은 경우 그 대답은 프로젝트에 따라 <em>“~에 달려있다”</em> 또는 <em>“누군가 여러분 대신 결정했을지도 모른다`</em> 가 될 것입니다. 만약 <a href=\"https://www.npmjs.com/package/tsdx\">tsdx</a>, <a href=\"https://angular.io/\">Angular</a>, <a href=\"https://nestjs.com/\">NestJS</a>와 같은 기존 프레임워크 또는 <a href=\"https://www.typescriptlang.org/docs/home\">Getting Started</a>에 언급된 프레임워크를 사용하여 프로젝트를 만들고 있다면 이 결정은 여러분을 위해 자동으로 처리됩니다.</p> <p>하지만, 사용할만한 직관적인 방법은 다음과 같습니다:</p> <ul> <li>빌드 출력 결과와 소스 입력 파일이 거의 비슷한가요? <code>tsc</code>를 사용하세요.</li> <li>여러 잠재적인 결과물을 내는 빌드 파이프라인이 필요하신가요? <code>babel</code>로 트랜스파일링을 하고, <code>tsc</code>로 타입을 검사하세요.</li> </ul> <h2 id=\"트랜스파일링은-babel-타입은-tsc\" style=\"position:relative;\">트랜스파일링은 Babel, 타입은 <code>tsc</code>\n</h2> <p>JavaScript 코드 베이스에서 TypeScript로 포팅되었을 수 있는 기존 빌드 인프라 구조를 가진 프로젝트의 일반적인 패턴입니다.</p> <p>이 기술은, Babel의 <a href=\"https://babeljs.io/docs/en/babel-preset-typescript\">preset-typescript</a>을 사용하여 JS 파일을 생성한 후, TypeScript를 사용하여 타입 검사 및 <code>.d.ts</code> 파일을 생성하는 복합 접근 방식입니다.</p> <p>Babel은 TypeScript를 지원하기 때문에, 기존 빌드 파이프라인으로 작업할 수 있고 Babel이 코드 타입을 검사하지 않기 때문에 JS 출력 시간이 더 빨라질 수 있습니다.</p> <h4 id=\"타입-검사와-dts-파일-생성\" style=\"position:relative;\">타입 검사와 d.ts 파일 생성</h4> <p>Babel 사용의 단점은 TS를 JS로 전환하는 동안 타입 검사를 할 수 없다는 점입니다. 즉, 에디터에서 잡지 못한 타입 오류가 프로덕션 코드에 포함될 수도 있다는 뜻입니다.</p> <p>또한, Babel은 TypeScript에 대한 <code>.d.ts</code> 파일을 만들 수 없기 때문에 여러분의 프로젝트가 라이브러리인 경우 작업하기가 더 어려워질 수 있습니다.</p> <p>이러한 문제를 해결하려면 TSC를 사용하여 프로젝트의 타입을 검사할 수 있는 명령어를 설정하는 것이 좋습니다. 이는 Babel 구성의 일부를 해당 <a href=\"https://www.typescriptlang.org/tconfig\"><code>tsconfig.json</code></a>에 복제하고, 다음 플래그가 활성화되었는지 확인하는 것을 의미합니다:</p> <pre tsconfig=\"true\" data-language=\"typescript\">\"compilerOptions\": {\n  // tsc를 사용해 .js 파일이 아닌 .d.ts 파일이 생성되었는지 확인합니다.\n  \"declaration\": true,\n  \"emitDeclarationOnly\": true,\n  // Babel이 TypeScript 프로젝트의 파일을 안전하게 트랜스파일할 수 있는지 확인합니다.\n  \"isolatedModules\": true\n}</pre> <p>해당 플래그에 대한 자세한 내용은 다음을 참고해주세요:</p> <ul> <li><a href=\"https://www.typescriptlang.org/tsconfig#isolatedModules\"><code>isolatedModules</code></a></li> <li>\n<a href=\"https://www.typescriptlang.org/tsconfig#declaration\"><code>declaration</code></a>, <a href=\"https://www.typescriptlang.org/tsconfig#emitDeclarationOnly\"><code>emitDeclarationOnly</code></a>\n</li> </ul><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2012-2023 Microsoft<br>Licensed under the Apache License, Version 2.0.<br>\n    <a href=\"https://www.typescriptlang.org/ko/docs/handbook/babel-with-typescript.html\" class=\"_attribution-link\">https://www.typescriptlang.org/ko/docs/handbook/babel-with-typescript.html</a>\n  </p>\n</div>\n","declaration-files/consumption":"<h1>Consumption</h1>\n<p>TypeScript 2.0에서는 선언 파일을 얻고, 사용하고, 찾는 것이 훨씬 쉬워졌습니다. 이 페이지에서 세 가지를 어떻게 하는지 정확하게 설명합니다.</p> <h2 id=\"다운로드-downloading\" style=\"position:relative;\">다운로드 (Downloading)</h2> <p>TypeScript 2.0 이상에서 타입 선언을 가져오는데 npm 이외의 도구는 필요하지 않습니다.</p> <p>예를 들어, lodash와 같은 라이브러리에 대한 선언을 얻는 것은 다음 명령어로 충분합니다.</p> <pre data-language=\"shell\">npm install --save @types/lodash</pre> <p><a href=\"https://www.typescriptlang.org/docs/handbook/declaration-files/publishing.html\">Publishing</a>에서 설명한 대로 npm 패키지에 이미 선언 파일이 포함되어 있다면, <code>@types</code> 패키지를 설치할 필요는 없다는 걸 유의하세요.</p> <h2 id=\"사용하기-consuming\" style=\"position:relative;\">사용하기 (Consuming)</h2> <p>TypeScript 코드에 별 어려움 없이 lodash를 사용할 수 있습니다. 이는 모듈 및 전역 코드에 모두 적용됩니다.</p> <p>예를 들어, 타입 선언에 대해 <code>npm install</code>을 한 번만 수행하면, import 하고 사용할 수 있고</p> <pre data-language=\"ts\">import * as _ from \"lodash\";\n_.padStart(\"Hello TypeScript!\", 20, \" \");</pre> <p>또는 모듈을 사용하지 않는다면, 전역 변수 <code>_</code> 를 사용할 수 있습니다.</p> <pre data-language=\"ts\">_.padStart(\"Hello TypeScript!\", 20, \" \");</pre> <h2 id=\"찾기-searching\" style=\"position:relative;\">찾기 (Searching)</h2> <p>대부분의 경우, 타입 선언 패키지 이름은 항상 <code>npm</code> 상의 패키지 이름과 같아야 하지만, <code>@types/</code> 가 앞에 붙어야 합니다. 하지만 필요시 <a href=\"https://aka.ms/types\">https://aka.ms/types</a> 를 방문해 선호하는 라이브러리의 패키지를 찾으세요.</p> <blockquote> <p>참고: 만약 찾고자 하는 선언 파일이 없는 경우, 언제든지 기여하고, 다음 개발자가 이를 찾는 데 도움을 줄 수 있습니다. 자세한 내용은 DefinitelyTyped의 <a href=\"http://definitelytyped.org/guides/contributing.html\">기여 지침 페이지</a>를 참고하세요.</p> </blockquote><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2012-2023 Microsoft<br>Licensed under the Apache License, Version 2.0.<br>\n    <a href=\"https://www.typescriptlang.org/ko/docs/handbook/declaration-files/consumption.html\" class=\"_attribution-link\">https://www.typescriptlang.org/ko/docs/handbook/declaration-files/consumption.html</a>\n  </p>\n</div>\n","intro-to-js-ts":"<h1>JS Projects Utilizing TypeScript</h1>\n<p>TypeScript의 타입 시스템은 코드베이스로 작업할 때 엄격함의 레벨이 다릅니다</p> <ul> <li>오직 JavaScript 코드의 추론을 기반으로 하는 타입 시스템</li> <li>\n<a href=\"https://www.typescriptlang.org/docs/handbook/jsdoc-supported-types.html\">JSDoc를 통한</a> JavaScript에서의 Incremental typing</li> <li>JavaScript에서의 <code>// @ts-check</code> 사용</li> <li>TypeScript 코드</li> <li>\n<a href=\"https://www.typescriptlang.org/tsconfig#strict\"><code>strict</code></a>이 활성화된 TypeScript</li> </ul> <p>각 단계는 타입시스템을 더 안전하게 만들지만, 반드시 모든 프로젝트가 이 수준에 맞는 검증을 필요로 하는 것은 아닙니다.</p> <h2 id=\"javascript를-활용한-typescript-typescript-with-javascript\" style=\"position:relative;\">JavaScript를 활용한 TypeScript (TypeScript with JavaScript)</h2> <p>이는 자동 완성, 심벌로 이동 및 이름 바꾸기와 같은 리팩토링 툴을 제공하기 위해서 TypeScript를 사용하는 에디터를 사용할 때 유용합니다. <a href=\"https://www.typescriptlang.org/\">홈페이지</a>에는 TypeScript 플러그인들이 있는 편집자 목록이 있습니다.</p> <h2 id=\"jsdoc을-통하여-js에-타입-힌트-제공하기-providing-type-hints-in-js-via-jsdoc\" style=\"position:relative;\">JSDoc을 통하여 JS에 타입 힌트 제공하기 (Providing Type Hints in JS via JSDoc)</h2> <p><code>.js</code> 파일에서는, 종종 타입들을 유추할 수 있습니다. 타입들을 유추할 수 없는 경우, JSDoc 구문을 사용하여 구체적으로 알릴 수 있습니다.</p> <p>JSDoc 주석은 선언 앞에 위치하며 특정 선언의 타입을 설정하는 데 사용됩니다. 예를 들어:</p> <pre data-language=\"js\">/** @type {number} */\nvar x;\n\nx = 0; // 성공\nx = false; // 성공?!</pre> <p>지원되는 JSDoc 패턴의 전체 목록은 <a href=\"https://www.typescriptlang.org/docs/handbook/jsdoc-supported-types.html\">JSDoc가 지원하는 타입에서</a> 찾을 수 있습니다.</p> <h2 id=\"ts-check\" style=\"position:relative;\"><code>@ts-check</code></h2> <p>이전 코드 예시의 마지막 줄은 TypeScript에서 오류를 발생시키지만, JS 프로젝트에서는 기본적으로 오류를 발생시키지 않습니다. JavaScript 파일에서 오류를 실행하려면 다음을 추가해야 합니다: <code>.js</code> 파일의 첫 번째 줄에 <code>// @ts-check</code>를 추가하여 TypeScript가 이를 오류로 올리도록 해야 합니다.</p> <pre data-language=\"js\">// @ts-check\n// @errors: 2322\n/** @type {number} */\nvar x;\n\nx = 0; // 성공\nx = false; // 성공 아님</pre> <p>만일 오류를 추가하려는 JavaScript 파일이 많은 경우, <a href=\"https://www.typescriptlang.org/docs/handbook/tsconfig-json.html\"><code>jsconfig.json</code></a> 역시 사용할 수 있습니다. 파일에 <code>// @ts-nocheck</code> 코멘트를 추가하면 일부 파일 확인을 건너뛸 수 있습니다.</p> <p>TypeScript는 우리가 동의하지 않는 오류들을 제공할 수도 있는데, 이 경우 특정 줄 맨앞에 <code>// @ts-ignore</code> 또는 <code>// @ts-expect-error</code>를 추가하여 그 줄의 오류를 무시할 수 있습니다.</p> <pre data-language=\"js\">// @ts-check\n/** @type {number} */\nvar x;\n\nx = 0; // 성공\n// @ts-expect-error\nx = false; // 성공 아님</pre> <p>JavaScript를 TypeScript로 해석하는 방법에 대한 자세한 내용은 <a href=\"https://www.typescriptlang.org/docs/handbook/type-checking-javascript-files.html\">TS Type이 JS를 체크하는 방법</a>을 참고하시기 바랍니다.</p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2012-2023 Microsoft<br>Licensed under the Apache License, Version 2.0.<br>\n    <a href=\"https://www.typescriptlang.org/ko/docs/handbook/intro-to-js-ts.html\" class=\"_attribution-link\">https://www.typescriptlang.org/ko/docs/handbook/intro-to-js-ts.html</a>\n  </p>\n</div>\n","declaration-files/dts-from-js":"<h1>Creating .d.ts Files from .js files</h1>\n<p><a href=\"https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-7.html#--declaration-and---allowjs\">TypeScript 3.7에서</a>, TypeScript는 JSDoc 구문을 사용한 JavaScript에서 .d.ts 파일을 생성할 수 있게 되었습니다.</p> <p>즉 프로젝트를 TypeScript에 이식하거나(porting) 코드베이스에 .d.ts 파일을 유지하지 않고도 TypeScript 기반 편집기의 환경을 유지할 수 있습니다. TypeScript는 대부분의 JSDoc 태그를 지원하며, <a href=\"https://www.typescriptlang.org/docs/handbook/type-checking-javascript-files.html#supported-jsdoc\">참조</a>에서 찾을 수 있습니다.</p> <h2 id=\"dts-파일-생성을-위한-프로젝트-설정-setting-up-your-project-to-emit-dts-files\" style=\"position:relative;\">.d.ts 파일 생성을 위한 프로젝트 설정 (Setting up your Project to emit .d.ts files)</h2> <p>.d.ts 파일을 프로젝트에서 생성하려면, 다음과 같은 4단계를 거쳐야합니다:</p> <ul> <li>개발 의존성에 TypeScript 추가</li> <li>TypeScript 설정을 위해 <code>tsconfig.json</code> 추가</li> <li>JS 파일에 해당하는 d.ts 파일을 생성하기 위해 TypeScript 컴파일 실행</li> <li>(선택적으로) 타입을 참조하기 위한 package.json 수정</li> </ul> <h3 id=\"typescript-추가-adding-typescript\" style=\"position:relative;\">TypeScript 추가 (Adding TypeScript)</h3> <p><a href=\"https://www.typescriptlang.org/download\">설치 페이지</a>에서 방법을 확인할 수 있습니다.</p> <h3 id=\"tsconfig\" style=\"position:relative;\">TSConfig</h3> <p>TSConfig는 컴파일러 플래그를 구성하고 파일을 찾을 위치를 선언하는 json5 파일입니다. 위와 같은 경우, 다음과 같은 파일이 필요합니다:</p> <pre tsconfig=\"true\" data-language=\"typescript\">{\n  // 프로젝트에 알맞게 수정하세요.\n  \"include\": [\"src/**/*\"],\n\n  \"compilerOptions\": {\n    // 일반적으로 소스 파일로 무시되기 때문에,\n    // TypeScript가 JS 파일을 읽도록 지시합니다.\n    \"allowJs\": true,\n    // d.ts 파일을 생성시킵니다.\n    \"declaration\": true,\n    // 컴파일러 실행이 오직\n    // d.ts 파일만 출력하게 합니다.\n    \"emitDeclarationOnly\": true,\n    // 타입은 이 디렉터리 안에 존재해야 합니다.\n    // 해당 설정을 제거하면,\n    // .d.ts 파일이 .js 파일 옆에 생성됩니다.\n    \"outDir\": \"dist\",\n  },\n}</pre> <p><a href=\"https://www.typescriptlang.org/reference\">tsconfig 참조</a>에서 더 많은 옵션을 찾을 수 있습니다. TSConfig 파일을 사용하는 대신 CLI를 사용할 수 있습니다.</p> <pre data-language=\"shell\">npx typescript src/**/*.js --declaration --allowJs --emitDeclarationOnly --outDir types</pre> <h2 id=\"컴파일러-실행-run-the-compiler\" style=\"position:relative;\">컴파일러 실행 (Run the compiler)</h2> <p><a href=\"https://www.typescriptlang.org/download\">설치 페이지</a>에서 방법을 확인할 수 있습니다. 프로젝트의 <code>.gitignore</code>에 파일이 있을 때, 이러한 파일들이 패키지에 포함되어 있는지 확인합니다.</p> <h2 id=\"packagejson-수정-editing-the-packagejson\" style=\"position:relative;\">package.json 수정 (Editing the package.json)</h2> <p>TypeScript는 .d.ts 파일을 찾기 위한 추가 단계와 함께 <code>package.json</code>의 모듈에 대한 노드 관계(node resolution)를 복제합니다. 대략적으로 먼저 선택적인 <code>\"types\"</code> 필드를 확인 후, 다음은 <code>\"main\"</code>, 마지막으로 루트에서 <code>index.d.ts</code>를 확인합니다.</p> <table> <thead> <tr> <th align=\"left\">Package.json</th> <th align=\"left\">기본 .d.ts의 위치</th> </tr> </thead> <tbody> <tr> <td align=\"left\">“types” 필드 없음</td> <td align=\"left\">“main” 확인 후, index.d.ts 확인</td> </tr> <tr> <td align=\"left\">“types”: “main.d.ts”</td> <td align=\"left\">main.d.ts</td> </tr> <tr> <td align=\"left\">“types”: “./dist/main.js”</td> <td align=\"left\">./dist/main.d.ts</td> </tr> </tbody> </table> <p>type 필드가 없다면, “main”으로 넘어갑니다.</p> <table> <thead> <tr> <th align=\"left\">Package.json</th> <th align=\"left\">기본 .d.ts의 위치</th> </tr> </thead> <tbody> <tr> <td align=\"left\">“main” 필드 없음</td> <td align=\"left\">index.d.ts</td> </tr> <tr> <td align=\"left\">“main”:“index.js”</td> <td align=\"left\">index.d.ts</td> </tr> <tr> <td align=\"left\">“main”:“./dist/index.js”</td> <td align=\"left\">./dist/index.d.ts</td> </tr> </tbody> </table> <h2 id=\"팁-tips\" style=\"position:relative;\">팁 (Tips)</h2> <p>.d.ts의 테스트를 작성하고 싶다면, <a href=\"https://github.com/SamVerschueren/tsd\">tsd</a>를 사용해보세요.</p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2012-2023 Microsoft<br>Licensed under the Apache License, Version 2.0.<br>\n    <a href=\"https://www.typescriptlang.org/ko/docs/handbook/declaration-files/dts-from-js.html\" class=\"_attribution-link\">https://www.typescriptlang.org/ko/docs/handbook/declaration-files/dts-from-js.html</a>\n  </p>\n</div>\n","jsdoc-supported-types":"<h1>JSDoc Reference</h1>\n<p>아래 목록은 JavaScript 파일에 타입 정보 제공을 위해 JSDoc 어노테이션을 사용할 때 현재 지원되는 구성의 개요를 다룹니다.</p> <p>아래 명시적으로 나열되지 않은 태그(예 <code>@async</code>)는 아직 지원되지 않습니다.</p> <ul> <li><a href=\"#type\"><code>@type</code></a></li> <li>\n<a href=\"#param-and-returns\"><code>@param</code></a> (or <a href=\"#param-and-returns\"><code>@arg</code></a> or <a href=\"#param-and-returns\"><code>@argument</code></a>)</li> <li>\n<a href=\"#param-and-returns\"><code>@returns</code></a> (or <a href=\"#param-and-returns\"><code>@return</code></a>)</li> <li><a href=\"#typedef-callback-and-param\"><code>@typedef</code></a></li> <li><a href=\"#typedef-callback-and-param\"><code>@callback</code></a></li> <li><a href=\"#template\"><code>@template</code></a></li> <li>\n<a href=\"#constructor\"><code>@class</code></a> (or <a href=\"#constructor\"><code>@constructor</code></a>)</li> <li><a href=\"#this\"><code>@this</code></a></li> <li>\n<a href=\"#extends\"><code>@extends</code></a> (or <a href=\"#extends\"><code>@augments</code></a>)</li> <li><a href=\"#enum\"><code>@enum</code></a></li> </ul> <h4 id=\"class-extensions\" style=\"position:relative;\">\n<code>class</code> extensions</h4> <ul> <li>\n<a href=\"#jsdoc-property-modifiers\">Property Modifiers</a> <code>@public</code>, <code>@private</code>, <code>@protected</code>, <code>@readonly</code>\n</li> </ul> <p>The meaning is usually the same, or a superset, of the meaning of the tag given at <a href=\"https://jsdoc.app\">jsdoc.app</a>. The code below describes the differences and gives some example usage of each tag.</p> <p><strong>Note:</strong> You can use <a href=\"https://www.typescriptlang.org/play?useJavaScript=truee=4#example/jsdoc-support\">the playground to explore JSDoc support</a>.</p> <h2 id=\"type\" style=\"position:relative;\"><code>@type</code></h2> <p>“@type” 태그를 사용하여 타입의 이름을 참조할 수 있습니다 (다음 경우 중 하나인 원시 타입과 TypeScript에 정의되어있거나 JSDoc “@typedef” 태그로 정의되어있거나). 당신은 대부분 JSDoc 타입들이나 TypeScript 타입을 사용할 것입니다,<a href=\"https://www.typescriptlang.org/docs/handbook/basic-types.html\">기존에 많이 사용하는 <code>string</code></a>부터 <a href=\"https://www.typescriptlang.org/docs/handbook/advanced-types.html\">조건부 타입인 고급 타입</a>까지.</p> <pre data-language=\"js\">/**\n * @type {string}\n */\nvar s;\n\n/** @type {Window} */\nvar win;\n\n/** @type {PromiseLike&lt;string&gt;} */\nvar promisedString;\n\n// DOM 프로퍼티를 사용하여 HTML 요소를 지정할 수 있습니다\n/** @type {HTMLElement} */\nvar myElement = document.querySelector(selector);\nelement.dataset.myData = \"\";</pre> <p><code>@type</code> 을 이용하여 유니언 타입을 지정할 수 있습니다. 예를 들어 어떤 것은 string 또는 boolean 일 수 있습니다.</p> <pre data-language=\"js\">/**\n * @type {(string | boolean)}\n */\nvar sb;</pre> <p>괄호는 유니언 타입에 대한 선택 사항입니다.</p> <pre data-language=\"js\">/**\n * @type {string | boolean}\n */\nvar sb;</pre> <p>다양한 구문을 통하여 배열 타입을 지정할 수 있습니다:</p> <pre data-language=\"js\">/** @type {number[]} */\nvar ns;\n/** @type {Array.&lt;number&gt;} */\nvar nds;\n/** @type {Array&lt;number&gt;} */\nvar nas;</pre> <p>또한 객체 리터럴 타입들도 지정할 수 있습니다. 예를 들어, 오브젝트에 프로퍼티 ‘a’ (string) 와 ‘b’ (number)을 사용한 경우 다음 구문을 사용합니다:</p> <pre data-language=\"js\">/** @type {{ a: string, b: number }} */\nvar var9;</pre> <p>당신은 JSDoc 구문이나 TypeScript 구문을 사용하여 문자열 및 숫자 인덱스 맵과 배열과 비슷한 오브젝트를 표시할 수 있습니다.</p> <pre data-language=\"js\">/**\n * 맵 같은 object는 임의의 `string` 프로퍼티들을 `number`로 바꿔줍니다.\n *\n * @type {Object.&lt;string, number&gt;}\n */\nvar stringToNumber;\n\n/** @type {Object.&lt;number, object&gt;} */\nvar arrayLike;</pre> <p>앞의 두 타입은 TypeScript의 타입인 <code>{ [x: string]: number }</code> 와 <code>{ [x: number]: any }</code>를 동일합니다. 컴파일러는 이 두 구문을 모두 이해합니다.</p> <p>TypeScript나 클로저 구문을 사용하여 함수 타입을 지정할 수 있습니다:</p> <pre data-language=\"js\">/** @type {function(string, boolean): number} 클로저 구문 */\nvar sbn;\n/** @type {(s: string, b: boolean) =&gt; number} TypeScript 구문 */\nvar sbn2;</pre> <p>혹은 특정하지 않은 <code>Function</code> 타입을 사용할 수 있습니다:</p> <pre data-language=\"js\">/** @type {Function} */\nvar fn7;\n/** @type {function} */\nvar fn6;</pre> <p>클로저의 다른 타입들 또한 작동합니다:</p> <pre data-language=\"js\">/**\n * @type {*} - 'any' 타입으로 쓸 수 있습니다\n */\nvar star;\n/**\n * @type {?} - 알 수 없는 타입 ('any'와 같습니다)\n */\nvar question;</pre> <h3 id=\"형변환-casts\" style=\"position:relative;\">형변환 (Casts)</h3> <p>TypeScript는 클로저 구문을 차용합니다. 이렇게 하면 괄호로 묶인 표현식 앞에 <code>@type</code> 태그를 추가하여 다른 유형으로 형변환할 수 있습니다.</p> <pre data-language=\"js\">/**\n * @type {number | string}\n */\nvar numberOrString = Math.random() &lt; 0.5 ? \"hello\" : 100;\nvar typeAssertedNumber = /** @type {number} */ (numberOrString);</pre> <h3 id=\"타입-가져오기-import-types\" style=\"position:relative;\">타입 가져오기 (Import types)</h3> <p>다른 파일에서 사용하고 있는 타입들은 import 선언을 통하여 가져올 수 있습니다. 이 구문은 TypeScript에 따라 다르며 JSDoc 표준과 다릅니다:</p> <pre data-language=\"js\">// @filename: types.d.ts\nexport type Pet = {\n  name: string,\n};\n\n// @filename: main.js\n/**\n * @param p { import(\"./types\").Pet }\n */\nfunction walk(p) {\n  console.log(`Walking ${p.name}...`);\n}</pre> <p>가져온 타입들 또한 별칭 선언에서 사용할 수 있습니다:</p> <pre data-language=\"js\">// @filename: types.d.ts\nexport type Pet = {\n  name: string,\n};\n// @filename: main.js\n// ---cut---\n/**\n * @typedef { import(\"./types\").Pet } Pet\n */\n\n/**\n * @type {Pet}\n */\nvar myPet;\nmyPet.name;</pre> <p>만약 알 수 없는 타입이거나 너무 큰 타입일 경우 모듈에서 얻어온 값의 타입을 사용할 수 있습니다:</p> <pre data-language=\"js\">// @filename: accounts.d.ts\nexport const userAccount = {\n  name: \"Name\",\n  address: \"An address\",\n  postalCode: \"\",\n  country: \"\",\n  planet: \"\",\n  system: \"\",\n  galaxy: \"\",\n  universe: \"\",\n};\n// @filename: main.js\n// ---cut---\n/**\n * @type {typeof import(\"./accounts\").userAccount }\n */\nvar x = require(\"./accounts\").userAccount;</pre> <h2 id=\"param-과-returns\" style=\"position:relative;\">\n<code>@param</code> 과 <code>@returns</code>\n</h2> <p><code>@param</code>은 타입 구문인 <code>@type</code>과 동일하게 사용합니다, 하지만 매개변수 이름을 추가할 수 있습니다. 매개변수는 이름 주변에 대괄호와 함께 선택적으로 선언됩니다:</p> <pre data-language=\"js\">// 매개변수들은 다양한 구문형식으로 선언될 수 있습니다\n/**\n * @param {string}  p1 - string 매개변수.\n * @param {string=} p2 - 선택적 매개변수 (클로저 구문)\n * @param {string} [p3] - 또다른 선택적 매개변수 (JSDoc 구문).\n * @param {string} [p4=\"test\"] - 기본값과 선택적 매개변수\n * @return {string} 이것은 결과 값입니다\n */\nfunction stringsStringStrings(p1, p2, p3, p4) {\n  // TODO\n}</pre> <p>마찬가지로, 함수의 반환형일 경우:</p> <pre data-language=\"js\">/**\n * @return {PromiseLike&lt;string&gt;}\n */\nfunction ps() {}\n\n/**\n * @returns {{ a: string, b: number }} - May use '@returns' as well as '@return'\n */\nfunction ab() {}</pre> <h2 id=\"typedef-callback-and-param\" style=\"position:relative;\">\n<code>@typedef</code>, <code>@callback</code>, and <code>@param</code>\n</h2> <p><code>@typedef</code> 는 복잡한 타입을 정의할 때 사용합니다. 마치 <code>@param</code>과 비슷하게 동작합니다.</p> <pre data-language=\"js\">/**\n * @typedef {Object} SpecialType - 새로운 타입인 'SpecialType'을 생성합니다\n * @property {string} prop1 - SpecialType의 string 프로퍼티\n * @property {number} prop2 - SpecialType의 number 프로퍼티\n * @property {number=} prop3 - SpecialType의 선택적 number 프로퍼티\n * @prop {number} [prop4] - SpecialType의 선택적 number 프로퍼티\n * @prop {number} [prop5=42] - SpecialType의 기본값이 존재하는 선택적 number 프로퍼티\n */\n\n/** @type {SpecialType} */\nvar specialTypeObject;\nspecialTypeObject.prop3;</pre> <p><code>object</code> 혹은 <code>Object</code>를 첫 번째 줄에 사용할 수 있습니다.</p> <pre data-language=\"js\">/**\n * @typedef {object} SpecialType1 - 새로운 타입인 'SpecialType'을 생성합니다\n * @property {string} prop1 - SpecialType의 string 프로퍼티\n * @property {number} prop2 - SpecialType의 number 프로퍼티\n * @property {number=} prop3 - SpecialType의 선택적 number 프로퍼티\n */\n\n/** @type {SpecialType1} */\nvar specialTypeObject1;</pre> <p><code>@param</code> 은 한 번만 사용하는 타입과 비슷한 구문을 허용합니다. 포함된 프로퍼티의 이름은 파라미터의 이름을 접두사로 사용해야 합니다:</p> <pre data-language=\"js\">/**\n * @param {Object} options - 위의 SpecialType와 비슷합니다.\n * @param {string} options.prop1\n * @param {number} options.prop2\n * @param {number=} options.prop3\n * @param {number} [options.prop4]\n * @param {number} [options.prop5=42]\n */\nfunction special(options) {\n  return (options.prop4 || 1001) + options.prop5;\n}</pre> <p><code>@callback</code>은 <code>@typedef</code>와 비슷합니다. 하지만 이것은 object 타입 대신 특정한 function 타입을 지정합니다:</p> <pre data-language=\"js\">/**\n * @callback Predicate\n * @param {string} data\n * @param {number} [index]\n * @returns {boolean}\n */\n\n/** @type {Predicate} */\nconst ok = (s) =&gt; !(s.length % 2);</pre> <p>물론, 이런 타입들은 TypeScript 구문에서 <code>@typedef</code> 단 한 줄로 선언할 수 있습니다:</p> <pre data-language=\"js\">/** @typedef {{ prop1: string, prop2: string, prop3?: number }} SpecialType */\n/** @typedef {(data: string, index?: number) =&gt; boolean} Predicate */</pre> <h2 id=\"template\" style=\"position:relative;\"><code>@template</code></h2> <p><code>@template</code> 태그를 사용하여 제네릭 함수를 선언할 수 있습니다:</p> <pre data-language=\"js\">/**\n * @template T\n * @param {T} x - 제네릭 매개변수는 리턴 타입과 같게 됩니다\n * @return {T}\n */\nfunction id(x) {\n  return x;\n}\n\nconst a = id(\"string\");\nconst b = id(123);\nconst c = id({});</pre> <p>콤마 혹은 여러 태그를 통하여 여러 타입의 매개변수를 선언할 수 있습니다:</p> <pre data-language=\"js\">/**\n * @template T,U,V\n * @template W,X\n */</pre> <p>또한 특정한 매개변수 앞에 타입을 지정할 수 있습니다. 매개변수 중 오직 첫 번째 매개변수만 제한됩니다:</p> <pre data-language=\"js\">/**\n * @template {string} K - K는 string 혹은 string 리터럴이어야 합니다\n * @template {{ serious(): string }} Seriousalizable - serious 메서드가 있어야 합니다\n * @param {K} key\n * @param {Seriousalizable} object\n */\nfunction seriousalize(key, object) {\n  // ????\n}</pre> <p>제네릭 클래스 혹은 타입 선언은 지원되지 않습니다.</p> <h2 id=\"클래스-classes\" style=\"position:relative;\">클래스 (Classes)</h2> <p>클래스는 ES6 클래스로 선언할 수 있습니다.</p> <pre data-language=\"js\">class C {\n  /**\n   * @param {number} data\n   */\n  constructor(data) {\n    // 프로퍼티 타입은 추론될 수 있습니다\n    this.name = \"foo\";\n\n    // 또는 명시적으로 선언할 수도 있습니다\n    /** @type {string | null} */\n    this.title = null;\n\n    // 만약 다른 곳에 선언되어 있다면 어노테이션으로 표기할 수 있습니다.\n    /** @type {number} */\n    this.size;\n\n    this.initialize(data); // 오류가 난다면, 이니셜 라이저는 string을 예상합니다\n  }\n  /**\n   * @param {string} s\n   */\n  initialize = function (s) {\n    this.size = s.length;\n  };\n}\n\nvar c = new C(0);\n\n// C는 new 와 함께 호출되어야합니다\n// 하지만 이건 JavaScript이고, 이것은 허용되며\n// 'any'로 간주됩니다.\nvar result = C(1);</pre> <p>다음 섹션에 설명된 대로 생성자 함수를 선언할 수 있습니다:</p> <h2 id=\"constructor\" style=\"position:relative;\"><code>@constructor</code></h2> <p>컴파일러는 속성 할당을 기반으로 생성자 함수를 추론합니다, 하지만 <code>@constructor</code> 태그를 사용하면 더 엄격한 검사와 제안 사항을 확인할 수 있습니다:</p> <pre data-language=\"js\">// @checkJs\n// @errors: 2345 2348\n/**\n * @constructor\n * @param {number} data\n */\nfunction C(data) {\n  // 프로퍼티 타입은 추론될 수 있습니다\n  this.name = \"foo\";\n\n  // 또는 명시적으로 선언할 수도 있습니다\n  /** @type {string | null} */\n  this.title = null;\n\n  // 만약 다른 곳에 선언되어 있다면 어노테이션으로 표기할 수 있습니다.\n  /** @type {number} */\n  this.size;\n\n  this.initialize(data);\n}\n/**\n * @param {string} s\n */\nC.prototype.initialize = function (s) {\n  this.size = s.length;\n};\n\nvar c = new C(0);\nc.size;\n\nvar result = C(1);</pre> <blockquote> <p>Note: 오류 메시지는 <a href=\"https://www.typescriptlang.org/docs/handbook/tsconfig-json.html\">a JSConfig</a> 및 <a href=\"https://www.typescriptlang.org/tsconfig#checkJs\"><code>checkJs</code></a>가 활성화된 상태에서만 JS 코드 베이스에 나타납니다.</p> </blockquote> <p><code>@constructor</code>를 사용하면 생성자 함수 <code>C</code>안에 <code>this</code>가 있는지 검사하므로, <code>initialize</code> 메서드에 대한 제안사항을 받으며 만약 인자로 숫자를 넘긴다면 오류가 발생합니다. 또한 <code>C</code>를 생성하지 않고 호출만 한다면 에디터에서 경고를 표시할 수 있습니다.</p> <p>유감스럽게도, 이는 호출가능한 생성자 함수는 <code>@constructor</code>를 사용하지 못함을 의미합니다.</p> <h2 id=\"this\" style=\"position:relative;\"><code>@this</code></h2> <p>컴파일러는 코드가 동작할 컨텍스트가 있다면 보통 <code>this</code>의 타입을 파악할 수 있습니다. 그렇지 않은 경우, <code>@this</code>를 사용하여 명확하게 <code>this</code>의 타입을 지정할 수 있습니다:</p> <pre data-language=\"js\">/**\n * @this {HTMLElement}\n * @param {*} e\n */\nfunction callbackForLater(e) {\n  this.clientHeight = parseInt(e); // 잘 작동해야 합니다!\n}</pre> <h2 id=\"extends\" style=\"position:relative;\"><code>@extends</code></h2> <p>Javascript 클래스를 제네릭 기반 클래스로부터 상속(extend)하면, 매개변수가 어떤 타입이 되어야 하는지 지정할 곳이 없습니다. <code>@extends</code> 태그는 이러한 타입 매개변수를 위한 위치를 제공합니다:</p> <pre data-language=\"js\">/**\n * @template T\n * @extends {Set&lt;T&gt;}\n */\nclass SortableSet extends Set {\n  // ...\n}</pre> <p><code>@extends</code>는 클래스에서만 작동합니다. 현재까지, 생성자 함수가 클래스를 상속할 수 있는 방법은 없습니다.</p> <h2 id=\"enum\" style=\"position:relative;\"><code>@enum</code></h2> <p><code>@enum</code> 태그는 멤버가 모두 지정된 객체 리터럴을 만들 수 있게 도와줍니다. Javascript 대부분의 객체 리터럴과 달리, 이 태그는 다른 멤버를 허용하지 않습니다.</p> <pre data-language=\"js\">/** @enum {number} */\nconst JSDocState = {\n  BeginningOfLine: 0,\n  SawAsterisk: 1,\n  SavingComments: 2,\n};\n\nJSDocState.SawAsterisk;</pre> <p><code>@enum</code>은 TypeScript의 <code>enum</code>과 상당히 다르고, 더 간단합니다. 하지만 TypeScript의 열거형(enum)과 달리, <code>@enum</code>은 어떠한 타입도 가질 수 있습니다:</p> <pre data-language=\"js\">/** @enum {function(number): number} */\nconst MathFuncs = {\n  add1: (n) =&gt; n + 1,\n  id: (n) =&gt; -n,\n  sub1: (n) =&gt; n - 1,\n};\n\nMathFuncs.add1;</pre> <h2 id=\"추가-예제-more-examples\" style=\"position:relative;\">추가 예제 (More examples)</h2> <pre data-language=\"js\">class Foo {}\n// ---cut---\nvar someObj = {\n  /**\n   * @param {string} param1 - 프로퍼티 할당 문서를 참조하세요\n   */\n  x: function (param1) {},\n};\n\n/**\n * 변수 할당 문서를 참조하세요\n * @return {Window}\n */\nlet someFunc = function () {};\n\n/**\n * 클래스 메서드\n * @param {string} greeting 사용할 인사말\n */\nFoo.prototype.sayHi = (greeting) =&gt; console.log(\"Hi!\");\n\n/**\n * 화살표 함수 표현식\n * @param {number} x - 곱하는 수\n */\nlet myArrow = (x) =&gt; x * x;\n\n/**\n * JSX의 무상태 함수형 컴포넌트(SFC)에도 작동합니다\n * @param {{a: string, b: number}} test - Some param\n */\nvar sfc = (test) =&gt; &lt;div&gt;{test.a.charAt(0)}&lt;/div&gt;;\n\n/**\n * 매개변수는 클로저 구문을 사용하면 클래스 생성자로 사용할 수 있습니다.\n *\n * @param {{new(...args: any[]): object}} C - The class to register\n */\nfunction registerClass(C) {}\n\n/**\n * @param {...string} p1 - '나머지' 문자열 인수들의 배열 ('any' 타입으로 취급됨)\n */\nfunction fn10(p1) {}\n\n/**\n * @param {...string} p1 - '나머지' 문자열 인수들의 배열 ('any' 타입으로 취급됨)\n */\nfunction fn9(p1) {\n  return p1.join();\n}</pre> <h2 id=\"지원하지-않는다고-알려진-패턴-patterns-that-are-known-not-to-be-supported\" style=\"position:relative;\">지원하지 않는다고 알려진 패턴 (Patterns that are known NOT to be supported)</h2> <p>Value space 안의 객체를 타입으로 태그하는 것은 객체가 마치 생성자 함수처럼 타입을 생성하지 않는 이상 작동하지 않습니다.</p> <pre data-language=\"js\">function aNormalFunction() {}\n/**\n * @type {aNormalFunction}\n */\nvar wrong;\n/**\n * 'typeof'를 대신 사용하세요:\n * @type {typeof aNormalFunction}\n */\nvar right;</pre> <p>접미사(Postfix)는 선택적(Optional) 프로퍼티를 구체화하지 않는 객체 리터럴 타입의 프로퍼티 타입과 같습니다:</p> <pre data-language=\"js\">/**\n * @type {{ a: string, b: number= }}\n */\nvar wrong;\n/**\n * 프로퍼티 이름 대신 물음표 접미사를 사용하세요:\n * @type {{ a: string, b?: number }}\n */\nvar right;</pre> <p><code>strictNullCheck</code>가 활성화 중인 경우에만 널러블(Nullable) 타입이 의미가 있습니다.</p> <pre data-language=\"js\">/**\n * @type {?number}\n * With strictNullChecks: true  -- number | null\n * With strictNullChecks: false -- number\n */\nvar nullable;</pre> <p>유니언 타입을 사용해도 됩니다:</p> <pre data-language=\"js\">/**\n * @type {number | null}\n * With strictNullChecks: true  -- number | null\n * With strictNullChecks: false -- number\n */\nvar unionNullable;</pre> <p>널러블 타입이 아닌 경우에는 아무 의미가 없으며 원래 타입으로 취급합니다:</p> <pre data-language=\"js\">/**\n * @type {!number}\n * 타입 number를 가집니다\n */\nvar normal;</pre> <p>JSDoc의 타입 체계와 달리, TypeScript는 타입이 오직 null을 포함하거나 하지 않는다 표시할 수 있습니다. 널러블은 명확하게 구분되지 않습니다 — 만약 strictNullChecks가 활성화 중이라면, <code>number</code>는 널러블하지 않습니다. 반대의 경우, <code>number</code>는 널러블합니다.</p> <h3 id=\"지원하지-않는-태그-unsupported-tags\" style=\"position:relative;\">지원하지 않는 태그 (Unsupported tags)</h3> <p>TypeScript는 지원하지 않는 JSDoc 태그를 무시합니다.</p> <p>태그 지원을 위한 오픈 이슈가 아래에 있습니다:</p> <ul> <li>\n<code>@const</code> (<a href=\"https://github.com/Microsoft/TypeScript/issues/19672\">issue #19672</a>)</li> <li>\n<code>@inheritdoc</code> (<a href=\"https://github.com/Microsoft/TypeScript/issues/23215\">issue #23215</a>)</li> <li>\n<code>@memberof</code> (<a href=\"https://github.com/Microsoft/TypeScript/issues/7237\">issue #7237</a>)</li> <li>\n<code>@yields</code> (<a href=\"https://github.com/Microsoft/TypeScript/issues/23857\">issue #23857</a>)</li> <li>\n<code>{@link …}</code> (<a href=\"https://github.com/Microsoft/TypeScript/issues/35524\">issue #35524</a>)</li> </ul> <h2 id=\"js-class-extensions\" style=\"position:relative;\">JS Class extensions</h2> <h3 id=\"jsdoc-property-modifiers\" style=\"position:relative;\">JSDoc Property Modifiers</h3> <p>From TypeScript 3.8 onwards, you can use JSDoc to modify the properties in a class. First are the accessibility modifiers: <code>@public</code>, <code>@private</code>, and <code>@protected</code>. These tags work exactly like <code>public</code>, <code>private</code>, and <code>protected</code> respectively work in TypeScript.</p> <pre data-language=\"js\">// @ts-check\n \nclass Car {\n  constructor() {\n    /** @private */\n    this.identifier = 100;\n  }\n \n  printIdentifier() {\n    console.log(this.identifier);\n  }\n}\n \nconst c = new Car();\nconsole.log(c.identifier);</pre> <ul> <li>\n<code>@public</code> is always implied and can be left off, but means that a property can be reached from anywhere.</li> <li>\n<code>@private</code> means that a property can only be used within the containing class.</li> <li>\n<code>@protected</code> means that a property can only be used within the containing class, and all derived subclasses, but not on dissimilar instances of the containing class.</li> </ul> <p>Next, we’ve also added the <code>@readonly</code> modifier to ensure that a property is only ever written to during initialization.</p> <pre data-language=\"js\">// @ts-check\n \nclass Car {\n  constructor() {\n    /** @readonly */\n    this.identifier = 100;\n  }\n \n  printIdentifier() {\n    console.log(this.identifier);\n  }\n}\n \nconst c = new Car();\nconsole.log(c.identifier);</pre><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2012-2023 Microsoft<br>Licensed under the Apache License, Version 2.0.<br>\n    <a href=\"https://www.typescriptlang.org/ko/docs/handbook/jsdoc-supported-types.html\" class=\"_attribution-link\">https://www.typescriptlang.org/ko/docs/handbook/jsdoc-supported-types.html</a>\n  </p>\n</div>\n","tsconfig-json":"<h1>What is a tsconfig.json</h1>\n<h2 id=\"개요-overview\" style=\"position:relative;\">개요 (Overview)</h2> <p>디렉토리에 <code>tsconfig.json</code> 파일이 있다면 해당 디렉토리가 TypeScript 프로젝트의 루트가 됩니다.<br> <code>tsconfig.json</code> 파일은 프로젝트를 컴파일하는 데 필요한 루트 파일과 컴파일러 옵션을 지정합니다.</p> <p>JavaScript 프로젝트는 <code>jsconfig.json</code> 파일을 대신 사용할 수 있습니다. 이 파일은 <code>tsconfig.json</code> 파일과 거의 동일하게 동작하지만, 몇몇 JavaScript 관련 컴파일러 플래그가 기본으로 활성화되어 있습니다.</p> <p>프로젝트는 다음 방법들로 컴파일됩니다:</p> <h2 id=\"tsconfigjson-또는-jsconfigjson-사용하기-using-tsconfigjson-or-jsconfigjson\" style=\"position:relative;\">\n<code>tsconfig.json</code> 또는 <code>jsconfig.json</code> 사용하기 (Using <code>tsconfig.json</code> or <code>jsconfig.json</code>)</h2> <ul> <li>입력 파일 없이 <code>tsc</code>를 호출하면 컴파일러는 현재 디렉토리에서부터 시작하여 상위 디렉토리 체인으로 <code>tsconfig.json</code> 파일을 검색합니다.</li> <li>입력 파일이 없이 <code>tsc</code>와 <code>tsconfig.json</code> 파일이 포함된 디렉토리 경로 또는 설정이 포함된 유효한 경로의 <code>.json</code> 파일 경로를 지정하는 <code>--project</code> (또는 <code>-p</code>) 커맨드 라인 옵션을 사용할 수 있습니다.</li> </ul> <p>커맨드 라인에 입력 파일을 지정하면 <code>tsconfig.json</code> 파일이 무시됩니다.</p> <h2 id=\"예제-examples\" style=\"position:relative;\">예제 (Examples)</h2> <p><code>tsconfig.json</code> 예제 파일들:</p> <ul> <li> <p><code>\"files\"</code> 속성 사용하기</p> <pre tsconfig=\"true\" data-language=\"typescript\">{\n  \"compilerOptions\": {\n    \"module\": \"commonjs\",\n    \"noImplicitAny\": true,\n    \"removeComments\": true,\n    \"preserveConstEnums\": true,\n    \"sourceMap\": true\n  },\n  \"files\": [\n    \"core.ts\",\n    \"sys.ts\",\n    \"types.ts\",\n    \"scanner.ts\",\n    \"parser.ts\",\n    \"utilities.ts\",\n    \"binder.ts\",\n    \"checker.ts\",\n    \"emitter.ts\",\n    \"program.ts\",\n    \"commandLineParser.ts\",\n    \"tsc.ts\",\n    \"diagnosticInformationMap.generated.ts\"\n  ]\n}</pre> </li> <li> <p><code>\"include\"</code> 와 <code>\"exclude\"</code> 속성 사용하기</p> <pre tsconfig=\"true\" data-language=\"typescript\">{\n  \"compilerOptions\": {\n    \"module\": \"system\",\n    \"noImplicitAny\": true,\n    \"removeComments\": true,\n    \"preserveConstEnums\": true,\n    \"outFile\": \"../../built/local/tsc.js\",\n    \"sourceMap\": true\n  },\n  \"include\": [\"src/**/*\"],\n  \"exclude\": [\"node_modules\", \"**/*.spec.ts\"]\n}</pre> </li> </ul> <h2 id=\"tsconfig-bases\" style=\"position:relative;\">TSConfig Bases</h2> <p>Depending on the JavaScript runtime environment which you intend to run your code in, there may be a base configuration which you can use at <a href=\"https://github.com/tsconfig/bases/\">github.com/tsconfig/bases</a>. These are <code>tsconfig.json</code> files which your project extends from which simplifies your <code>tsconfig.json</code> by handling the runtime support.</p> <p>For example, if you were writing a project which uses Node.js version 12 and above, then you could use the npm module <a href=\"https://www.npmjs.com/package/@tsconfig/node12\"><code>@tsconfig/node12</code></a>:</p> <pre tsconfig=\"true\" data-language=\"typescript\">{\n  \"extends\": \"@tsconfig/node12/tsconfig.json\",\n\n  \"compilerOptions\": {\n    \"preserveConstEnums\": true\n  },\n\n  \"include\": [\"src/**/*\"],\n  \"exclude\": [\"node_modules\", \"**/*.spec.ts\"]\n}</pre> <p>This lets your <code>tsconfig.json</code> focus on the unique choices for your project, and not all of the runtime mechanics. There are a few tsconfig bases already, and we’re hoping the community can add more for different environments.</p> <ul> <li><a href=\"https://www.npmjs.com/package/@tsconfig/recommended\">Recommended</a></li> <li><a href=\"https://www.npmjs.com/package/@tsconfig/node10\">Node 10</a></li> <li><a href=\"https://www.npmjs.com/package/@tsconfig/node12\">Node 12</a></li> <li><a href=\"https://www.npmjs.com/package/@tsconfig/node14\">Node 14</a></li> <li><a href=\"https://www.npmjs.com/package/@tsconfig/deno\">Deno</a></li> <li><a href=\"https://www.npmjs.com/package/@tsconfig/react-native\">React Native</a></li> <li><a href=\"https://www.npmjs.com/package/@tsconfig/svelte\">Svelte</a></li> </ul> <h2 id=\"상세-설명-details\" style=\"position:relative;\">상세 설명 (Details)</h2> <p><code>\"compilerOptions\"</code> 속성은 생략될 수 있으며 생략하면 컴파일러의 기본 값이 사용됩니다. 지원되는 전체 목록은 <a href=\"https://www.typescriptlang.org/docs/handbook/compiler-options.html\">컴파일러 옵션</a>를 참고하세요.</p> <h2 id=\"tsconfig-레퍼런스\" style=\"position:relative;\">TSConfig 레퍼런스</h2> <p>TSConfig 레퍼런스를 보려면 <a href=\"https://www.typescriptlang.org/tsconfig\">여기</a>로 이동하세요.</p> <h2 id=\"스키마-schema\" style=\"position:relative;\">스키마 (Schema)</h2> <p><code>tsconfig.json</code> 스키마는 <a href=\"http://json.schemastore.org/tsconfig\">http://json.schemastore.org/tsconfig</a>에서 찾을 수 있습니다.</p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2012-2023 Microsoft<br>Licensed under the Apache License, Version 2.0.<br>\n    <a href=\"https://www.typescriptlang.org/ko/docs/handbook/tsconfig-json.html\" class=\"_attribution-link\">https://www.typescriptlang.org/ko/docs/handbook/tsconfig-json.html</a>\n  </p>\n</div>\n","compiler-options-in-msbuild":"<h1>Compiler Options in MSBuild</h1>\n<h2 id=\"개요-overview\" style=\"position:relative;\">개요 (Overview)</h2> <p>컴파일러 옵션은 MSBuild 프로젝트 내의 MSBuild 프로퍼티를 사용하여 지정할 수 있습니다.</p> <h2 id=\"예제-example\" style=\"position:relative;\">예제 (Example)</h2> <pre data-language=\"typescript\">  &lt;PropertyGroup Condition=\"'$(Configuration)' == 'Debug'\"&gt;\n    &lt;TypeScriptRemoveComments&gt;false&lt;/TypeScriptRemoveComments&gt;\n    &lt;TypeScriptSourceMap&gt;true&lt;/TypeScriptSourceMap&gt;\n  &lt;/PropertyGroup&gt;\n  &lt;PropertyGroup Condition=\"'$(Configuration)' == 'Release'\"&gt;\n    &lt;TypeScriptRemoveComments&gt;true&lt;/TypeScriptRemoveComments&gt;\n    &lt;TypeScriptSourceMap&gt;false&lt;/TypeScriptSourceMap&gt;\n  &lt;/PropertyGroup&gt;\n  &lt;Import\n      Project=\"$(MSBuildExtensionsPath32)\\Microsoft\\VisualStudio\\v$(VisualStudioVersion)\\TypeScript\\Microsoft.TypeScript.targets\"\n      Condition=\"Exists('$(MSBuildExtensionsPath32)\\Microsoft\\VisualStudio\\v$(VisualStudioVersion)\\TypeScript\\Microsoft.TypeScript.targets')\" /&gt;</pre> <h2 id=\"맵핑-mappings\" style=\"position:relative;\">맵핑 (Mappings)</h2> <table> <thead> <tr> <th>컴파일러 옵션</th> <th>MSBuild 프로퍼티 이름</th> <th>허용된 값</th> </tr> </thead> <tbody> <tr> <td><code>--allowJs</code></td> <td><em>MSBuild에서 지원되지 않습니다</em></td> <td></td> </tr> <tr> <td><code>--allowSyntheticDefaultImports</code></td> <td>TypeScriptAllowSyntheticDefaultImports</td> <td>boolean</td> </tr> <tr> <td><code>--allowUnreachableCode</code></td> <td>TypeScriptAllowUnreachableCode</td> <td>boolean</td> </tr> <tr> <td><code>--allowUnusedLabels</code></td> <td>TypeScriptAllowUnusedLabels</td> <td>boolean</td> </tr> <tr> <td><code>--alwaysStrict</code></td> <td>TypeScriptAlwaysStrict</td> <td>boolean</td> </tr> <tr> <td><code>--baseUrl</code></td> <td>TypeScriptBaseUrl</td> <td>파일 경로</td> </tr> <tr> <td><code>--charset</code></td> <td>TypeScriptCharset</td> <td></td> </tr> <tr> <td><code>--declaration</code></td> <td>TypeScriptGeneratesDeclarations</td> <td>boolean</td> </tr> <tr> <td><code>--declarationDir</code></td> <td>TypeScriptDeclarationDir</td> <td>파일 경로</td> </tr> <tr> <td><code>--diagnostics</code></td> <td><em>MSBuild에서 지원되지 않습니다</em></td> <td></td> </tr> <tr> <td><code>--disableSizeLimit</code></td> <td><em>MSBuild에서 지원되지 않습니다</em></td> <td></td> </tr> <tr> <td><code>--emitBOM</code></td> <td>TypeScriptEmitBOM</td> <td>boolean</td> </tr> <tr> <td><code>--emitDecoratorMetadata</code></td> <td>TypeScriptEmitDecoratorMetadata</td> <td>boolean</td> </tr> <tr> <td><code>--emitDeclarationOnly</code></td> <td>TypeScriptEmitDeclarationOnly</td> <td>boolean</td> </tr> <tr> <td><code>--esModuleInterop</code></td> <td>TypeScriptESModuleInterop</td> <td>boolean</td> </tr> <tr> <td><code>--experimentalAsyncFunctions</code></td> <td>TypeScriptExperimentalAsyncFunctions</td> <td>boolean</td> </tr> <tr> <td><code>--experimentalDecorators</code></td> <td>TypeScriptExperimentalDecorators</td> <td>boolean</td> </tr> <tr> <td><code>--forceConsistentCasingInFileNames</code></td> <td>TypeScriptForceConsistentCasingInFileNames</td> <td>boolean</td> </tr> <tr> <td><code>--help</code></td> <td><em>MSBuild에서 지원되지 않습니다</em></td> <td></td> </tr> <tr> <td><code>--importHelpers</code></td> <td>TypeScriptImportHelpers</td> <td>boolean</td> </tr> <tr> <td><code>--inlineSourceMap</code></td> <td>TypeScriptInlineSourceMap</td> <td>boolean</td> </tr> <tr> <td><code>--inlineSources</code></td> <td>TypeScriptInlineSources</td> <td>boolean</td> </tr> <tr> <td><code>--init</code></td> <td><em>MSBuild에서 지원되지 않습니다</em></td> <td></td> </tr> <tr> <td><code>--isolatedModules</code></td> <td>TypeScriptIsolatedModules</td> <td>boolean</td> </tr> <tr> <td><code>--jsx</code></td> <td>TypeScriptJSXEmit</td> <td>\n<code>React</code> 또는 <code>Preserve</code>\n</td> </tr> <tr> <td><code>--jsxFactory</code></td> <td>TypeScriptJSXFactory</td> <td>제한된 이름</td> </tr> <tr> <td><code>--lib</code></td> <td>TypeScriptLib</td> <td>쉼표로 구분된 문자열 목록</td> </tr> <tr> <td><code>--listEmittedFiles</code></td> <td><em>MSBuild에서 지원되지 않습니다</em></td> <td></td> </tr> <tr> <td><code>--listFiles</code></td> <td><em>MSBuild에서 지원되지 않습니다</em></td> <td></td> </tr> <tr> <td><code>--locale</code></td> <td><em>자동</em></td> <td>자동으로 PreferredUILang 값 설정</td> </tr> <tr> <td><code>--mapRoot</code></td> <td>TypeScriptMapRoot</td> <td>파일 경로</td> </tr> <tr> <td><code>--maxNodeModuleJsDepth</code></td> <td><em>MSBuild에서 지원되지 않습니다</em></td> <td></td> </tr> <tr> <td><code>--module</code></td> <td>TypeScriptModuleKind</td> <td>\n<code>AMD</code>, <code>CommonJs</code>, <code>UMD</code>, <code>System</code> or <code>ES6</code>\n</td> </tr> <tr> <td><code>--moduleResolution</code></td> <td>TypeScriptModuleResolution</td> <td>\n<code>Classic</code> 또는 <code>Node</code>\n</td> </tr> <tr> <td><code>--newLine</code></td> <td>TypeScriptNewLine</td> <td>\n<code>CRLF</code> 또는 <code>LF</code>\n</td> </tr> <tr> <td><code>--noEmit</code></td> <td><em>MSBuild에서 지원되지 않습니다</em></td> <td></td> </tr> <tr> <td><code>--noEmitHelpers</code></td> <td>TypeScriptNoEmitHelpers</td> <td>boolean</td> </tr> <tr> <td><code>--noEmitOnError</code></td> <td>TypeScriptNoEmitOnError</td> <td>boolean</td> </tr> <tr> <td><code>--noFallthroughCasesInSwitch</code></td> <td>TypeScriptNoFallthroughCasesInSwitch</td> <td>boolean</td> </tr> <tr> <td><code>--noImplicitAny</code></td> <td>TypeScriptNoImplicitAny</td> <td>boolean</td> </tr> <tr> <td><code>--noImplicitReturns</code></td> <td>TypeScriptNoImplicitReturns</td> <td>boolean</td> </tr> <tr> <td><code>--noImplicitThis</code></td> <td>TypeScriptNoImplicitThis</td> <td>boolean</td> </tr> <tr> <td><code>--noImplicitUseStrict</code></td> <td>TypeScriptNoImplicitUseStrict</td> <td>boolean</td> </tr> <tr> <td><code>--noStrictGenericChecks</code></td> <td>TypeScriptNoStrictGenericChecks</td> <td>boolean</td> </tr> <tr> <td><code>--noUnusedLocals</code></td> <td>TypeScriptNoUnusedLocals</td> <td>boolean</td> </tr> <tr> <td><code>--noUnusedParameters</code></td> <td>TypeScriptNoUnusedParameters</td> <td>boolean</td> </tr> <tr> <td><code>--noLib</code></td> <td>TypeScriptNoLib</td> <td>boolean</td> </tr> <tr> <td><code>--noResolve</code></td> <td>TypeScriptNoResolve</td> <td>boolean</td> </tr> <tr> <td><code>--out</code></td> <td>TypeScriptOutFile</td> <td>파일 경로</td> </tr> <tr> <td><code>--outDir</code></td> <td>TypeScriptOutDir</td> <td>파일 경로</td> </tr> <tr> <td><code>--outFile</code></td> <td>TypeScriptOutFile</td> <td>파일 경로</td> </tr> <tr> <td><code>--paths</code></td> <td><em>MSBuild에서 지원되지 않습니다</em></td> <td></td> </tr> <tr> <td><code>--preserveConstEnums</code></td> <td>TypeScriptPreserveConstEnums</td> <td>boolean</td> </tr> <tr> <td><code>--preserveSymlinks</code></td> <td>TypeScriptPreserveSymlinks</td> <td>boolean</td> </tr> <tr> <td><code>--listEmittedFiles</code></td> <td><em>MSBuild에서 지원되지 않습니다</em></td> <td></td> </tr> <tr> <td><code>--pretty</code></td> <td><em>MSBuild에서 지원되지 않습니다</em></td> <td></td> </tr> <tr> <td><code>--reactNamespace</code></td> <td>TypeScriptReactNamespace</td> <td>string</td> </tr> <tr> <td><code>--removeComments</code></td> <td>TypeScriptRemoveComments</td> <td>boolean</td> </tr> <tr> <td><code>--rootDir</code></td> <td>TypeScriptRootDir</td> <td>파일 경로</td> </tr> <tr> <td><code>--rootDirs</code></td> <td><em>MSBuild에서 지원되지 않습니다</em></td> <td></td> </tr> <tr> <td><code>--skipLibCheck</code></td> <td>TypeScriptSkipLibCheck</td> <td>boolean</td> </tr> <tr> <td><code>--skipDefaultLibCheck</code></td> <td>TypeScriptSkipDefaultLibCheck</td> <td>boolean</td> </tr> <tr> <td><code>--sourceMap</code></td> <td>TypeScriptSourceMap</td> <td>파일 경로</td> </tr> <tr> <td><code>--sourceRoot</code></td> <td>TypeScriptSourceRoot</td> <td>파일 경로</td> </tr> <tr> <td><code>--strict</code></td> <td>TypeScriptStrict</td> <td>boolean</td> </tr> <tr> <td><code>--strictFunctionTypes</code></td> <td>TypeScriptStrictFunctionTypes</td> <td>boolean</td> </tr> <tr> <td><code>--strictNullChecks</code></td> <td>TypeScriptStrictNullChecks</td> <td>boolean</td> </tr> <tr> <td><code>--strictPropertyInitialization</code></td> <td>TypeScriptStrictPropertyInitialization</td> <td>boolean</td> </tr> <tr> <td><code>--stripInternal</code></td> <td>TypeScriptStripInternal</td> <td>boolean</td> </tr> <tr> <td><code>--suppressExcessPropertyErrors</code></td> <td>TypeScriptSuppressExcessPropertyErrors</td> <td>boolean</td> </tr> <tr> <td><code>--suppressImplicitAnyIndexErrors</code></td> <td>TypeScriptSuppressImplicitAnyIndexErrors</td> <td>boolean</td> </tr> <tr> <td><code>--target</code></td> <td>TypeScriptTarget</td> <td>\n<code>ES3</code>, <code>ES5</code>, 또는 <code>ES6</code>\n</td> </tr> <tr> <td><code>--traceResolution</code></td> <td><em>MSBuild에서 지원되지 않습니다</em></td> <td></td> </tr> <tr> <td><code>--types</code></td> <td><em>MSBuild에서 지원되지 않습니다</em></td> <td></td> </tr> <tr> <td><code>--typeRoots</code></td> <td><em>MSBuild에서 지원되지 않습니다</em></td> <td></td> </tr> <tr> <td><code>--useDefineForClassFields</code></td> <td>TypeScriptUseDefineForClassFields</td> <td>boolean</td> </tr> <tr> <td><code>--watch</code></td> <td><em>MSBuild에서 지원되지 않습니다</em></td> <td></td> </tr> <tr> <td><em>MSBuild 전용 옵션</em></td> <td>TypeScriptAdditionalFlags</td> <td><em>모든 컴파일러 옵션</em></td> </tr> </tbody> </table> <h2 id=\"나의-visual-studio-버전에서-지원하는-것은-what-is-supported-in-my-version-of-visual-studio\" style=\"position:relative;\">나의 Visual Studio 버전에서 지원하는 것은? (What is supported in my version of Visual Studio?)</h2> <p><code>C:\\Program Files (x86)\\MSBuild\\Microsoft\\VisualStudio\\v$(VisualStudioVersion)\\TypeScript\\Microsoft.TypeScript.targets</code> 파일을 확인하세요.<br> MSBuild XML 태그와 <code>tsc</code> 컴파일러 옵션 사이의 신뢰할 수 있는 맵핑이 여기에 있습니다.</p> <h2 id=\"툴버전-toolsversion\" style=\"position:relative;\">툴버전 (ToolsVersion)</h2> <p>프로젝트 파일의 <code>&lt;TypeScriptToolsVersion&gt;1.7&lt;/TypeScriptToolsVersion&gt;</code> 프로퍼티 값은 빌드하는 데 사용할 컴파일러 버전을 식별합니다 (이 예제에서는 1.7).<br> 이렇게 하면 프로젝트가 다른 컴퓨터에 있는 동일한 버전의 컴파일러에 대한 빌드를 허용합니다.</p> <p>만약 <code>TypeScriptToolsVersion</code>이 지정되지 않으면, 설치된 최신 컴파일러 버전을 사용하여 빌드합니다.</p> <p>최신 버전의 TS를 사용하는 사용자에게는, 첫 로드 시 프로젝트를 업그레이드하라는 메시지가 표시됩니다.</p> <h2 id=\"typescriptcompileblocked\" style=\"position:relative;\">TypeScriptCompileBlocked</h2> <p>다른 빌드 도구를 사용하여 프로젝트 (예: gulp, grunt 등) 그리고 개발을 위한 VS와 디버깅 환경을 사용하는 경우 프로젝트에서 <code>&lt;TypeScriptCompileBlocked&gt;true&lt;/TypeScriptCompileBlocked&gt;</code>를 설정하세요. 이렇게 하면 모든 편집 지원이 제공되지만 F5키를 눌러도 빌드되지 않습니다.</p> <h2 id=\"typescriptenableincrementalmsbuild-typescript-42-beta-and-later\" style=\"position:relative;\">TypeScriptEnableIncrementalMSBuild (TypeScript 4.2 Beta and later)</h2> <p>By default, MSBuild will attempt to only run the TypeScript compiler when the project’s source files have been updated since the last compilation. However, if this behavior is causing issues, such as when TypeScript’s <code>incremental</code> option is enabled, set <code>&lt;TypeScriptEnableIncrementalMSBuild&gt;false&lt;/TypeScriptEnableIncrementalMSBuild&gt;</code> to ensure the TypeScript compiler is invoked with every run of MSBuild.</p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2012-2023 Microsoft<br>Licensed under the Apache License, Version 2.0.<br>\n    <a href=\"https://www.typescriptlang.org/ko/docs/handbook/compiler-options-in-msbuild.html\" class=\"_attribution-link\">https://www.typescriptlang.org/ko/docs/handbook/compiler-options-in-msbuild.html</a>\n  </p>\n</div>\n","compiler-options":"<h1>tsc CLI Options</h1>\n<h2 id=\"cli로-사용하기-using-the-cli\" style=\"position:relative;\">CLI로 사용하기 (Using the CLI)</h2> <p>로컬에서 <code>tsc</code>를 실행하면 <code>tsconfig.json</code>가 정의한 가장 가까운 프로젝트를 컴파일하고, 원하는 파일 glob을 전달하여 TypeScript 파일 집합을 컴파일할 수 있습니다.</p> <pre data-language=\"shell\"># tsconfig.json에 대한 fs를 역방향으로 검토하여 컴파일 실행\ntsc\n\n# 컴파일러 기본값으로 index.ts만 트랜스파일\ntsc index.ts\n\n# 기본 설정으로 src 폴더 안에 모든 .ts 파일을 트랜스파일\ntsc src/*.ts\n\n# tsconfig.json의 컴파일러 설정으로 src 폴더 안에 모든 .ts 파일을 트랜스파일\ntsc --project tsconfig.json src/*.ts</pre> <h2 id=\"컴파일러-옵션-compiler-options\" style=\"position:relative;\">컴파일러 옵션 (Compiler Options)</h2> <p>tsconfig의 컴파일러 옵션에 대한 더 많은 정보를 찾는다면, 베타 TSConfig 레퍼런스를 <a href=\"https://www.typescriptlang.org/v2/en/tsconfig\">v2 사이트</a>에서 확인하세요.</p> <table> <thead> <tr> <th>옵션</th> <th>타입</th> <th>기본값</th> <th>설명</th> </tr> </thead> <tbody> <tr> <td><code>--allowJs</code></td> <td><code>boolean</code></td> <td><code>false</code></td> <td>JavaScript 파일의 컴파일을 허용합니다</td> </tr> <tr> <td><code>--allowSyntheticDefaultImports</code></td> <td><code>boolean</code></td> <td>\n<code>module === \"system\"</code> 또는 <code>--esModuleInterop</code>\n</td> <td>default export가 없는 모듈에서 default imports를 허용합니다. 코드 방출에는 영향을 주지 않으며, 타입 검사만 수행합니다.</td> </tr> <tr> <td><code>--allowUmdGlobalAccess</code></td> <td><code>boolean</code></td> <td><code>false</code></td> <td>모듈에서 전역 UMD 접근을 허용합니다.</td> </tr> <tr> <td><code>--allowUnreachableCode</code></td> <td><code>boolean</code></td> <td><code>false</code></td> <td>도달할 수 없는 코드에 대한 오류를 보고하지 않습니다.</td> </tr> <tr> <td><code>--allowUnusedLabels</code></td> <td><code>boolean</code></td> <td><code>false</code></td> <td>사용되지 않는 레이블에 대한 오류를 보고하지 않습니다.</td> </tr> <tr> <td><code>--alwaysStrict</code></td> <td><code>boolean</code></td> <td><code>false</code></td> <td>strict mode에서 파싱하고 각 소스 파일에 대해 <code>\"use strict\"</code>를 내보냅니다.</td> </tr> <tr> <td><code>--assumeChangesOnlyAffectDirectDependencies</code></td> <td><code>boolean</code></td> <td><code>false</code></td> <td>파일 안에서의 변경은 파일이 직접 의존하는 파일에만 영향을 미친다고 가정하고 ‘—incremental’ 및 ‘-watch’로 다시 컴파일 합니다.</td> </tr> <tr> <td><code>--baseUrl</code></td> <td><code>string</code></td> <td></td> <td>비-상대적 모듈 이름을 해석하기 위한 기본 디렉터리. 자세한 내용은 <a href=\"module-resolution.md#base-url\">모듈 해석 문서</a>을 참조하세요.</td> </tr> <tr> <td>\n<code>--build</code><br><code>-b</code>\n</td> <td><code>boolean</code></td> <td><code>false</code></td> <td>\n<a href=\"project-references.md\">프로젝트 레퍼런스</a>에서 지정한 이 프로젝트와 프로젝트의 모든 의존성을 빌드 합니다. 이 플래그는 이 페이지의 다른 플래그들과는 호환되지 않음에 유의하세요 자세한 내용은 <a href=\"project-references.md\">여기</a>를 보세요.</td> </tr> <tr> <td><code>--charset</code></td> <td><code>string</code></td> <td><code>\"utf8\"</code></td> <td>입력 파일의 문자 집합입니다.</td> </tr> <tr> <td><code>--checkJs</code></td> <td><code>boolean</code></td> <td><code>false</code></td> <td>\n<code>.js</code> 파일에 오류를 보고합니다. <code>--allowJs</code>와 함께 사용하세요.</td> </tr> <tr> <td><code>--composite</code></td> <td><code>boolean</code></td> <td><code>true</code></td> <td>TypeScript가 프로젝트를 컴파일하기 위해 참조된 프로젝트의 출력을 찾을 위치를 결정할 수 있는지 확인합니다.</td> </tr> <tr> <td>\n<code>--declaration</code><br><code>-d</code>\n</td> <td><code>boolean</code></td> <td><code>false</code></td> <td>해당하는 <code>.d.ts</code> 파일을 생성합니다.</td> </tr> <tr> <td><code>--declarationDir</code></td> <td><code>string</code></td> <td></td> <td>생성된 선언 파일의 출력 디렉토리입니다.</td> </tr> <tr> <td><code>--declarationMap</code></td> <td><code>boolean</code></td> <td><code>false</code></td> <td>해당하는 ‘.d.ts’파일 각각에 대한 소스 맵을 생성합니다.</td> </tr> <tr> <td><code>--diagnostics</code></td> <td><code>boolean</code></td> <td><code>false</code></td> <td>진단 정보를 보여줍니다.</td> </tr> <tr> <td><code>--disableSizeLimit</code></td> <td><code>boolean</code></td> <td><code>false</code></td> <td>JavaScript 프로젝트의 사이즈 제한을 비활성화합니다.</td> </tr> <tr> <td><code>--downlevelIteration</code></td> <td><code>boolean</code></td> <td><code>false</code></td> <td>ES5 또는 ES3를 대상으로 할 때 <code>for..of</code>, 스프레드와 구조분해할당에서 이터러블을 완전히 지원합니다.</td> </tr> <tr> <td><code>--emitBOM</code></td> <td><code>boolean</code></td> <td><code>false</code></td> <td>출력 파일의 시작 부분에 UTF-8 바이트 순서표(BOM)를 내보냅니다.</td> </tr> <tr> <td><code>--emitDeclarationOnly</code></td> <td><code>boolean</code></td> <td><code>false</code></td> <td>‘.d.ts’ 선언 파일만 내보냅니다.</td> </tr> <tr> <td>\n<code>--emitDecoratorMetadata</code><sup>[1]</sup>\n</td> <td><code>boolean</code></td> <td><code>false</code></td> <td>소스에 데코레이터 선언에 대한 설계-타입 메타 데이터를 내보냅니다. 자세한 내용은 <a href=\"https://github.com/Microsoft/TypeScript/issues/2577\">#2577 이슈</a>을 참조하세요.</td> </tr> <tr> <td><code>--esModuleInterop</code></td> <td><code>boolean</code></td> <td><code>false</code></td> <td>런타임 바벨 생태계 호환성을 위한 <code>__importStar</code>와 <code>__importDefault</code> 헬퍼를 내보내고 타입 시스템 호환성을 위해 <code>--allowSyntheticDefaultImports</code>를 활성화합니다.</td> </tr> <tr> <td>\n<code>--experimentalDecorators</code><sup>[1]</sup>\n</td> <td><code>boolean</code></td> <td><code>false</code></td> <td>ES 데코레이터에 대한 실험적인 지원을 사용하도록 활성화합니다.</td> </tr> <tr> <td><code>--extendedDiagnostics</code></td> <td><code>boolean</code></td> <td><code>false</code></td> <td>자세한 진단 정보를 표시합니다</td> </tr> <tr> <td><code>--forceConsistentCasingInFileNames</code></td> <td><code>boolean</code></td> <td><code>false</code></td> <td>동일 파일 참조에 대해 일관성 없는 대소문자를 비활성화합니다.</td> </tr> <tr> <td><code>--generateCpuProfile</code></td> <td><code>string</code></td> <td><code>profile.cpuprofile</code></td> <td>주어진 경로에 cpu 프로필을 생성합니다. 파일 경로 대신 존재하는 디렉터리 이름을 전달하면 타임스탬프 이름이 지정된 프로필이 그 디렉터리에 대신 생성됩니다.</td> </tr> <tr> <td>\n<code>--help</code><br><code>-h</code>\n</td> <td></td> <td></td> <td>도움말을 출력합니다.</td> </tr> <tr> <td><code>--importHelpers</code></td> <td><code>boolean</code></td> <td><code>false</code></td> <td>\n<a href=\"https://www.npmjs.com/package/tslib\"><code>tslib</code></a>에서 방출된 헬퍼를 import 합니다. (예. <code>__extends</code>, <code>__rest</code>, 등..)</td> </tr> <tr> <td><code>--importsNotUsedAsValues</code></td> <td><code>string</code></td> <td><code>remove</code></td> <td>타입을 위해서만 사용하는 import를 위한 내보내기/검사 동작을 지정합니다. <code>\"remove\"</code>와 <code>\"preserve\"</code>는 사이드 이펙트를 위해 사용하지 않는 import를 내보낼지 지정하고, <code>\"error\"</code>는 타입을 위해서만 사용하는 import는 <code>import type</code>으로 작성하게 강제합니다.</td> </tr> <tr> <td><code>--incremental</code></td> <td><code>boolean</code></td> <td>\n<code>composite</code>이 켜져있으면 <code>true</code> 아니면 <code>false</code>\n</td> <td>이전 컴파일에서 디스크의 파일로 정보를 읽거나/기록하여 증분 컴파일을 활성화합니다. 이 파일은 <code>--tsBuildInfoFile</code> 플래그로 컨트롤합니다.</td> </tr> <tr> <td><code>--inlineSourceMap</code></td> <td><code>boolean</code></td> <td><code>false</code></td> <td>별도의 파일 대신 소스 맵으로 단일 파일을 내보냅니다.</td> </tr> <tr> <td><code>--inlineSources</code></td> <td><code>boolean</code></td> <td><code>false</code></td> <td>단일 파일 내에서 소스 맵과 함께 소스를 내보냅니다. <code>--inlineSourceMap</code> 또는 <code>--sourceMap</code>을 설정해야 합니다.</td> </tr> <tr> <td><code>--init</code></td> <td></td> <td></td> <td>TypeScript 프로젝트를 초기화하고 <code>tsconfig.json</code> 파일을 생성합니다.</td> </tr> <tr> <td><code>--isolatedModules</code></td> <td><code>boolean</code></td> <td><code>false</code></td> <td>추가 검사를 수행하여 별도의 컴파일 (예를 들어 <a href=\"https://github.com/Microsoft/TypeScript/wiki/Using-the-Compiler-API#a-simple-transform-function\"><code>트랜스파일된 모듈</code></a> 혹은 <a href=\"https://babeljs.io/docs/en/babel-plugin-transform-typescript\">@babel/plugin-transform-typescript</a>) 이 안전한지 확인합니다.</td> </tr> <tr> <td><code>--jsx</code></td> <td><code>string</code></td> <td><code>\"Preserve\"</code></td> <td>\n<code>.tsx</code> 파일에서 JSX 지원: <code>\"React\"</code>, <code>\"Preserve\"</code>, <code>\"react-native\"</code>. <a href=\"jsx.md\">JSX</a>를 확인하세요.</td> </tr> <tr> <td><code>--jsxFactory</code></td> <td><code>string</code></td> <td><code>\"React.createElement\"</code></td> <td>리액트 JSX 방출을 대상으로 할 때 사용할 JSX 팩토리 함수를 지정합니다. 예: <code>React.createElement</code> 또는 <code>h</code>.</td> </tr> <tr> <td><code>--keyofStringsOnly</code></td> <td><code>boolean</code></td> <td><code>false</code></td> <td>\n<code>keyof</code>를 문자열 값으로 된 프로퍼티 이름에만 적용합니다 (숫자나 심벌에서는 안됨).</td> </tr> <tr> <td><code>--useDefineForClassFields</code></td> <td><code>boolean</code></td> <td><code>false</code></td> <td>클래스 필드를 ECMAScript-표준 시맨틱으로 내보냅니다.</td> </tr> <tr> <td><code>--lib</code></td> <td><code>string[]</code></td> <td></td> <td>컴파일에 포함될 라이브러리 파일 목록입니다.<br>가능한 값은 다음과 같습니다: <br>► <code>ES5</code> <br>► <code>ES6</code> <br>► <code>ES2015</code> <br>► <code>ES7</code> <br>► <code>ES2016</code> <br>► <code>ES2017</code> <br>► <code>ES2018</code> <br>► <code>ESNext</code> <br>► <code>DOM</code> <br>► <code>DOM.Iterable</code> <br>► <code>WebWorker</code> <br>► <code>ScriptHost</code> <br>► <code>ES2015.Core</code> <br>► <code>ES2015.Collection</code> <br>► <code>ES2015.Generator</code> <br>► <code>ES2015.Iterable</code> <br>► <code>ES2015.Promise</code> <br>► <code>ES2015.Proxy</code> <br>► <code>ES2015.Reflect</code> <br>► <code>ES2015.Symbol</code> <br>► <code>ES2015.Symbol.WellKnown</code> <br>► <code>ES2016.Array.Include</code> <br>► <code>ES2017.object</code> <br>► <code>ES2017.Intl</code> <br>► <code>ES2017.SharedMemory</code> <br>► <code>ES2017.String</code> <br>► <code>ES2017.TypedArrays</code> <br>► <code>ES2018.Intl</code> <br>► <code>ES2018.Promise</code> <br>► <code>ES2018.RegExp</code> <br>► <code>ESNext.AsyncIterable</code> <br>► <code>ESNext.Array</code> <br>► <code>ESNext.Intl</code> <br>► <code>ESNext.Symbol</code> <br><br> 주의사항: <code>--lib</code>가 지정되지 않으면 라이브러리의 기본 리스트가 삽입됩니다. 주입되는 기본 라이브러리는 다음과 같습니다: <br> ► <code>--target ES5</code>: <code>DOM,ES5,ScriptHost</code><br> ► <code>--target ES6</code>: <code>DOM,ES6,DOM.Iterable,ScriptHost</code>\n</td> </tr> <tr> <td><code>--listEmittedFiles</code></td> <td><code>boolean</code></td> <td><code>false</code></td> <td>컴파일의 일부로 생성된 파일의 이름을 출력합니다.</td> </tr> <tr> <td><code>--listFiles</code></td> <td><code>boolean</code></td> <td><code>false</code></td> <td>컴파일에 포함된 파일의 이름을 출력합니다.</td> </tr> <tr> <td><code>--locale</code></td> <td><code>string</code></td> <td><em>(플랫폼 별)</em></td> <td>오류 메시지를 표시하는 데 사용할 지역화, 예: en-us. <br>가능한 값은 다음과 같습니다: <br>► 영어 (US): <code>en</code> <br>► 체코어: <code>cs</code> <br>► 독일어: <code>de</code> <br>► 스페인어: <code>es</code> <br>► 프랑스어: <code>fr</code> <br>► 이탈리아어: <code>it</code> <br>► 일본어: <code>ja</code> <br>► 한국어: <code>ko</code> <br>► 폴란드어: <code>pl</code> <br>► 포르투갈어(브라질): <code>pt-BR</code> <br>► 러시아어: <code>ru</code> <br>► 터키어: <code>tr</code> <br>► 중국어 간체: <code>zh-CN</code> <br>► 중국어 번체: <code>zh-TW</code>\n</td> </tr> <tr> <td><code>--mapRoot</code></td> <td><code>string</code></td> <td></td> <td>디버거가 생성된 위치가 아닌 맵 파일의 위치를 지정합니다. .map 파일이 .js 파일과 다른 위치에 런타임 시 위치할 경우 이 옵션을 사용하세요. 지정된 위치는 sourceMap에 포함되어 맵 파일이 위치할 디버거를 지정합니다. 이 플래그는 지정된 경로를 작성하지 않고 해당 위치에 맵 파일을 생성합니다. 대신 파일을 지정된 경로로 이동하는 빌드 후 단계를 작성하십시오.</td> </tr> <tr> <td><code>--maxNodeModuleJsDepth</code></td> <td><code>number</code></td> <td><code>0</code></td> <td>node_modules 및 로드 JavaScript 파일 아래에서 검색할 최대 의존성 깊이. <code>--allowJs</code>에만 적용됩니다.</td> </tr> <tr> <td>\n<code>--module</code><br><code>-m</code>\n</td> <td><code>string</code></td> <td><code>target === \"ES3\" or \"ES5\" ? \"CommonJS\" : \"ES6\"</code></td> <td>모듈 코드 생성 지정: <code>\"None\"</code>, <code>\"CommonJS\"</code>, <code>\"AMD\"</code>, <code>\"System\"</code>, <code>\"UMD\"</code>, <code>\"ES6\"</code>, <code>\"ES2015\"</code> 또는 <code>\"ESNext\"</code>.<br>► <code>\"AMD\"</code>와 <code>\"System\"</code>만 <code>--outFile</code>과 함께 사용할 수 있습니다.<br>► <code>\"ES6\"</code>와 <code>\"ES2015\"</code> 값은 <code>\"ES5\"</code> 또는 이하를 대상으로 할 때 사용할 수 있습니다.</td> </tr> <tr> <td><code>--moduleResolution</code></td> <td><code>string</code></td> <td><code>module === \"AMD\" or \"System\" or \"ES6\" ?  \"Classic\" : \"Node\"</code></td> <td>모듈 해석 방법 결정. Node.js/io.js 스타일 해석의 경우, <code>\"Node\"</code> 또는 <code>\"Classic\"</code> 중 하나입니다. 자세한 내용은 <a href=\"module-resolution.md\">모듈 해석 문서</a>를 참조하세요.</td> </tr> <tr> <td><code>--newLine</code></td> <td><code>string</code></td> <td><em>(플랫폼 별)</em></td> <td>파일을 내보낼 때 사용되는 지정된 라인 끝의 시퀀스 사용: <code>\"crlf\"</code> (윈도우) 또는 <code>\"lf\"</code> (유닉스).”</td> </tr> <tr> <td><code>--noEmit</code></td> <td><code>boolean</code></td> <td><code>false</code></td> <td>출력을 내보내지 않습니다.</td> </tr> <tr> <td><code>--noEmitHelpers</code></td> <td><code>boolean</code></td> <td><code>false</code></td> <td>컴파일된 출력에서는 <code>__extends</code>와 같은 커스텀 헬퍼 함수를 생성하지 않습니다.</td> </tr> <tr> <td><code>--noEmitOnError</code></td> <td><code>boolean</code></td> <td><code>false</code></td> <td>오류가 보고된 경우 출력을 내보내지 않습니다.</td> </tr> <tr> <td><code>--noErrorTruncation</code></td> <td><code>boolean</code></td> <td><code>false</code></td> <td>오류 메세지를 줄이지 않습니다.</td> </tr> <tr> <td><code>--noFallthroughCasesInSwitch</code></td> <td><code>boolean</code></td> <td><code>false</code></td> <td>스위치 문에 fallthrough 케이스에 대한 오류를 보고합니다.</td> </tr> <tr> <td><code>--noImplicitAny</code></td> <td><code>boolean</code></td> <td><code>false</code></td> <td>\n<code>any</code> 타입으로 암시한 표현식과 선언에 오류를 발생시킵니다.</td> </tr> <tr> <td><code>--noImplicitReturns</code></td> <td><code>boolean</code></td> <td><code>false</code></td> <td>함수의 모든 코드 경로에 반환값이 없을 때 오류를 보고합니다.</td> </tr> <tr> <td><code>--noImplicitThis</code></td> <td><code>boolean</code></td> <td><code>false</code></td> <td>\n<code>any</code> 타입으로 암시한 <code>this</code> 표현식에 오류를 보고합니다.</td> </tr> <tr> <td><code>--noImplicitUseStrict</code></td> <td><code>boolean</code></td> <td><code>false</code></td> <td>모듈 출력에 <code>\"use strict\"</code> 지시자를 내보내지 않습니다.</td> </tr> <tr> <td><code>--noLib</code></td> <td><code>boolean</code></td> <td><code>false</code></td> <td>기본 라이브러리 파일(<code>lib.d.ts</code>)은 포함하지 않습니다.</td> </tr> <tr> <td><code>--noResolve</code></td> <td><code>boolean</code></td> <td><code>false</code></td> <td>컴파일된 파일 목록에 트리플-슬래시 참조 또는 모듈 임포트 대상을 추가하지 않습니다.</td> </tr> <tr> <td><code>--noStrictGenericChecks</code></td> <td><code>boolean</code></td> <td><code>false</code></td> <td>함수 타입에서 제네릭 시그니처의 엄격한 검사를 비활성화합니다.</td> </tr> <tr> <td><code>--noUnusedLocals</code></td> <td><code>boolean</code></td> <td><code>false</code></td> <td>사용하지 않는 지역 변수에 대한 오류를 보고합니다.</td> </tr> <tr> <td><code>--noUnusedParameters</code></td> <td><code>boolean</code></td> <td><code>false</code></td> <td>사용하지 않는 매개 변수에 대한 오류를 보고합니다.</td> </tr> <tr> <td><del><code>--out</code></del></td> <td><code>string</code></td> <td></td> <td>더 이상 사용하지 않습니다. <code>--outFile</code>을 대신 사용합니다.</td> </tr> <tr> <td><code>--outDir</code></td> <td><code>string</code></td> <td></td> <td>출력 구조를 디렉토리로 리다이렉트합니다.</td> </tr> <tr> <td><code>--outFile</code></td> <td><code>string</code></td> <td></td> <td>출력을 단일 파일로 연결하여 방출합니다. 연결의 순서는 컴파일러에 전달된 파일 목록과 트리플-슬래시 참조 그리고 import와 함께 결정됩니다. 자세한 내용은 <a href=\"https://github.com/Microsoft/TypeScript/wiki/FAQ#how-do-i-control-file-ordering-in-combined-output---out-\">출력 파일 순서 문서</a>를 참조하세요.</td> </tr> <tr> <td>\n<code>paths</code><sup>[2]</sup>\n</td> <td><code>Object</code></td> <td></td> <td>\n<code>baseUrl</code>을 기준으로 관련된 위치에 모듈 이름의 경로 매핑 목록을 나열합니다. 자세한 내용은 <a href=\"module-resolution.md#path-mapping\">모듈 해석 문서</a>를 참조하세요.</td> </tr> <tr> <td><code>--preserveConstEnums</code></td> <td><code>boolean</code></td> <td><code>false</code></td> <td>생성된 코드에 const enum 선언을 지우지 않습니다. 자세한 내용은 <a href=\"https://github.com/Microsoft/TypeScript/blob/master/doc/spec.md#94-constant-enum-declarations\">const 열거형 문서</a>를 참조하세요.</td> </tr> <tr> <td><code>--preserveSymlinks</code></td> <td><code>boolean</code></td> <td><code>false</code></td> <td>symlinks를 실제 경로로 해석하지 않습니다. symlinked된 파일을 실제 파일처럼 다룹니다.</td> </tr> <tr> <td><code>--preserveWatchOutput</code></td> <td><code>boolean</code></td> <td><code>false</code></td> <td>스크린을 지우는 대신에 예전 콘솔 출력을 감시 모드로 남겨둡니다</td> </tr> <tr> <td><code>--pretty</code></td> <td><code>boolean</code></td> <td>다른 프로그램으로 파이프하거나 출력을 파일로 리다이렉션하지 않으면 <code>true</code>\n</td> <td>에러와 메시지를 색과 컨텍스트를 사용해서 스타일 지정합니다.</td> </tr> <tr> <td>\n<code>--project</code><br><code>-p</code>\n</td> <td><code>string</code></td> <td></td> <td>유효한 설정 파일이 지정된 프로젝트를 컴파일하세요.<br>이 인수는 유효한 JSON 설정 파일의 파일 경로일 수도 있고 <code>tsconfig.json</code> 파일이 포함된 디렉토리의 경로일 수도 있습니다.<br>자세한 내용은 <a href=\"https://www.typescriptlang.org/4d0ca8bfd95f86587ebed840833b3e52/tsconfig.json.md\">tsconfig.json</a>를 참조하세요.</td> </tr> <tr> <td><code>--reactNamespace</code></td> <td><code>string</code></td> <td><code>\"React\"</code></td> <td>더 이상 사용하지 않습니다. <code>--jsxFactory</code>를 대신 사용합니다.<br><code>\"react\"</code> JSX emit을 대상으로 할 때 <code>createElement</code>와 <code>__spread</code>에 호출된 객체를 지정합니다.</td> </tr> <tr> <td><code>--removeComments</code></td> <td><code>boolean</code></td> <td><code>false</code></td> <td>\n<code>/*!</code>로 시작하는 copy-right 헤더 주석을 제외한 모든 주석을 제거합니다.</td> </tr> <tr> <td><code>--resolveJsonModule</code></td> <td><code>boolean</code></td> <td><code>false</code></td> <td>\n<code>.json</code> 확장자로 import된 모듈을 포함합니다.</td> </tr> <tr> <td><code>--rootDir</code></td> <td><code>string</code></td> <td><em>(공통 루트 디렉토리는 input files 리스트에서 처리됩니다)</em></td> <td>입력 파일의 루트 디렉토리를 지정합니다. <code>--outDir</code>로 출력 디렉토리 구조를 제어하기 위해서만 사용합니다.</td> </tr> <tr> <td>\n<code>rootDirs</code><sup>[2]</sup>\n</td> <td><code>string[]</code></td> <td></td> <td>런타임 시 결합된 컨텐츠가 프로젝트의 구조를 나타내는 <i>루트</i> 폴더 목록입니다. 자세한 내용은 <a href=\"module-resolution.md#virtual-directories-with-rootdirs\">모듈 해석 문서</a>를 참조하세요.</td> </tr> <tr> <td><code>--showConfig</code></td> <td><code>boolean</code></td> <td><code>false</code></td> <td>다른 입력 옵션 및 구성 파일을 사용하여 빌드를 실제로 실행하는 대신 출력에 마지막 암시적 구성 파일을 표시하십시오.</td> </tr> <tr> <td><code>--skipDefaultLibCheck</code></td> <td><code>boolean</code></td> <td><code>false</code></td> <td>더 이상 사용하지 않습니다. <code>--skipLibCheck</code>를 대신 사용합니다.<br><a href=\"triple-slash-directives.md#-reference-no-default-libtrue\">기본 라이브러리 선언 파일</a>의 타입 검사를 건너뜁니다.</td> </tr> <tr> <td><code>--skipLibCheck</code></td> <td><code>boolean</code></td> <td><code>false</code></td> <td>모든 선언 파일(<code>*.d.ts</code>)의 타입 검사를 건너뜁니다.</td> </tr> <tr> <td><code>--sourceMap</code></td> <td><code>boolean</code></td> <td><code>false</code></td> <td>해당하는 <code>.map</code> 파일을 생성합니다.</td> </tr> <tr> <td><code>--sourceRoot</code></td> <td><code>string</code></td> <td></td> <td>디버거가 소스 위치 대신 TypeScript 파일을 찾아야 하는 위치를 지정합니다. 설계 시점에 소스가 아닌 런타임에 소스가 있는 경우 이 옵션을 사용하세요. 지정한 위치는 소스 파일이 위치할 디버깅 위치를 지정하기 위해 소스 맵에 포함됩니다.</td> </tr> <tr> <td><code>--strict</code></td> <td><code>boolean</code></td> <td><code>false</code></td> <td>모든 엄격한 타입 검사 옵션을 활성화합니다. <br><code>--strict</code>를 활성화하면 <code>--noImplicitAny</code>, <code>--noImplicitThis</code>, <code>--alwaysStrict</code>, <code>--strictNullChecks</code> 및 <code>--strictFunctionTypes</code>이 가능합니다.</td> </tr> <tr> <td><code>--strictBindCallApply</code></td> <td><code>boolean</code></td> <td><code>false</code></td> <td>함수에서 <code>bind</code>, <code>call</code> 그리고 <code>apply</code> 메서드의 더 엄격한 검사를 활성화합니다.</td> </tr> <tr> <td><code>--strictFunctionTypes</code></td> <td><code>boolean</code></td> <td><code>false</code></td> <td>함수 타입에 대한 bivariant 매개변수를 비활성화합니다.</td> </tr> <tr> <td><code>--strictPropertyInitialization</code></td> <td><code>boolean</code></td> <td><code>false</code></td> <td>undefined가 아닌 클래스 프로퍼티가 생성자에서 초기화 되도록 합니다. 이 옵션을 적용하려면 <code>--strictNullChecks</code>가 활성화되어야 합니다.</td> </tr> <tr> <td><code>--strictNullChecks</code></td> <td><code>boolean</code></td> <td><code>false</code></td> <td>엄격한 null 검사 모드에서는 <code>null</code>과 <code>undefined</code> 값이 모든 타입의 도메인에 있지 않고 그 자체와 <code>any</code>만 할당할 수 있습니다(한 가지 예외사항은 <code>undefined</code> 또한 <code>void</code>에 할당 가능하다는 것입니다).</td> </tr> <tr> <td><code>--suppressExcessPropertyErrors</code></td> <td><code>boolean</code></td> <td><code>false</code></td> <td>객체 리터럴에 대한 프로퍼티 초과 검사를 억제합니다.</td> </tr> <tr> <td><code>--suppressImplicitAnyIndexErrors</code></td> <td><code>boolean</code></td> <td><code>false</code></td> <td>인덱스 시그니처가 없는 객체를 인덱싱하는 경우 <code>--noImplicitAny</code> 억제합니다. 오류를 시그니처 자세한 내용은 <a href=\"https://github.com/Microsoft/TypeScript/issues/1232#issuecomment-64510362\">#1232 이슈</a>를 참조하세요.</td> </tr> <tr> <td>\n<code>--target</code><br><code>-t</code>\n</td> <td><code>string</code></td> <td><code>\"ES3\"</code></td> <td>ECMAScript 대상 버전 지정: <br>► <code>\"ES3\"</code> (기본 값) <br>► <code>\"ES5\"</code> <br>► <code>\"ES6\"</code>/<code>\"ES2015\"</code> <br>► <code>\"ES2016\"</code> <br>► <code>\"ES2017\"</code> <br>► <code>\"ES2018\"</code> <br>► <code>\"ES2019\"</code> <br>► <code>\"ES2020\"</code> <br>► <code>\"ESNext\"</code> <br><br> 주의사항: <code>\"ESNext\"</code>는 최신 <a href=\"https://github.com/tc39/proposals\">ES 제안 기능</a>을 대상으로 합니다.</td> </tr> <tr> <td><code>--traceResolution</code></td> <td><code>boolean</code></td> <td><code>false</code></td> <td>모듈 해석 로그 메세지를 보고합니다.</td> </tr> <tr> <td><code>--tsBuildInfoFile</code></td> <td><code>string</code></td> <td><code>.tsbuildinfo</code></td> <td>증분 빌드 정보를 저장할 파일을 지정합니다.</td> </tr> <tr> <td><code>--types</code></td> <td><code>string[]</code></td> <td></td> <td>타입 정의가 포함될 이름의 목록. 자세한 내용은 <a href=\"tsconfig.json.md#types-typeroots-and-types\">@types, —typeRoots 및 —types</a>를 참조하세요.</td> </tr> <tr> <td><code>--typeRoots</code></td> <td><code>string[]</code></td> <td></td> <td>타입 정의가 포함될 폴더의 목록. 자세한 내용은 <a href=\"tsconfig.json.md#types-typeroots-and-types\">@types, —typeRoots 및 —types</a>를 참조하세요.</td> </tr> <tr> <td>\n<code>--version</code><br><code>-v</code>\n</td> <td></td> <td></td> <td>컴파일러의 버전을 출력합니다.</td> </tr> <tr> <td>\n<code>--watch</code><br><code>-w</code>\n</td> <td></td> <td></td> <td>컴파일러를 감시 모드로 실행합니다. 입력 파일을 감시하여 변경 시 다시 컴파일합니다. 감시 파일과 디렉터리의 구현은 환경 변수를 사용하여 구성합니다. 더 자세한 내용은 <a href=\"configuring-watch.md\">감시 구성하기</a>를 보세요.</td> </tr> </tbody> </table> <ul> <li>\n<sup>[1]</sup> 이 옵션은 실험단계입니다.</li> <li>\n<sup>[2]</sup> 이 옵션은 <code>tsconfig.json</code>에서만 허용되며 커맨드 라인에서는 허용되지 않습니다.</li> </ul> <h2 id=\"관련사항-related\" style=\"position:relative;\">관련사항 (Related)</h2> <ul> <li>각 옵션에 대한 상세한 설명은 <a href=\"https://www.typescriptlang.org/tsconfig\">TSConfig 레퍼런스</a>에 있습니다.</li> <li>\n<a href=\"https://www.typescriptlang.org/docs/handbook/tsconfig-json.html\"><code>tsconfig.json</code></a> 파일에서 컴파일러 옵션 설정하기</li> <li>\n<a href=\"https://www.typescriptlang.org/docs/handbook/compiler-options-in-msbuild.html\">MSBuild projects</a> 프로젝트에서 컴파일러 옵션 설정하기</li> </ul> <h3>CLI Commands</h3> <table class=\"cli-option\" width=\"100%\"> <thead> <tr> <th>Flag</th> <th>Type</th> </tr> </thead> <tbody> <tr class=\"odd\" name=\"all\"> <td><code>--all</code></td> <td>\n<p><code>boolean</code></p> </td> </tr> <tr class=\"option-description odd\"><td colspan=\"3\"> <p>Show all compiler options.</p> </td></tr> <tr class=\"even\" name=\"generateTrace\"> <td><code>--generateTrace</code></td> <td>\n<p><code>string</code></p> </td> </tr> <tr class=\"option-description even\"><td colspan=\"3\"> <p>Generates an event trace and a list of types.</p> </td></tr> <tr class=\"odd\" name=\"help\"> <td><code>--help</code></td> <td>\n<p><code>boolean</code></p> </td> </tr> <tr class=\"option-description odd\"><td colspan=\"3\"> <p>Gives local information for help on the CLI.</p> </td></tr> <tr class=\"even\" name=\"init\"> <td><code>--init</code></td> <td>\n<p><code>boolean</code></p> </td> </tr> <tr class=\"option-description even\"><td colspan=\"3\"> <p>Initializes a TypeScript project and creates a tsconfig.json file.</p> </td></tr> <tr class=\"odd\" name=\"listFilesOnly\"> <td><code>--listFilesOnly</code></td> <td>\n<p><code>boolean</code></p> </td> </tr> <tr class=\"option-description odd\"><td colspan=\"3\"> <p>Print names of files that are part of the compilation and then stop processing.</p> </td></tr> <tr class=\"even\" name=\"locale\"> <td><code>--locale</code></td> <td>\n<p><code>string</code></p> </td> </tr> <tr class=\"option-description even\"><td colspan=\"3\"> <p>Set the language of the tsc output</p> </td></tr> <tr class=\"odd\" name=\"project\"> <td><code>--project</code></td> <td>\n<p><code>string</code></p> </td> </tr> <tr class=\"option-description odd\"><td colspan=\"3\"> <p>Compile the project given the path to its configuration file, or to a folder with a 'tsconfig.json'.</p> </td></tr> <tr class=\"even\" name=\"showConfig\"> <td><code>--showConfig</code></td> <td>\n<p><code>boolean</code></p> </td> </tr> <tr class=\"option-description even\"><td colspan=\"3\"> <p>Print the final configuration instead of building.</p> </td></tr> <tr class=\"odd\" name=\"version\"> <td><code>--version</code></td> <td>\n<p><code>boolean</code></p> </td> </tr> <tr class=\"option-description odd\"><td colspan=\"3\"> <p>Print the compiler's version.</p> </td></tr> </tbody>\n</table> <h3>Build Options</h3> <table class=\"cli-option\" width=\"100%\"> <thead> <tr> <th>Flag</th> <th>Type</th> </tr> </thead> <tbody> <tr class=\"odd\" name=\"build\"> <td><code>--build</code></td> <td>\n<p><code>boolean</code></p> </td> </tr> <tr class=\"option-description odd\"><td colspan=\"3\"> <p>Build one or more projects and their dependencies, if out of date</p> </td></tr> <tr class=\"even\" name=\"clean\"> <td><code>--clean</code></td> <td>\n<p><code>boolean</code></p> </td> </tr> <tr class=\"option-description even\"><td colspan=\"3\"> <p>Delete the outputs of all projects.</p> </td></tr> <tr class=\"odd\" name=\"dry\"> <td><code>--dry</code></td> <td>\n<p><code>boolean</code></p> </td> </tr> <tr class=\"option-description odd\"><td colspan=\"3\"> <p>Show what would be built (or deleted, if specified with '--clean')</p> </td></tr> <tr class=\"even\" name=\"force\"> <td><code><a href=\"https://www.typescriptlang.org/tsconfig/#force\">--force</a></code></td> <td>\n<p><code>boolean</code></p> </td> </tr> <tr class=\"option-description even\"><td colspan=\"3\"> <p>Build all projects, including those that appear to be up to date.</p> </td></tr> <tr class=\"odd\" name=\"verbose\"> <td><code><a href=\"https://www.typescriptlang.org/tsconfig/#verbose\">--verbose</a></code></td> <td>\n<p><code>boolean</code></p> </td> </tr> <tr class=\"option-description odd\"><td colspan=\"3\"> <p>Enable verbose logging.</p> </td></tr> </tbody>\n</table> <h3>Watch Options</h3> <table class=\"cli-option\" width=\"100%\"> <thead> <tr> <th>Flag</th> <th>Type</th> </tr> </thead> <tbody> <tr class=\"odd\" name=\"excludeDirectories\"> <td><code><a href=\"https://www.typescriptlang.org/tsconfig/#excludeDirectories\">--excludeDirectories</a></code></td> <td>\n<p><code>list</code></p> </td> </tr> <tr class=\"option-description odd\"><td colspan=\"3\"> <p>Remove a list of directories from the watch process.</p> </td></tr> <tr class=\"even\" name=\"excludeFiles\"> <td><code><a href=\"https://www.typescriptlang.org/tsconfig/#excludeFiles\">--excludeFiles</a></code></td> <td>\n<p><code>list</code></p> </td> </tr> <tr class=\"option-description even\"><td colspan=\"3\"> <p>Remove a list of files from the watch mode's processing.</p> </td></tr> <tr class=\"odd\" name=\"fallbackPolling\"> <td><code><a href=\"https://www.typescriptlang.org/tsconfig/#fallbackPolling\">--fallbackPolling</a></code></td> <td>\n<p><code>fixedinterval</code>, <code>priorityinterval</code>, <code>dynamicpriority</code> 또는 <code>fixedchunksize</code></p> </td> </tr> <tr class=\"option-description odd\"><td colspan=\"3\"> <p>Specify what approach the watcher should use if the system runs out of native file watchers.</p> </td></tr> <tr class=\"even\" name=\"synchronousWatchDirectory\"> <td><code><a href=\"https://www.typescriptlang.org/tsconfig/#synchronousWatchDirectory\">--synchronousWatchDirectory</a></code></td> <td>\n<p><code>boolean</code></p> </td> </tr> <tr class=\"option-description even\"><td colspan=\"3\"> <p>Synchronously call callbacks and update the state of directory watchers on platforms that don`t support recursive watching natively.</p> </td></tr> <tr class=\"odd\" name=\"watch\"> <td><code>--watch</code></td> <td>\n<p><code>boolean</code></p> </td> </tr> <tr class=\"option-description odd\"><td colspan=\"3\"> <p>Watch input files.</p> </td></tr> <tr class=\"even\" name=\"watchDirectory\"> <td><code><a href=\"https://www.typescriptlang.org/tsconfig/#watchDirectory\">--watchDirectory</a></code></td> <td>\n<p><code>usefsevents</code>, <code>fixedpollinginterval</code>, <code>dynamicprioritypolling</code> 또는 <code>fixedchunksizepolling</code></p> </td> </tr> <tr class=\"option-description even\"><td colspan=\"3\"> <p>Specify how directories are watched on systems that lack recursive file-watching functionality.</p> </td></tr> <tr class=\"odd\" name=\"watchFile\"> <td><code><a href=\"https://www.typescriptlang.org/tsconfig/#watchFile\">--watchFile</a></code></td> <td>\n<p><code>fixedpollinginterval</code>, <code>prioritypollinginterval</code>, <code>dynamicprioritypolling</code>, <code>fixedchunksizepolling</code>, <code>usefsevents</code> 또는 <code>usefseventsonparentdirectory</code></p> </td> </tr> <tr class=\"option-description odd\"><td colspan=\"3\"> <p>Specify how the TypeScript watch mode works.</p> </td></tr> </tbody>\n</table> <h3>Compiler Flags</h3> <table class=\"cli-option\" width=\"100%\"> <thead> <tr> <th>Flag</th> <th>Type</th> <th>Default</th> </tr> </thead> <tbody> <tr class=\"odd\" name=\"allowArbitraryExtensions\"> <td><code><a href=\"https://www.typescriptlang.org/tsconfig/#allowArbitraryExtensions\">--allowArbitraryExtensions</a></code></td> <td>\n<p><code>boolean</code></p> </td> <td>\n<p><code>false</code></p> </td> </tr> <tr class=\"option-description odd\"><td colspan=\"3\"> <p>Enable importing files with any extension, provided a declaration file is present.</p> </td></tr> <tr class=\"even\" name=\"allowImportingTsExtensions\"> <td><code><a href=\"https://www.typescriptlang.org/tsconfig/#allowImportingTsExtensions\">--allowImportingTsExtensions</a></code></td> <td>\n<p><code>boolean</code></p> </td> <td>\n<p><code>false</code></p> </td> </tr> <tr class=\"option-description even\"><td colspan=\"3\"> <p>Allow imports to include TypeScript file extensions.</p> </td></tr> <tr class=\"odd\" name=\"allowJs\"> <td><code><a href=\"https://www.typescriptlang.org/tsconfig/#allowJs\">--allowJs</a></code></td> <td>\n<p><code>boolean</code></p> </td> <td>\n<p><code>false</code></p> </td> </tr> <tr class=\"option-description odd\"><td colspan=\"3\"> <p>Allow JavaScript files to be a part of your program. Use the <code>checkJS</code> option to get errors from these files.</p> </td></tr> <tr class=\"even\" name=\"allowSyntheticDefaultImports\"> <td><code><a href=\"https://www.typescriptlang.org/tsconfig/#allowSyntheticDefaultImports\">--allowSyntheticDefaultImports</a></code></td> <td>\n<p><code>boolean</code></p> </td> <td>\n<p><code>true</code> if <a href=\"#esModuleInterop\"><code>esModuleInterop</code></a> is enabled, <a href=\"#module\"><code>module</code></a> is <code>system</code>, or <a href=\"#module-resolution\"><code>moduleResolution</code></a> is <code>bundler</code>; <code>false</code> otherwise.</p> </td> </tr> <tr class=\"option-description even\"><td colspan=\"3\"> <p>Allow 'import x from y' when a module doesn't have a default export.</p> </td></tr> <tr class=\"odd\" name=\"allowUmdGlobalAccess\"> <td><code><a href=\"https://www.typescriptlang.org/tsconfig/#allowUmdGlobalAccess\">--allowUmdGlobalAccess</a></code></td> <td>\n<p><code>boolean</code></p> </td> <td>\n<p><code>false</code></p> </td> </tr> <tr class=\"option-description odd\"><td colspan=\"3\"> <p>Allow accessing UMD globals from modules.</p> </td></tr> <tr class=\"even\" name=\"allowUnreachableCode\"> <td><code><a href=\"https://www.typescriptlang.org/tsconfig/#allowUnreachableCode\">--allowUnreachableCode</a></code></td> <td>\n<p><code>boolean</code></p> </td> <td> </td> </tr> <tr class=\"option-description even\"><td colspan=\"3\"> <p>Disable error reporting for unreachable code.</p> </td></tr> <tr class=\"odd\" name=\"allowUnusedLabels\"> <td><code><a href=\"https://www.typescriptlang.org/tsconfig/#allowUnusedLabels\">--allowUnusedLabels</a></code></td> <td>\n<p><code>boolean</code></p> </td> <td> </td> </tr> <tr class=\"option-description odd\"><td colspan=\"3\"> <p>Disable error reporting for unused labels.</p> </td></tr> <tr class=\"even\" name=\"alwaysStrict\"> <td><code><a href=\"https://www.typescriptlang.org/tsconfig/#alwaysStrict\">--alwaysStrict</a></code></td> <td>\n<p><code>boolean</code></p> </td> <td>\n<p><code>true</code> if <a href=\"#strict\"><code>strict</code></a>; <code>false</code> otherwise.</p> </td> </tr> <tr class=\"option-description even\"><td colspan=\"3\"> <p>Ensure 'use strict' is always emitted</p> </td></tr> <tr class=\"odd\" name=\"assumeChangesOnlyAffectDirectDependencies\"> <td><code><a href=\"https://www.typescriptlang.org/tsconfig/#assumeChangesOnlyAffectDirectDependencies\">--assumeChangesOnlyAffectDirectDependencies</a></code></td> <td>\n<p><code>boolean</code></p> </td> <td>\n<p><code>false</code></p> </td> </tr> <tr class=\"option-description odd\"><td colspan=\"3\"> <p>Have recompiles in projects that use <a href=\"#incremental\"><code>incremental</code></a> and <code>watch</code> mode assume that changes within a file will only affect files directly depending on it.</p> </td></tr> <tr class=\"even\" name=\"baseUrl\"> <td><code><a href=\"https://www.typescriptlang.org/tsconfig/#baseUrl\">--baseUrl</a></code></td> <td>\n<p><code>string</code></p> </td> <td> </td> </tr> <tr class=\"option-description even\"><td colspan=\"3\"> <p>Set a baseurl for relative module names</p> </td></tr> <tr class=\"odd\" name=\"charset\"> <td><code><a href=\"https://www.typescriptlang.org/tsconfig/#charset\">--charset</a></code></td> <td>\n<p><code>string</code></p> </td> <td>\n<p><code>utf8</code></p> </td> </tr> <tr class=\"option-description odd\"><td colspan=\"3\"> <p>Manually set the text encoding for reading files</p> </td></tr> <tr class=\"even\" name=\"checkJs\"> <td><code><a href=\"https://www.typescriptlang.org/tsconfig/#checkJs\">--checkJs</a></code></td> <td>\n<p><code>boolean</code></p> </td> <td>\n<p><code>false</code></p> </td> </tr> <tr class=\"option-description even\"><td colspan=\"3\"> <p>Enable error reporting in type-checked JavaScript files.</p> </td></tr> <tr class=\"odd\" name=\"composite\"> <td><code><a href=\"https://www.typescriptlang.org/tsconfig/#composite\">--composite</a></code></td> <td>\n<p><code>boolean</code></p> </td> <td>\n<p><code>false</code></p> </td> </tr> <tr class=\"option-description odd\"><td colspan=\"3\"> <p>Enable constraints that allow a TypeScript project to be used with project references.</p> </td></tr> <tr class=\"even\" name=\"customConditions\"> <td><code><a href=\"https://www.typescriptlang.org/tsconfig/#customConditions\">--customConditions</a></code></td> <td>\n<p><code>list</code></p> </td> <td> </td> </tr> <tr class=\"option-description even\"><td colspan=\"3\"> <p>Conditions to set in addition to the resolver-specific defaults when resolving imports.</p> </td></tr> <tr class=\"odd\" name=\"declaration\"> <td><code><a href=\"https://www.typescriptlang.org/tsconfig/#declaration\">--declaration</a></code></td> <td>\n<p><code>boolean</code></p> </td> <td>\n<p><code>true</code> if <a href=\"#composite\"><code>composite</code></a>; <code>false</code> otherwise.</p> </td> </tr> <tr class=\"option-description odd\"><td colspan=\"3\"> <p>Generates .d.ts files from TypeScript and JavaScript files in your project.</p> </td></tr> <tr class=\"even\" name=\"declarationDir\"> <td><code><a href=\"https://www.typescriptlang.org/tsconfig/#declarationDir\">--declarationDir</a></code></td> <td>\n<p><code>string</code></p> </td> <td> </td> </tr> <tr class=\"option-description even\"><td colspan=\"3\"> <p>Specify the output directory for generated declaration files.</p> </td></tr> <tr class=\"odd\" name=\"declarationMap\"> <td><code><a href=\"https://www.typescriptlang.org/tsconfig/#declarationMap\">--declarationMap</a></code></td> <td>\n<p><code>boolean</code></p> </td> <td>\n<p><code>false</code></p> </td> </tr> <tr class=\"option-description odd\"><td colspan=\"3\"> <p>Create sourcemaps for d.ts files.</p> </td></tr> <tr class=\"even\" name=\"diagnostics\"> <td><code><a href=\"https://www.typescriptlang.org/tsconfig/#diagnostics\">--diagnostics</a></code></td> <td>\n<p><code>boolean</code></p> </td> <td>\n<p><code>false</code></p> </td> </tr> <tr class=\"option-description even\"><td colspan=\"3\"> <p>Output compiler performance information after building.</p> </td></tr> <tr class=\"odd\" name=\"disableReferencedProjectLoad\"> <td><code><a href=\"https://www.typescriptlang.org/tsconfig/#disableReferencedProjectLoad\">--disableReferencedProjectLoad</a></code></td> <td>\n<p><code>boolean</code></p> </td> <td>\n<p><code>false</code></p> </td> </tr> <tr class=\"option-description odd\"><td colspan=\"3\"> <p>Reduce the number of projects loaded automatically by TypeScript.</p> </td></tr> <tr class=\"even\" name=\"disableSizeLimit\"> <td><code><a href=\"https://www.typescriptlang.org/tsconfig/#disableSizeLimit\">--disableSizeLimit</a></code></td> <td>\n<p><code>boolean</code></p> </td> <td>\n<p><code>false</code></p> </td> </tr> <tr class=\"option-description even\"><td colspan=\"3\"> <p>Remove the 20mb cap on total source code size for JavaScript files in the TypeScript language server.</p> </td></tr> <tr class=\"odd\" name=\"disableSolutionSearching\"> <td><code><a href=\"https://www.typescriptlang.org/tsconfig/#disableSolutionSearching\">--disableSolutionSearching</a></code></td> <td>\n<p><code>boolean</code></p> </td> <td>\n<p><code>false</code></p> </td> </tr> <tr class=\"option-description odd\"><td colspan=\"3\"> <p>Opt a project out of multi-project reference checking when editing.</p> </td></tr> <tr class=\"even\" name=\"disableSourceOfProjectReferenceRedirect\"> <td><code><a href=\"https://www.typescriptlang.org/tsconfig/#disableSourceOfProjectReferenceRedirect\">--disableSourceOfProjectReferenceRedirect</a></code></td> <td>\n<p><code>boolean</code></p> </td> <td>\n<p><code>false</code></p> </td> </tr> <tr class=\"option-description even\"><td colspan=\"3\"> <p>Disable preferring source files instead of declaration files when referencing composite projects.</p> </td></tr> <tr class=\"odd\" name=\"downlevelIteration\"> <td><code><a href=\"https://www.typescriptlang.org/tsconfig/#downlevelIteration\">--downlevelIteration</a></code></td> <td>\n<p><code>boolean</code></p> </td> <td>\n<p><code>false</code></p> </td> </tr> <tr class=\"option-description odd\"><td colspan=\"3\"> <p>Emit more compliant, but verbose and less performant JavaScript for iteration.</p> </td></tr> <tr class=\"even\" name=\"emitBOM\"> <td><code><a href=\"https://www.typescriptlang.org/tsconfig/#emitBOM\">--emitBOM</a></code></td> <td>\n<p><code>boolean</code></p> </td> <td>\n<p><code>false</code></p> </td> </tr> <tr class=\"option-description even\"><td colspan=\"3\"> <p>Emit a UTF-8 Byte Order Mark (BOM) in the beginning of output files.</p> </td></tr> <tr class=\"odd\" name=\"emitDeclarationOnly\"> <td><code><a href=\"https://www.typescriptlang.org/tsconfig/#emitDeclarationOnly\">--emitDeclarationOnly</a></code></td> <td>\n<p><code>boolean</code></p> </td> <td>\n<p><code>false</code></p> </td> </tr> <tr class=\"option-description odd\"><td colspan=\"3\"> <p>Only output d.ts files and not JavaScript files.</p> </td></tr> <tr class=\"even\" name=\"emitDecoratorMetadata\"> <td><code><a href=\"https://www.typescriptlang.org/tsconfig/#emitDecoratorMetadata\">--emitDecoratorMetadata</a></code></td> <td>\n<p><code>boolean</code></p> </td> <td>\n<p><code>false</code></p> </td> </tr> <tr class=\"option-description even\"><td colspan=\"3\"> <p>Emit design-type metadata for decorated declarations in source files.</p> </td></tr> <tr class=\"odd\" name=\"esModuleInterop\"> <td><code><a href=\"https://www.typescriptlang.org/tsconfig/#esModuleInterop\">--esModuleInterop</a></code></td> <td>\n<p><code>boolean</code></p> </td> <td>\n<p><code>true</code> if <a href=\"#module\"><code>module</code></a> is <code>node16</code> or <code>nodenext</code>; <code>false</code> otherwise.</p> </td> </tr> <tr class=\"option-description odd\"><td colspan=\"3\"> <p>Emit additional JavaScript to ease support for importing CommonJS modules. This enables <a href=\"#allowSyntheticDefaultImports\"><code>allowSyntheticDefaultImports</code></a> for type compatibility.</p> </td></tr> <tr class=\"even\" name=\"exactOptionalPropertyTypes\"> <td><code><a href=\"https://www.typescriptlang.org/tsconfig/#exactOptionalPropertyTypes\">--exactOptionalPropertyTypes</a></code></td> <td>\n<p><code>boolean</code></p> </td> <td>\n<p><code>false</code></p> </td> </tr> <tr class=\"option-description even\"><td colspan=\"3\"> <p>Interpret optional property types as written, rather than adding <code>undefined</code>.</p> </td></tr> <tr class=\"odd\" name=\"experimentalDecorators\"> <td><code><a href=\"https://www.typescriptlang.org/tsconfig/#experimentalDecorators\">--experimentalDecorators</a></code></td> <td>\n<p><code>boolean</code></p> </td> <td>\n<p><code>false</code></p> </td> </tr> <tr class=\"option-description odd\"><td colspan=\"3\"> <p>Enable experimental support for TC39 stage 2 draft decorators.</p> </td></tr> <tr class=\"even\" name=\"explainFiles\"> <td><code><a href=\"https://www.typescriptlang.org/tsconfig/#explainFiles\">--explainFiles</a></code></td> <td>\n<p><code>boolean</code></p> </td> <td>\n<p><code>false</code></p> </td> </tr> <tr class=\"option-description even\"><td colspan=\"3\"> <p>Print files read during the compilation including why it was included.</p> </td></tr> <tr class=\"odd\" name=\"extendedDiagnostics\"> <td><code><a href=\"https://www.typescriptlang.org/tsconfig/#extendedDiagnostics\">--extendedDiagnostics</a></code></td> <td>\n<p><code>boolean</code></p> </td> <td>\n<p><code>false</code></p> </td> </tr> <tr class=\"option-description odd\"><td colspan=\"3\"> <p>Output more detailed compiler performance information after building.</p> </td></tr> <tr class=\"even\" name=\"forceConsistentCasingInFileNames\"> <td><code><a href=\"https://www.typescriptlang.org/tsconfig/#forceConsistentCasingInFileNames\">--forceConsistentCasingInFileNames</a></code></td> <td>\n<p><code>boolean</code></p> </td> <td>\n<p><code>true</code></p> </td> </tr> <tr class=\"option-description even\"><td colspan=\"3\"> <p>Ensure that casing is correct in imports.</p> </td></tr> <tr class=\"odd\" name=\"generateCpuProfile\"> <td><code><a href=\"https://www.typescriptlang.org/tsconfig/#generateCpuProfile\">--generateCpuProfile</a></code></td> <td>\n<p><code>string</code></p> </td> <td>\n<p><code>profile.cpuprofile</code></p> </td> </tr> <tr class=\"option-description odd\"><td colspan=\"3\"> <p>Emit a v8 CPU profile of the compiler run for debugging.</p> </td></tr> <tr class=\"even\" name=\"importHelpers\"> <td><code><a href=\"https://www.typescriptlang.org/tsconfig/#importHelpers\">--importHelpers</a></code></td> <td>\n<p><code>boolean</code></p> </td> <td>\n<p><code>false</code></p> </td> </tr> <tr class=\"option-description even\"><td colspan=\"3\"> <p>Allow importing helper functions from tslib once per project, instead of including them per-file.</p> </td></tr> <tr class=\"odd\" name=\"importsNotUsedAsValues\"> <td><code><a href=\"https://www.typescriptlang.org/tsconfig/#importsNotUsedAsValues\">--importsNotUsedAsValues</a></code></td> <td>\n<p><code>remove</code>, <code>preserve</code> 또는 <code>error</code></p> </td> <td>\n<p><code>remove</code></p> </td> </tr> <tr class=\"option-description odd\"><td colspan=\"3\"> <p>Specify emit/checking behavior for imports that are only used for types.</p> </td></tr> <tr class=\"even\" name=\"incremental\"> <td><code><a href=\"https://www.typescriptlang.org/tsconfig/#incremental\">--incremental</a></code></td> <td>\n<p><code>boolean</code></p> </td> <td>\n<p><code>true</code> if <a href=\"#composite\"><code>composite</code></a>; <code>false</code> otherwise.</p> </td> </tr> <tr class=\"option-description even\"><td colspan=\"3\"> <p>Save .tsbuildinfo files to allow for incremental compilation of projects.</p> </td></tr> <tr class=\"odd\" name=\"inlineSourceMap\"> <td><code><a href=\"https://www.typescriptlang.org/tsconfig/#inlineSourceMap\">--inlineSourceMap</a></code></td> <td>\n<p><code>boolean</code></p> </td> <td>\n<p><code>false</code></p> </td> </tr> <tr class=\"option-description odd\"><td colspan=\"3\"> <p>Include sourcemap files inside the emitted JavaScript.</p> </td></tr> <tr class=\"even\" name=\"inlineSources\"> <td><code><a href=\"https://www.typescriptlang.org/tsconfig/#inlineSources\">--inlineSources</a></code></td> <td>\n<p><code>boolean</code></p> </td> <td>\n<p><code>false</code></p> </td> </tr> <tr class=\"option-description even\"><td colspan=\"3\"> <p>Include source code in the sourcemaps inside the emitted JavaScript.</p> </td></tr> <tr class=\"odd\" name=\"isolatedModules\"> <td><code><a href=\"https://www.typescriptlang.org/tsconfig/#isolatedModules\">--isolatedModules</a></code></td> <td>\n<p><code>boolean</code></p> </td> <td>\n<p><code>false</code></p> </td> </tr> <tr class=\"option-description odd\"><td colspan=\"3\"> <p>Ensure that each file can be safely transpiled without relying on other imports.</p> </td></tr> <tr class=\"even\" name=\"jsx\"> <td><code><a href=\"https://www.typescriptlang.org/tsconfig/#jsx\">--jsx</a></code></td> <td>\n<p><code>preserve</code>, <code>react</code>, <code>react-native</code>, <code>react-jsx</code> 또는 <code>react-jsxdev</code></p> </td> <td> </td> </tr> <tr class=\"option-description even\"><td colspan=\"3\"> <p>Specify what JSX code is generated.</p> </td></tr> <tr class=\"odd\" name=\"jsxFactory\"> <td><code><a href=\"https://www.typescriptlang.org/tsconfig/#jsxFactory\">--jsxFactory</a></code></td> <td>\n<p><code>string</code></p> </td> <td>\n<p><code>React.createElement</code></p> </td> </tr> <tr class=\"option-description odd\"><td colspan=\"3\"> <p>Specify the JSX factory function used when targeting React JSX emit, e.g. 'React.createElement' or 'h'.</p> </td></tr> <tr class=\"even\" name=\"jsxFragmentFactory\"> <td><code><a href=\"https://www.typescriptlang.org/tsconfig/#jsxFragmentFactory\">--jsxFragmentFactory</a></code></td> <td>\n<p><code>string</code></p> </td> <td>\n<p><code>React.Fragment</code></p> </td> </tr> <tr class=\"option-description even\"><td colspan=\"3\"> <p>Specify the JSX Fragment reference to use for fragements when targeting React JSX emit, e.g. 'React.Fragment' or 'Fragment'.</p> </td></tr> <tr class=\"odd\" name=\"jsxImportSource\"> <td><code><a href=\"https://www.typescriptlang.org/tsconfig/#jsxImportSource\">--jsxImportSource</a></code></td> <td>\n<p><code>string</code></p> </td> <td>\n<p><code>react</code></p> </td> </tr> <tr class=\"option-description odd\"><td colspan=\"3\"> <p>Specify module specifier used to import the JSX factory functions when using <code>jsx: react-jsx*</code>.`</p> </td></tr> <tr class=\"even\" name=\"keyofStringsOnly\"> <td><code><a href=\"https://www.typescriptlang.org/tsconfig/#keyofStringsOnly\">--keyofStringsOnly</a></code></td> <td>\n<p><code>boolean</code></p> </td> <td>\n<p><code>false</code></p> </td> </tr> <tr class=\"option-description even\"><td colspan=\"3\"> <p>Make keyof only return strings instead of string, numbers or symbols. Legacy option.</p> </td></tr> <tr class=\"odd\" name=\"lib\"> <td><code><a href=\"https://www.typescriptlang.org/tsconfig/#lib\">--lib</a></code></td> <td>\n<p><code>list</code></p> </td> <td> </td> </tr> <tr class=\"option-description odd\"><td colspan=\"3\"> <p>A list of bundled library declaration files which describe the target runtime environment.</p> </td></tr> <tr class=\"even\" name=\"listEmittedFiles\"> <td><code><a href=\"https://www.typescriptlang.org/tsconfig/#listEmittedFiles\">--listEmittedFiles</a></code></td> <td>\n<p><code>boolean</code></p> </td> <td>\n<p><code>false</code></p> </td> </tr> <tr class=\"option-description even\"><td colspan=\"3\"> <p>Print the names of emitted files after a compilation.</p> </td></tr> <tr class=\"odd\" name=\"listFiles\"> <td><code><a href=\"https://www.typescriptlang.org/tsconfig/#listFiles\">--listFiles</a></code></td> <td>\n<p><code>boolean</code></p> </td> <td>\n<p><code>false</code></p> </td> </tr> <tr class=\"option-description odd\"><td colspan=\"3\"> <p>Print all of the files read during the compilation.</p> </td></tr> <tr class=\"even\" name=\"mapRoot\"> <td><code><a href=\"https://www.typescriptlang.org/tsconfig/#mapRoot\">--mapRoot</a></code></td> <td>\n<p><code>string</code></p> </td> <td> </td> </tr> <tr class=\"option-description even\"><td colspan=\"3\"> <p>Specify the location where debugger should locate map files instead of generated locations.</p> </td></tr> <tr class=\"odd\" name=\"maxNodeModuleJsDepth\"> <td><code><a href=\"https://www.typescriptlang.org/tsconfig/#maxNodeModuleJsDepth\">--maxNodeModuleJsDepth</a></code></td> <td>\n<p><code>number</code></p> </td> <td>\n<p><code>0</code></p> </td> </tr> <tr class=\"option-description odd\"><td colspan=\"3\"> <p>Specify the maximum folder depth used for checking JavaScript files from <code>node_modules</code>. Only applicable with <a href=\"#allowJs\"><code>allowJs</code></a>.</p> </td></tr> <tr class=\"even\" name=\"module\"> <td><code><a href=\"https://www.typescriptlang.org/tsconfig/#module\">--module</a></code></td> <td>\n<p><code>none</code>, <code>commonjs</code>, <code>amd</code>, <code>umd</code>, <code>system</code>, <code>es6</code>/<code>es2015</code>, <code>es2020</code>, <code>es2022</code>, <code>esnext</code>, <code>node16</code> 또는 <code>nodenext</code></p> </td> <td>\n<p><code>CommonJS</code> if <a href=\"#target\"><code>target</code></a> is <code>ES3</code> or <code>ES5</code>; <code>ES6</code>/<code>ES2015</code> otherwise.</p> </td> </tr> <tr class=\"option-description even\"><td colspan=\"3\"> <p>Specify what module code is generated.</p> </td></tr> <tr class=\"odd\" name=\"moduleDetection\"> <td><code><a href=\"https://www.typescriptlang.org/tsconfig/#moduleDetection\">--moduleDetection</a></code></td> <td>\n<p><code>legacy</code>, <code>auto</code> 또는 <code>force</code></p> </td> <td>\n<p>\"auto\": Treat files with imports, exports, import.meta, jsx (with jsx: react-jsx), or esm format (with module: node16+) as modules.</p> </td> </tr> <tr class=\"option-description odd\"><td colspan=\"3\"> <p>Specify what method is used to detect whether a file is a script or a module.</p> </td></tr> <tr class=\"even\" name=\"moduleResolution\"> <td><code><a href=\"https://www.typescriptlang.org/tsconfig/#moduleResolution\">--moduleResolution</a></code></td> <td>\n<p><code>classic</code>, <code>node10</code>/<code>node</code>, <code>node16</code>, <code>nodenext</code> 또는 <code>bundler</code></p> </td> <td>\n<p><code>Classic</code> if <a href=\"#module\"><code>module</code></a> is <code>AMD</code>, <code>UMD</code>, <code>System</code>, or <code>ES6</code>/<code>ES2015</code>; Matches if <a href=\"#module\"><code>module</code></a> is <code>node16</code> or <code>nodenext</code>; <code>Node</code> otherwise.</p> </td> </tr> <tr class=\"option-description even\"><td colspan=\"3\"> <p>Specify how TypeScript looks up a file from a given module specifier.</p> </td></tr> <tr class=\"odd\" name=\"moduleSuffixes\"> <td><code><a href=\"https://www.typescriptlang.org/tsconfig/#moduleSuffixes\">--moduleSuffixes</a></code></td> <td>\n<p><code>list</code></p> </td> <td> </td> </tr> <tr class=\"option-description odd\"><td colspan=\"3\"> <p>List of file name suffixes to search when resolving a module.</p> </td></tr> <tr class=\"even\" name=\"newLine\"> <td><code><a href=\"https://www.typescriptlang.org/tsconfig/#newLine\">--newLine</a></code></td> <td>\n<p><code>crlf</code> 또는 <code>lf</code></p> </td> <td>\n<p>Platform specific.</p> </td> </tr> <tr class=\"option-description even\"><td colspan=\"3\"> <p>Set the newline character</p> </td></tr> <tr class=\"odd\" name=\"noEmit\"> <td><code><a href=\"https://www.typescriptlang.org/tsconfig/#noEmit\">--noEmit</a></code></td> <td>\n<p><code>boolean</code></p> </td> <td>\n<p><code>false</code></p> </td> </tr> <tr class=\"option-description odd\"><td colspan=\"3\"> <p>Disable emitting files from a compilation.</p> </td></tr> <tr class=\"even\" name=\"noEmitHelpers\"> <td><code><a href=\"https://www.typescriptlang.org/tsconfig/#noEmitHelpers\">--noEmitHelpers</a></code></td> <td>\n<p><code>boolean</code></p> </td> <td>\n<p><code>false</code></p> </td> </tr> <tr class=\"option-description even\"><td colspan=\"3\"> <p>Disable generating custom helper functions like <code>__extends</code> in compiled output.</p> </td></tr> <tr class=\"odd\" name=\"noEmitOnError\"> <td><code><a href=\"https://www.typescriptlang.org/tsconfig/#noEmitOnError\">--noEmitOnError</a></code></td> <td>\n<p><code>boolean</code></p> </td> <td>\n<p><code>false</code></p> </td> </tr> <tr class=\"option-description odd\"><td colspan=\"3\"> <p>Disable emitting files if any type checking errors are reported.</p> </td></tr> <tr class=\"even\" name=\"noErrorTruncation\"> <td><code><a href=\"https://www.typescriptlang.org/tsconfig/#noErrorTruncation\">--noErrorTruncation</a></code></td> <td>\n<p><code>boolean</code></p> </td> <td>\n<p><code>false</code></p> </td> </tr> <tr class=\"option-description even\"><td colspan=\"3\"> <p>Disable truncating types in error messages.</p> </td></tr> <tr class=\"odd\" name=\"noFallthroughCasesInSwitch\"> <td><code><a href=\"https://www.typescriptlang.org/tsconfig/#noFallthroughCasesInSwitch\">--noFallthroughCasesInSwitch</a></code></td> <td>\n<p><code>boolean</code></p> </td> <td>\n<p><code>false</code></p> </td> </tr> <tr class=\"option-description odd\"><td colspan=\"3\"> <p>Enable error reporting for fallthrough cases in switch statements.</p> </td></tr> <tr class=\"even\" name=\"noImplicitAny\"> <td><code><a href=\"https://www.typescriptlang.org/tsconfig/#noImplicitAny\">--noImplicitAny</a></code></td> <td>\n<p><code>boolean</code></p> </td> <td>\n<p><code>true</code> if <a href=\"#strict\"><code>strict</code></a>; <code>false</code> otherwise.</p> </td> </tr> <tr class=\"option-description even\"><td colspan=\"3\"> <p>Avoid introducing anys inside your codebase when a type could be specified</p> </td></tr> <tr class=\"odd\" name=\"noImplicitOverride\"> <td><code><a href=\"https://www.typescriptlang.org/tsconfig/#noImplicitOverride\">--noImplicitOverride</a></code></td> <td>\n<p><code>boolean</code></p> </td> <td>\n<p><code>false</code></p> </td> </tr> <tr class=\"option-description odd\"><td colspan=\"3\"> <p>Ensure overriding members in derived classes are marked with an override modifier.</p> </td></tr> <tr class=\"even\" name=\"noImplicitReturns\"> <td><code><a href=\"https://www.typescriptlang.org/tsconfig/#noImplicitReturns\">--noImplicitReturns</a></code></td> <td>\n<p><code>boolean</code></p> </td> <td>\n<p><code>false</code></p> </td> </tr> <tr class=\"option-description even\"><td colspan=\"3\"> <p>Enable error reporting for codepaths that do not explicitly return in a function.</p> </td></tr> <tr class=\"odd\" name=\"noImplicitThis\"> <td><code><a href=\"https://www.typescriptlang.org/tsconfig/#noImplicitThis\">--noImplicitThis</a></code></td> <td>\n<p><code>boolean</code></p> </td> <td>\n<p><code>true</code> if <a href=\"#strict\"><code>strict</code></a>; <code>false</code> otherwise.</p> </td> </tr> <tr class=\"option-description odd\"><td colspan=\"3\"> <p>Enable error reporting when <code>this</code> is given the type <code>any</code>.</p> </td></tr> <tr class=\"even\" name=\"noImplicitUseStrict\"> <td><code><a href=\"https://www.typescriptlang.org/tsconfig/#noImplicitUseStrict\">--noImplicitUseStrict</a></code></td> <td>\n<p><code>boolean</code></p> </td> <td>\n<p><code>false</code></p> </td> </tr> <tr class=\"option-description even\"><td colspan=\"3\"> <p>Disable adding 'use strict' directives in emitted JavaScript files.</p> </td></tr> <tr class=\"odd\" name=\"noLib\"> <td><code><a href=\"https://www.typescriptlang.org/tsconfig/#noLib\">--noLib</a></code></td> <td>\n<p><code>boolean</code></p> </td> <td>\n<p><code>false</code></p> </td> </tr> <tr class=\"option-description odd\"><td colspan=\"3\"> <p>Disable including any library files, including the default lib.d.ts.</p> </td></tr> <tr class=\"even\" name=\"noPropertyAccessFromIndexSignature\"> <td><code><a href=\"https://www.typescriptlang.org/tsconfig/#noPropertyAccessFromIndexSignature\">--noPropertyAccessFromIndexSignature</a></code></td> <td>\n<p><code>boolean</code></p> </td> <td>\n<p><code>false</code></p> </td> </tr> <tr class=\"option-description even\"><td colspan=\"3\"> <p>Enforces using indexed accessors for keys declared using an indexed type.</p> </td></tr> <tr class=\"odd\" name=\"noResolve\"> <td><code><a href=\"https://www.typescriptlang.org/tsconfig/#noResolve\">--noResolve</a></code></td> <td>\n<p><code>boolean</code></p> </td> <td>\n<p><code>false</code></p> </td> </tr> <tr class=\"option-description odd\"><td colspan=\"3\"> <p>Disallow <code>import</code>s, <code>require</code>s or <code>&lt;reference&gt;</code>s from expanding the number of files TypeScript should add to a project.</p> </td></tr> <tr class=\"even\" name=\"noStrictGenericChecks\"> <td><code><a href=\"https://www.typescriptlang.org/tsconfig/#noStrictGenericChecks\">--noStrictGenericChecks</a></code></td> <td>\n<p><code>boolean</code></p> </td> <td>\n<p><code>false</code></p> </td> </tr> <tr class=\"option-description even\"><td colspan=\"3\"> <p>Disable strict checking of generic signatures in function types.</p> </td></tr> <tr class=\"odd\" name=\"noUncheckedIndexedAccess\"> <td><code><a href=\"https://www.typescriptlang.org/tsconfig/#noUncheckedIndexedAccess\">--noUncheckedIndexedAccess</a></code></td> <td>\n<p><code>boolean</code></p> </td> <td>\n<p><code>false</code></p> </td> </tr> <tr class=\"option-description odd\"><td colspan=\"3\"> <p>Add <code>undefined</code> to a type when accessed using an index.</p> </td></tr> <tr class=\"even\" name=\"noUnusedLocals\"> <td><code><a href=\"https://www.typescriptlang.org/tsconfig/#noUnusedLocals\">--noUnusedLocals</a></code></td> <td>\n<p><code>boolean</code></p> </td> <td>\n<p><code>false</code></p> </td> </tr> <tr class=\"option-description even\"><td colspan=\"3\"> <p>Enable error reporting when local variables aren't read.</p> </td></tr> <tr class=\"odd\" name=\"noUnusedParameters\"> <td><code><a href=\"https://www.typescriptlang.org/tsconfig/#noUnusedParameters\">--noUnusedParameters</a></code></td> <td>\n<p><code>boolean</code></p> </td> <td>\n<p><code>false</code></p> </td> </tr> <tr class=\"option-description odd\"><td colspan=\"3\"> <p>Raise an error when a function parameter isn't read.</p> </td></tr> <tr class=\"even\" name=\"out\"> <td><code><a href=\"https://www.typescriptlang.org/tsconfig/#out\">--out</a></code></td> <td>\n<p><code>string</code></p> </td> <td> </td> </tr> <tr class=\"option-description even\"><td colspan=\"3\"> <p>Deprecated setting. Use <code>outFile</code> instead.</p> </td></tr> <tr class=\"odd\" name=\"outDir\"> <td><code><a href=\"https://www.typescriptlang.org/tsconfig/#outDir\">--outDir</a></code></td> <td>\n<p><code>string</code></p> </td> <td> </td> </tr> <tr class=\"option-description odd\"><td colspan=\"3\"> <p>Specify an output folder for all emitted files.</p> </td></tr> <tr class=\"even\" name=\"outFile\"> <td><code><a href=\"https://www.typescriptlang.org/tsconfig/#outFile\">--outFile</a></code></td> <td>\n<p><code>string</code></p> </td> <td> </td> </tr> <tr class=\"option-description even\"><td colspan=\"3\"> <p>Specify a file that bundles all outputs into one JavaScript file. If <code>declaration</code> is true, also designates a file that bundles all .d.ts output.</p> </td></tr> <tr class=\"odd\" name=\"paths\"> <td><code><a href=\"https://www.typescriptlang.org/tsconfig/#paths\">--paths</a></code></td> <td>\n<p><code>object</code></p> </td> <td> </td> </tr> <tr class=\"option-description odd\"><td colspan=\"3\"> <p>A set of locations to look for imports in</p> </td></tr> <tr class=\"even\" name=\"plugins\"> <td><code><a href=\"https://www.typescriptlang.org/tsconfig/#plugins\">--plugins</a></code></td> <td>\n<p><code>list</code></p> </td> <td> </td> </tr> <tr class=\"option-description even\"><td colspan=\"3\"> <p>Specify a list of language service plugins to include.</p> </td></tr> <tr class=\"odd\" name=\"preserveConstEnums\"> <td><code><a href=\"https://www.typescriptlang.org/tsconfig/#preserveConstEnums\">--preserveConstEnums</a></code></td> <td>\n<p><code>boolean</code></p> </td> <td>\n<p><code>true</code> if <a href=\"#isolatedModules\"><code>isolatedModules</code></a>; <code>false</code> otherwise.</p> </td> </tr> <tr class=\"option-description odd\"><td colspan=\"3\"> <p>Disable erasing <code>const enum</code> declarations in generated code.</p> </td></tr> <tr class=\"even\" name=\"preserveSymlinks\"> <td><code><a href=\"https://www.typescriptlang.org/tsconfig/#preserveSymlinks\">--preserveSymlinks</a></code></td> <td>\n<p><code>boolean</code></p> </td> <td>\n<p><code>false</code></p> </td> </tr> <tr class=\"option-description even\"><td colspan=\"3\"> <p>Disable resolving symlinks to their realpath. This correlates to the same flag in node.</p> </td></tr> <tr class=\"odd\" name=\"preserveValueImports\"> <td><code><a href=\"https://www.typescriptlang.org/tsconfig/#preserveValueImports\">--preserveValueImports</a></code></td> <td>\n<p><code>boolean</code></p> </td> <td>\n<p><code>false</code></p> </td> </tr> <tr class=\"option-description odd\"><td colspan=\"3\"> <p>Preserve unused imported values in the JavaScript output that would otherwise be removed.</p> </td></tr> <tr class=\"even\" name=\"preserveWatchOutput\"> <td><code><a href=\"https://www.typescriptlang.org/tsconfig/#preserveWatchOutput\">--preserveWatchOutput</a></code></td> <td>\n<p><code>boolean</code></p> </td> <td>\n<p><code>false</code></p> </td> </tr> <tr class=\"option-description even\"><td colspan=\"3\"> <p>Disable wiping the console in watch mode.</p> </td></tr> <tr class=\"odd\" name=\"pretty\"> <td><code><a href=\"https://www.typescriptlang.org/tsconfig/#pretty\">--pretty</a></code></td> <td>\n<p><code>boolean</code></p> </td> <td>\n<p><code>true</code></p> </td> </tr> <tr class=\"option-description odd\"><td colspan=\"3\"> <p>Enable color and formatting in TypeScript's output to make compiler errors easier to read.</p> </td></tr> <tr class=\"even\" name=\"reactNamespace\"> <td><code><a href=\"https://www.typescriptlang.org/tsconfig/#reactNamespace\">--reactNamespace</a></code></td> <td>\n<p><code>string</code></p> </td> <td>\n<p><code>React</code></p> </td> </tr> <tr class=\"option-description even\"><td colspan=\"3\"> <p>Specify the object invoked for <code>createElement</code>. This only applies when targeting <code>react</code> JSX emit.</p> </td></tr> <tr class=\"odd\" name=\"removeComments\"> <td><code><a href=\"https://www.typescriptlang.org/tsconfig/#removeComments\">--removeComments</a></code></td> <td>\n<p><code>boolean</code></p> </td> <td>\n<p><code>false</code></p> </td> </tr> <tr class=\"option-description odd\"><td colspan=\"3\"> <p>Disable emitting comments.</p> </td></tr> <tr class=\"even\" name=\"resolveJsonModule\"> <td><code><a href=\"https://www.typescriptlang.org/tsconfig/#resolveJsonModule\">--resolveJsonModule</a></code></td> <td>\n<p><code>boolean</code></p> </td> <td>\n<p><code>false</code></p> </td> </tr> <tr class=\"option-description even\"><td colspan=\"3\"> <p>Enable importing .json files.</p> </td></tr> <tr class=\"odd\" name=\"resolvePackageJsonExports\"> <td><code><a href=\"https://www.typescriptlang.org/tsconfig/#resolvePackageJsonExports\">--resolvePackageJsonExports</a></code></td> <td>\n<p><code>boolean</code></p> </td> <td>\n<p><code>true</code> when <a href=\"#moduleResolution\"><code>moduleResolution</code></a> is <code>node16</code>, <code>nodenext</code>, or <code>bundler</code>; otherwise <code>false</code></p> </td> </tr> <tr class=\"option-description odd\"><td colspan=\"3\"> <p>Use the package.json 'exports' field when resolving package imports.</p> </td></tr> <tr class=\"even\" name=\"resolvePackageJsonImports\"> <td><code><a href=\"https://www.typescriptlang.org/tsconfig/#resolvePackageJsonImports\">--resolvePackageJsonImports</a></code></td> <td>\n<p><code>boolean</code></p> </td> <td>\n<p><code>true</code> when <a href=\"#moduleResolution\"><code>moduleResolution</code></a> is <code>node16</code>, <code>nodenext</code>, or <code>bundler</code>; otherwise <code>false</code></p> </td> </tr> <tr class=\"option-description even\"><td colspan=\"3\"> <p>Use the package.json 'imports' field when resolving imports.</p> </td></tr> <tr class=\"odd\" name=\"rootDir\"> <td><code><a href=\"https://www.typescriptlang.org/tsconfig/#rootDir\">--rootDir</a></code></td> <td>\n<p><code>string</code></p> </td> <td>\n<p>Computed from the list of input files.</p> </td> </tr> <tr class=\"option-description odd\"><td colspan=\"3\"> <p>Specify the root folder within your source files.</p> </td></tr> <tr class=\"even\" name=\"rootDirs\"> <td><code><a href=\"https://www.typescriptlang.org/tsconfig/#rootDirs\">--rootDirs</a></code></td> <td>\n<p><code>list</code></p> </td> <td>\n<p>Computed from the list of input files.</p> </td> </tr> <tr class=\"option-description even\"><td colspan=\"3\"> <p>Allow multiple folders to be treated as one when resolving modules.</p> </td></tr> <tr class=\"odd\" name=\"skipDefaultLibCheck\"> <td><code><a href=\"https://www.typescriptlang.org/tsconfig/#skipDefaultLibCheck\">--skipDefaultLibCheck</a></code></td> <td>\n<p><code>boolean</code></p> </td> <td>\n<p><code>false</code></p> </td> </tr> <tr class=\"option-description odd\"><td colspan=\"3\"> <p>Skip type checking .d.ts files that are included with TypeScript.</p> </td></tr> <tr class=\"even\" name=\"skipLibCheck\"> <td><code><a href=\"https://www.typescriptlang.org/tsconfig/#skipLibCheck\">--skipLibCheck</a></code></td> <td>\n<p><code>boolean</code></p> </td> <td>\n<p><code>false</code></p> </td> </tr> <tr class=\"option-description even\"><td colspan=\"3\"> <p>Skip type checking all .d.ts files.</p> </td></tr> <tr class=\"odd\" name=\"sourceMap\"> <td><code><a href=\"https://www.typescriptlang.org/tsconfig/#sourceMap\">--sourceMap</a></code></td> <td>\n<p><code>boolean</code></p> </td> <td>\n<p><code>false</code></p> </td> </tr> <tr class=\"option-description odd\"><td colspan=\"3\"> <p>Create source map files for emitted JavaScript files.</p> </td></tr> <tr class=\"even\" name=\"sourceRoot\"> <td><code><a href=\"https://www.typescriptlang.org/tsconfig/#sourceRoot\">--sourceRoot</a></code></td> <td>\n<p><code>string</code></p> </td> <td> </td> </tr> <tr class=\"option-description even\"><td colspan=\"3\"> <p>Sets the root path for debuggers to find the reference source code</p> </td></tr> <tr class=\"odd\" name=\"strict\"> <td><code><a href=\"https://www.typescriptlang.org/tsconfig/#strict\">--strict</a></code></td> <td>\n<p><code>boolean</code></p> </td> <td>\n<p><code>false</code></p> </td> </tr> <tr class=\"option-description odd\"><td colspan=\"3\"> <p>Enable all strict type checking options.</p> </td></tr> <tr class=\"even\" name=\"strictBindCallApply\"> <td><code><a href=\"https://www.typescriptlang.org/tsconfig/#strictBindCallApply\">--strictBindCallApply</a></code></td> <td>\n<p><code>boolean</code></p> </td> <td>\n<p><code>true</code> if <a href=\"#strict\"><code>strict</code></a>; <code>false</code> otherwise.</p> </td> </tr> <tr class=\"option-description even\"><td colspan=\"3\"> <p>Check that the arguments for <code>bind</code>, <code>call</code>, and <code>apply</code> methods match the original function.</p> </td></tr> <tr class=\"odd\" name=\"strictFunctionTypes\"> <td><code><a href=\"https://www.typescriptlang.org/tsconfig/#strictFunctionTypes\">--strictFunctionTypes</a></code></td> <td>\n<p><code>boolean</code></p> </td> <td>\n<p><code>true</code> if <a href=\"#strict\"><code>strict</code></a>; <code>false</code> otherwise.</p> </td> </tr> <tr class=\"option-description odd\"><td colspan=\"3\"> <p>When assigning functions, check to ensure parameters and the return values are subtype-compatible.</p> </td></tr> <tr class=\"even\" name=\"strictNullChecks\"> <td><code><a href=\"https://www.typescriptlang.org/tsconfig/#strictNullChecks\">--strictNullChecks</a></code></td> <td>\n<p><code>boolean</code></p> </td> <td>\n<p><code>true</code> if <a href=\"#strict\"><code>strict</code></a>; <code>false</code> otherwise.</p> </td> </tr> <tr class=\"option-description even\"><td colspan=\"3\"> <p>When type checking, take into account <code>null</code> and <code>undefined</code>.</p> </td></tr> <tr class=\"odd\" name=\"strictPropertyInitialization\"> <td><code><a href=\"https://www.typescriptlang.org/tsconfig/#strictPropertyInitialization\">--strictPropertyInitialization</a></code></td> <td>\n<p><code>boolean</code></p> </td> <td>\n<p><code>true</code> if <a href=\"#strict\"><code>strict</code></a>; <code>false</code> otherwise.</p> </td> </tr> <tr class=\"option-description odd\"><td colspan=\"3\"> <p>Check for class properties that are declared but not set in the constructor.</p> </td></tr> <tr class=\"even\" name=\"stripInternal\"> <td><code><a href=\"https://www.typescriptlang.org/tsconfig/#stripInternal\">--stripInternal</a></code></td> <td>\n<p><code>boolean</code></p> </td> <td>\n<p><code>false</code></p> </td> </tr> <tr class=\"option-description even\"><td colspan=\"3\"> <p>Disable emitting declarations that have <code>@internal</code> in their JSDoc comments.</p> </td></tr> <tr class=\"odd\" name=\"suppressExcessPropertyErrors\"> <td><code><a href=\"https://www.typescriptlang.org/tsconfig/#suppressExcessPropertyErrors\">--suppressExcessPropertyErrors</a></code></td> <td>\n<p><code>boolean</code></p> </td> <td>\n<p><code>false</code></p> </td> </tr> <tr class=\"option-description odd\"><td colspan=\"3\"> <p>Disable reporting of excess property errors during the creation of object literals.</p> </td></tr> <tr class=\"even\" name=\"suppressImplicitAnyIndexErrors\"> <td><code><a href=\"https://www.typescriptlang.org/tsconfig/#suppressImplicitAnyIndexErrors\">--suppressImplicitAnyIndexErrors</a></code></td> <td>\n<p><code>boolean</code></p> </td> <td>\n<p><code>false</code></p> </td> </tr> <tr class=\"option-description even\"><td colspan=\"3\"> <p>Suppress <a href=\"#noImplicitAny\"><code>noImplicitAny</code></a> errors when indexing objects that lack index signatures.</p> </td></tr> <tr class=\"odd\" name=\"target\"> <td><code><a href=\"https://www.typescriptlang.org/tsconfig/#target\">--target</a></code></td> <td>\n<p><code>es3</code>, <code>es5</code>, <code>es6</code>/<code>es2015</code>, <code>es2016</code>, <code>es2017</code>, <code>es2018</code>, <code>es2019</code>, <code>es2020</code>, <code>es2021</code>, <code>es2022</code> 또는 <code>esnext</code></p> </td> <td>\n<p><code>ES3</code></p> </td> </tr> <tr class=\"option-description odd\"><td colspan=\"3\"> <p>Set the JavaScript language version for emitted JavaScript and include compatible library declarations.</p> </td></tr> <tr class=\"even\" name=\"traceResolution\"> <td><code><a href=\"https://www.typescriptlang.org/tsconfig/#traceResolution\">--traceResolution</a></code></td> <td>\n<p><code>boolean</code></p> </td> <td>\n<p><code>false</code></p> </td> </tr> <tr class=\"option-description even\"><td colspan=\"3\"> <p>Log paths used during the <code>moduleResolution</code> process.</p> </td></tr> <tr class=\"odd\" name=\"tsBuildInfoFile\"> <td><code><a href=\"https://www.typescriptlang.org/tsconfig/#tsBuildInfoFile\">--tsBuildInfoFile</a></code></td> <td>\n<p><code>string</code></p> </td> <td>\n<p><code>.tsbuildinfo</code></p> </td> </tr> <tr class=\"option-description odd\"><td colspan=\"3\"> <p>The file to store <code>.tsbuildinfo</code> incremental build information in.</p> </td></tr> <tr class=\"even\" name=\"typeRoots\"> <td><code><a href=\"https://www.typescriptlang.org/tsconfig/#typeRoots\">--typeRoots</a></code></td> <td>\n<p><code>list</code></p> </td> <td> </td> </tr> <tr class=\"option-description even\"><td colspan=\"3\"> <p>Specify multiple folders that act like <code>./node_modules/@types</code>.</p> </td></tr> <tr class=\"odd\" name=\"types\"> <td><code><a href=\"https://www.typescriptlang.org/tsconfig/#types\">--types</a></code></td> <td>\n<p><code>list</code></p> </td> <td> </td> </tr> <tr class=\"option-description odd\"><td colspan=\"3\"> <p>Specify type package names to be included without being referenced in a source file.</p> </td></tr> <tr class=\"even\" name=\"useDefineForClassFields\"> <td><code><a href=\"https://www.typescriptlang.org/tsconfig/#useDefineForClassFields\">--useDefineForClassFields</a></code></td> <td>\n<p><code>boolean</code></p> </td> <td>\n<p><code>true</code> if <a href=\"#target\"><code>target</code></a> is <code>ES2022</code> or higher, including <code>ESNext</code>; <code>false</code> otherwise.</p> </td> </tr> <tr class=\"option-description even\"><td colspan=\"3\"> <p>Emit ECMAScript-standard-compliant class fields.</p> </td></tr> <tr class=\"odd\" name=\"useUnknownInCatchVariables\"> <td><code><a href=\"https://www.typescriptlang.org/tsconfig/#useUnknownInCatchVariables\">--useUnknownInCatchVariables</a></code></td> <td>\n<p><code>boolean</code></p> </td> <td>\n<p><code>true</code> if <a href=\"#strict\"><code>strict</code></a>; <code>false</code> otherwise.</p> </td> </tr> <tr class=\"option-description odd\"><td colspan=\"3\"> <p>Default catch clause variables as <code>unknown</code> instead of <code>any</code>.</p> </td></tr> <tr class=\"even\" name=\"verbatimModuleSyntax\"> <td><code><a href=\"https://www.typescriptlang.org/tsconfig/#verbatimModuleSyntax\">--verbatimModuleSyntax</a></code></td> <td>\n<p><code>boolean</code></p> </td> <td>\n<p><code>false</code></p> </td> </tr> <tr class=\"option-description even\"><td colspan=\"3\"> <p>Do not transform or elide any imports or exports not marked as type-only, ensuring they are written in the output file's format based on the 'module' setting.</p> </td></tr> </tbody>\n</table> undefined<div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2012-2023 Microsoft<br>Licensed under the Apache License, Version 2.0.<br>\n    <a href=\"https://www.typescriptlang.org/ko/docs/handbook/compiler-options.html\" class=\"_attribution-link\">https://www.typescriptlang.org/ko/docs/handbook/compiler-options.html</a>\n  </p>\n</div>\n","dom-manipulation":"<h1>DOM Manipulation</h1>\n<h1 id=\"dom-조작-dom-manipulation\" style=\"position:relative;\">DOM 조작 (DOM Manipulation)</h1> <h3 id=\"htmlelement-타입-탐구-an-exploration-into-the-htmlelement-type\" style=\"position:relative;\">\n<em><code>HTMLElement</code> 타입 탐구</em> (<em>An exploration into the <code>HTMLElement</code> type</em>)</h3> <p>표준화 이후 20여 년 동안, JavaScript는 많은 발전을 이루었습니다. 2020년에는 서버, 데이터 사이언스, 그리고 IoT 기기에도 JavaScript를 사용할 수 있지만, 가장 인기 있는 활용 사례는 웹 브라우저인 것을 기억하는 것이 중요합니다.</p> <p>웹 사이트는 HTML 및/또는 XML 문서로 구성됩니다. 이러한 문서들은 정적이어서, 변하지 않습니다. <em>문서 객체 모델(DOM)은</em> 정적 웹 사이트를 기능적으로 작동시키기 위해 브라우저에 의해 구현된 프로그래밍 인터페이스입니다. DOM API를 사용하면 문서의 구조, 스타일, 그리고 내용을 변경할 수 있습니다. API는 매우 강력해서 이를 바탕으로 보다 쉽게 동적인 웹사이트들 개발하기 위해 수많은 프런트엔드 프레임워크(jQuery, React, Angular 등)가 개발되었습니다.</p> <p>TypeScript는 타입이 있는 JavaScript 상위 집합(superset)이며, DOM API에 대한 타입 정의를 제공합니다. 이러한 정의는 모든 기본 TypeScript 프로젝트에서 쉽게 사용 가능합니다. <em>lib.dom.d.ts</em> 에 있는 2만여 줄의 정의 중에서, 가장 눈에 띄는 것은 <code>HTMLElement</code>입니다. 이 타입은 TypeScript를 사용한 DOM 조작의 중축입니다.</p> <blockquote> <p><a href=\"https://github.com/microsoft/TypeScript/blob/master/lib/lib.dom.d.ts\">DOM 타입 정의</a>에 대한 소스코드는 이곳에서 볼 수 있습니다.</p> </blockquote> <h2 id=\"기본-예제-basic-example\" style=\"position:relative;\">기본 예제 (Basic Example)</h2> <p>간단한 예시 파일 <em>index.html</em>:</p> <pre data-language=\"typescript\">&lt;!DOCTYPE html&gt;\n&lt;html lang=\"en\"&gt;\n  &lt;head&gt;&lt;title&gt;TypeScript Dom Manipulation&lt;/title&gt;&lt;/head&gt;\n  &lt;body&gt;\n    &lt;div id=\"app\"&gt;&lt;/div&gt;\n    &lt;!-- Assume index.js is the compiled output of index.ts --&gt;\n    &lt;script src=\"index.js\"&gt;&lt;/script&gt;\n  &lt;/body&gt;\n&lt;/html&gt;</pre> <p><code>#app</code> 요소에 <code>&lt;p&gt;Hello, World&lt;/p&gt;</code> 요소를 추가하는 TypeScript 스크립트를 살펴보겠습니다.</p> <pre data-language=\"ts\">// 1. id 프로퍼티를 사용하여 div 요소를 선택합니다.\nconst app = document.getElementById(\"app\");\n\n// 2. 새로운 &lt;p&gt;&lt;/p&gt; 요소를 프로그래밍 방식으로 생성합니다.\nconst p = document.createElement(\"p\");\n\n// 3. 텍스트 내용을 추가합니다.\np.textContent = \"Hello, World!\";\n\n// 4. div 요소에 p 요소를 자식 노드로 추가합니다.\napp?.appendChild(p);</pre> <p><em>index.html</em> 페이지를 컴파일하고 실행한 후, HTML 결과:</p> <pre data-language=\"html\">&lt;div id=\"app\"&gt;\n  &lt;p&gt;Hello, World!&lt;/p&gt;\n&lt;/div&gt;</pre> <h2 id=\"document-인터페이스-the-document-interface\" style=\"position:relative;\">\n<code>Document</code> 인터페이스 (The <code>Document</code> Interface)</h2> <p>TypeScript 코드의 첫 번째 줄은 전역변수 <code>document</code>를 사용하며, 그 변수를 검사하면 <em>lib.dom.d.ts</em> 파일의 <code>Document</code> 인터페이스에 의해 정의된 것으로 표시됩니다. 그 코드의 스니펫(snippet)에는 <code>getElementById</code>와 <code>createElement</code>라는 두 가지 메서드 호출이 포함되어 있습니다.</p> <h3 id=\"documentgetelementbyid\" style=\"position:relative;\"><code>Document.getElementById</code></h3> <p>이 메서드의 정의는 다음과 같습니다:</p> <pre data-language=\"ts\">getElementById(elementId: string): HTMLElement | null;</pre> <p>문자열 id 요소가 전달되면 <code>HTMLElement</code> 또는 <code>null</code>이 반환됩니다. 이 메서드는 가장 중요한 타입들 중 하나인 <code>HTMLElement</code>를 도입합니다. 이 타입은 다른 모든 요소 인터페이스의 기본 인터페이스 역할을 합니다. 예를 들면, 예제 코드에서 <code>p</code> 변수는 <code>HTMLParagraphElement</code> 타입입니다. 다음으로, 이 메서드는 <code>null</code>을 반환할 수 있다는 점에 유의해야 합니다. 메서드가 실제로 지정된 요소를 찾을 수 있을지 없을지에 따라 확실한 사전 런타임이 될 수 없기 때문입니다. 스니펫 코드의 마지막 줄에는, <code>appendChild</code>를 호출하기 위해 새로운 <em>선택적 체이닝(optional chaining)</em> 연산자가 사용되고 있습니다.</p> <h3 id=\"documentcreateelement\" style=\"position:relative;\"><code>Document.createElement</code></h3> <p>이 메서드의 정의는 다음과 같습니다(<em>deprecated</em> 표기된 정의는 생략했습니다):</p> <pre data-language=\"ts\">createElement&lt;K extends keyof HTMLElementTagNameMap&gt;(tagName: K, options?: ElementCreationOptions): HTMLElementTagNameMap[K];\ncreateElement(tagName: string, options?: ElementCreationOptions): HTMLElement;</pre> <p>이는 오버 로드된 함수 정의입니다. 두 번째 오버로드는 가장 단순하며 <code>getElementById</code> 메서드와 매우 유사하게 작동합니다. 어떤 <code>문자열</code>이 전달되면 HTMLElement 표준이 반환됩니다. 이 정의는 개발자가 고유한 HTML 요소 태그를 생성할 수 있게 합니다.</p> <p>예를 들면 <code>document.createElement('xyz')</code>는 HTML 규격에 지정된 요소가 아닌 <code>&lt;xyz&gt;&lt;/xyz&gt;</code> 요소를 반환합니다.</p> <blockquote> <p>관심 있는 사람들을 위해 언급하자면, <code>document.getElementsByTagName</code>를 사용해 사용자 정의 태그(custom tag) 요소와 상호작용할 수 있습니다.</p> </blockquote> <p><code>createElement</code>의 첫 번째 정의에는, 고급 제네릭 패턴들을 사용하고 있습니다. 이는 내용을 나누어 이해하는 것이 가장 좋습니다. 먼저 <code>&lt;K extends keyof HTMLElementTagNameMap&gt;</code>라는 제네릭 표현부터 시작합니다. 이 표현식은 <code>HTMLElementTagNameMap</code> 인터페이스의 키에 제약을 받는 제네릭 매개변수 <code>K</code>를 정의하고 있습니다. 그 맵 인터페이스는 모든 지정된 HTML 태그 이름과 해당 타입 인터페이스를 포함하고 있습니다. 예를 들면 여기 코드 초반에 5개의 매핑된 값이 있습니다:</p> <pre data-language=\"ts\">interface HTMLElementTagNameMap {\n    \"a\": HTMLAnchorElement;\n    \"abbr\": HTMLElement;\n    \"address\": HTMLElement;\n    \"applet\": HTMLAppletElement;\n    \"area\": HTMLAreaElement;\n        ...\n}</pre> <p>일부 요소들은 고유한 프로퍼티를 나타내지 않아 <code>HTMLElement</code>를 반환하기도 하지만, 그 외 타입 요소들은 고유한 프로퍼티와 메서드를 가지고 특정 인터페이스(<code>HTMLElement</code>에서 확장되거나 구현됨)를 반환합니다.</p> <p>이제, <code>createElement</code> 정의의 나머지 부분인 <code>(tagName: K, options?: ElementCreationOptions): HTMLElementTagNameMap[K]</code>를 살펴보겠습니다. 첫 번째 인수 <code>tagName</code>은 제네릭 매개변수 <code>K</code>로 정의됩니다. TypeScript 인터프리터는 이 인수로부터 제네릭 매개변수를 <em>추론</em> 할 수 있는 충분한 성능을 가지고 있습니다. 이는 개발자가 메서드를 사용할 때 실제로 제네릭 매개변수를 지정할 필요가 없음을 의미하며, 어떤 값이 <code>tagName</code>인수로 전달되든 간에 <code>K</code>로 추론되므로 정의의 나머지 부분에 사용할 수 있을 것입니다. 정확히 무슨 일이 일어나는지를 보면 반환값 <code>HTMLElementTagNameMap[K]</code>는 <code>tagName</code>인수를 가지고 해당 타입을 반환합니다. 이 정의는 스니펫 코드 <code>p</code> 변수에서 <code>HTMLParagraphElement</code>타입을 얻는 방법입니다. 그리고 코드가 <code>document.createElement('a')</code>였다면, <code>HTMLAnchorElement</code>타입의 요소가 됩니다.</p> <h2 id=\"node-인터페이스-the-node-interface\" style=\"position:relative;\">\n<code>Node</code> 인터페이스 (The <code>Node</code> interface)</h2> <p><code>document.getElementById</code> 함수는 <code>HTMLElement</code>를 반환합니다. <code>HTMLElement</code> 인터페이스는 <code>Node</code> 인터페이스를 확장한 <code>Element</code> 인터페이스를 확장합니다. 이러한 프로토타입 확장은 모든 <code>HTMLElements</code>가 표준 메서드의 하위 집합을 활용할 수 있도록 합니다. 코드 스니펫에서는 <code>Node</code> 인터페이스에 정의된 속성을 사용하여 웹 사이트에 새 <code>p</code> 요소를 추가합니다.</p> <h3 id=\"nodeappendchild\" style=\"position:relative;\"><code>Node.appendChild</code></h3> <p>코드 스니펫의 마지막 줄은 <code>app?.appendChild(p)</code>입니다. 이전 섹션(<code>document.getElementById</code>)에서는 <code>app</code>이 런타임에 null일 가능성이 있기 때문에 <em>선택적 체이닝(optional chaining)</em> 연산자가 여기에 사용된다고 설명했습니다. <code>appendChild</code>의 메서드는 다음과 같습니다:</p> <pre data-language=\"ts\">appendChild&lt;T extends Node&gt;(newChild: T): T;</pre> <p>제네릭 매개변수 <code>T</code>가 <code>newChild</code> 인수로부터 나온 것이기 때문에 이 메서드는 <code>createElement</code> 메서드와 유사하게 작동합니다. <code>T</code>는 또 다른 기본 인터페이스인 <code>노드</code>로 <em>제한</em>됩니다.</p> <h2 id=\"children과-childnodes의-차이점-difference-between-children-and-childnodes\" style=\"position:relative;\">\n<code>children</code>과 <code>childNodes</code>의 차이점 (Difference between <code>children</code> and <code>childNodes</code>)</h2> <p>이전에 이 문서는 <code>HTMLElement</code> 인터페이스가 <code>Node</code>로부터 확장된 <code>Element</code>에서 확장된 개념이라고 설명했습니다. DOM API에는 <em>자식(children)</em> 요소 개념이 있습니다. 예를 들어 HTML에서 <code>p</code> 태그는 <code>div</code> 요소의 자식입니다.</p> <pre data-language=\"typescript+html\">&lt;div&gt;\n  &lt;p&gt;Hello, World&lt;/p&gt;\n  &lt;p&gt;TypeScript!&lt;/p&gt;\n&lt;/div&gt;;\n\nconst div = document.getElementByTagName(\"div\")[0];\n\ndiv.children;\n// HTMLCollection(2) [p, p]\n\ndiv.childNodes;\n// NodeList(2) [p, p]</pre> <p><code>div</code> 요소를 찾아낸 후 <code>children</code> 프로퍼티는 <code>HTMLParagraphElements</code>를 포함하는 <code>HTMLCollection</code> 리스트를 반환합니다. <code>childNodes</code> 프로퍼티는 위와 유사하게 노드 리스트인 <code>NodeList</code>를 반환합니다. 각 <code>p</code> 태그는 여전히 <code>HTMLParagraphElements</code> 타입이지만, <code>NodeList</code>는 추가적으로 <code>HTMLCollection</code> 리스트에는 없는 <em>HTML 노드</em> 를 포함할 수 있습니다.</p> <p><code>p</code> 태그 중 하나를 제거하여 html을 수정하되 텍스트는 그대로 유지하십시오.</p> <pre data-language=\"typescript+html\">&lt;div&gt;\n  &lt;p&gt;Hello, World&lt;/p&gt;\n  TypeScript!\n&lt;/div&gt;;\n\nconst div = document.getElementByTagName(\"div\")[0];\n\ndiv.children;\n// HTMLCOllection(1) [p]\n\ndiv.childNodes;\n// NodeList(2) [p, text]</pre> <p>어떻게 두 개의 리스트가 변했는지 보겠습니다. <code>children</code>은 현재 <code>&lt;p&gt;Hello, World&lt;/p&gt;</code> 요소만을 포함하고 있고, <code>childNodes</code>는 두 개의 <code>p</code> 노드가 아닌 <code>text</code> 노드를 포함하고 있습니다. <code>NodeList</code>에서 <code>text</code> 부분은 <code>TypeScript!</code> 텍스트를 포함하는 문자 그대로의 <code>Node</code>입니다. <code>children</code> 리스트는 이 <code>Node</code>를 포함하지 않습니다. 왜냐하면 <code>HTMLElement</code>로 간주하지 않기 때문입니다.</p> <h2 id=\"queryselector와-queryselectorall-메서드-the-queryselector-and-queryselectorall-methods\" style=\"position:relative;\">\n<code>querySelector</code>와 <code>querySelectorAll</code> 메서드 (The <code>querySelector</code> and <code>querySelectorAll</code> methods)</h2> <p>두 개의 메서드 모두 고유한 제약 조건 집합에 적합한 돔 요소 리스트를 가져오는 데 좋은 도구입니다. 메서드들은 <em>lib.dom.d.ts</em> 에 다음과 같이 정의되어 있습니다:</p> <pre data-language=\"ts\">/**\n * 선택자와 일치하는 노드의 자식 중 첫 번째 요소를 반환합니다.\n */\nquerySelector&lt;K extends keyof HTMLElementTagNameMap&gt;(selectors: K): HTMLElementTagNameMap[K] | null;\nquerySelector&lt;K extends keyof SVGElementTagNameMap&gt;(selectors: K): SVGElementTagNameMap[K] | null;\nquerySelector&lt;E extends Element = Element&gt;(selectors: string): E | null;\n\n/**\n * 선택자와 일치하는 모든 노드 자식 요소를 반환합니다.\n */\nquerySelectorAll&lt;K extends keyof HTMLElementTagNameMap&gt;(selectors: K): NodeListOf&lt;HTMLElementTagNameMap[K]&gt;;\nquerySelectorAll&lt;K extends keyof SVGElementTagNameMap&gt;(selectors: K): NodeListOf&lt;SVGElementTagNameMap[K]&gt;;\nquerySelectorAll&lt;E extends Element = Element&gt;(selectors: string): NodeListOf&lt;E&gt;;</pre> <p><code>querySelectorAll</code> 정의는 <code>NodeListOf</code>라는 새로운 타입을 반환한다는 점을 제외하면 <code>getElementByTagName</code>과 유사합니다. 이 반환 타입은 기본적으로 표준 JavaScript 리스트 요소의 맞춤형으로 구현되었습니다. <code>NodeListOf&lt;E&gt;</code>를 <code>E[]</code>로 바꿔보면 틀림없이 매우 유사한 사용자 경험을 제공할 것입니다. <code>NodeListOf</code>는 <code>length</code> , <code>item(index)</code>, <code>forEach((value, key, parent) =&gt; void)</code> , 그리고 숫자 인덱스 생성과 같은 프로퍼티 및 메서드만을 구현합니다. 또한, 메서드는 <em>노드</em> 가 아닌 <em>요소</em> 리스트를 반환하며 이는 <code>.childNodes</code> 메서드에서 <code>NodeList</code>가 반환한 것입니다. 모순처럼 보일 수 있지만, <code>Element</code> 인터페이스는 <code>Node</code>에서 확장된 점에 유의해야 합니다.</p> <p>두 개의 메서드가 동작하는 것을 보려면 기존 코드를 다음과 같이 수정하십시오:</p> <pre data-language=\"typescript+html\">&lt;ul&gt;\n  &lt;li&gt;First :)&lt;/li&gt;\n  &lt;li&gt;Second!&lt;/li&gt;\n  &lt;li&gt;Third times a charm.&lt;/li&gt;\n&lt;/ul&gt;;\n\nconst first = document.querySelector(\"li\"); // 첫 번째 li 요소를 반환합니다.\nconst all = document.querySelectorAll(\"li\"); // 모든 li 요소를 포함하는 리스트를 반환합니다.</pre> <h2 id=\"더-자세히-알고-싶으십니까-interested-in-learning-more\" style=\"position:relative;\">더 자세히 알고 싶으십니까? (Interested in learning more?)</h2> <p><em>lib.dom.d.ts</em> 타입 정의에서 가장 좋은 부분은 Mozilla Developer Network (MDN) 문서 사이트에 표기된 타입들을 반영했다는 것입니다. 예를 들어, <code>HTMLElement</code> 인터페이스는 MDN에서 <a href=\"https://developer.mozilla.org/docs/Web/API/HTMLElement\">HTMLElement 페이지</a>에 문서화 되어 있습니다. 이 페이지에는 사용 가능한 모든 프로퍼티, 메서드, 때로는 예시까지 제공합니다. 해당 페이지가 훌륭한 다른 면은 표준 문서에 맞는 링크를 제공한다는 것입니다. 다음은 <a href=\"https://www.w3.org/TR/html52/dom.html#htmlelement\">HTMLElement의 W3C 권장사항</a>에 대한 링크입니다.</p> <p>소스코드 참조:</p> <ul> <li><a href=\"http://www.ecma-international.org/ecma-262/10.0/index.html\">ECMA-262 Standard</a></li> <li><a href=\"https://developer.mozilla.org/docs/Web/API/Document_Object_Model/Introduction\">Introduction to the DOM</a></li> </ul><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2012-2023 Microsoft<br>Licensed under the Apache License, Version 2.0.<br>\n    <a href=\"https://www.typescriptlang.org/ko/docs/handbook/dom-manipulation.html\" class=\"_attribution-link\">https://www.typescriptlang.org/ko/docs/handbook/dom-manipulation.html</a>\n  </p>\n</div>\n","project-references":"<h1>Project References</h1>\n<p>프로젝트 레퍼런스는 TypeScript 프로그램을 더 작은 조각으로 구성할 수 있는 TypeScript 3.0의 새로운 기능입니다.</p> <p>이를 통해, 빌드 시간을 크게 개선하고, 컴포넌트 사이의 논리적인 분리를 강제하여 코드를 새롭고 더 나은 방법으로 구성할 수 있습니다.</p> <p>또한, 빠른 TypeScript 빌드를 위해 프로젝트 레퍼런스와 함께 동작하는 <code>tsc</code> 의 새로운 모드인 <code>--build</code> 플래그를 도입했습니다.</p> <h1 id=\"예제-프로젝트-an-example-project\" style=\"position:relative;\">예제 프로젝트 (An Example Project)</h1> <p>꽤 일반적인 프로그램을 보고 프로젝트 레퍼런스가 이 프로그램을 더 잘 구성하는데 어떻게 도움이 될 수 있는지 살펴보겠습니다. <code>converter</code>와 <code>units</code>이라는 두 모듈이 프로젝트 안에 있고, 각 모듈에 대응되는 테스트 파일이 있다고 상상해봅시다:</p> <pre data-language=\"shell\">/src/converter.ts\n/src/units.ts\n/test/converter-tests.ts\n/test/units-tests.ts\n/tsconfig.json</pre> <p>테스트 파일은 구현 파일을 import 하고 테스트를 진행합니다:</p> <pre data-language=\"ts\">// converter-tests.ts\nimport * as converter from \"../converter\";\n\nassert.areEqual(converter.celsiusToFahrenheit(0), 32);</pre> <p>이전에는, 단일 tsconfig 파일을 사용한 경우 이 구조가 어색하게 동작했습니다:</p> <ul> <li>구현 파일에서 테스트 파일을 import 하는 것이 가능합니다</li> <li>아마도 원치 않았겠지만 <code>src</code>가 출력 폴더 이름에 나타나지 않고는 <code>test</code>와 <code>src</code>를 동시에 빌드 하는 것이 불가능합니다</li> <li>구현 파일 안에 <em>내용물</em> 만 바꿔도 새로운 오류를 절대 발생시키지 않지만 테스트 파일에 대한 <em>타입 검사</em>를 다시 해야 합니다</li> <li>테스트 파일만 바꿔도 아무 변화 없지만 구현 파일의 타입 검사를 다시 해야 합니다</li> </ul> <p>여러 개의 tsconfig 파일을 사용하여 이 문제들 중 <em>몇 가지</em>는 해결할 수 있지만, 새로운 문제가 발생합니다:</p> <ul> <li>내장된 최신 검사가 없기 때문에, 항상 <code>tsc</code>를 두 번 실행해야 합니다</li> <li>\n<code>tsc</code>를 두 번 호출하면 시작 시간 오버헤드가 더 많이 발생합니다</li> <li>\n<code>tsc-w</code>는 한 번에 여러 config 파일을 실행할 수 없습니다</li> </ul> <p>프로젝트 레퍼런스는 이 모든 문제를 해결할 수 있습니다.</p> <h1 id=\"프로젝트-레퍼런스는-무엇인가-what-is-a-project-reference\" style=\"position:relative;\">프로젝트 레퍼런스는 무엇인가? (What is a Project Reference?)</h1> <p><code>tsconfig.json</code> 파일은 새로운 최상위-레벨 프로퍼티 <code>reference</code>를 가집니다. 이는 참조할 프로젝트를 지정하는 객체의 배열입니다:</p> <pre data-language=\"js\">{\n    \"compilerOptions\": {\n        // The usual\n    },\n    \"references\": [\n        { \"path\": \"../src\" }\n    ]\n}</pre> <p>각 참조의 <code>path</code> 프로퍼티는 <code>tsconfig.json</code> 파일을 가지는 디렉터리를 가리키거나, config 파일 자체(어떤 이름도 가질 수 있음)를 가리킵니다.</p> <p>프로젝트를 참조하면, 새로운 일이 일어납니다:</p> <ul> <li>참조된 프로젝트에서 모듈을 import 하면 모듈의 <em>출력</em> 선언 파일을 대신 로드합니다 (<code>.d.ts</code>)</li> <li>만약 참조된 프로젝트가 <code>outFile</code>를 생성하면, 출력 파일 <code>.d.ts</code> 파일의 선언은 이 프로젝트 안에서 노출됩니다</li> <li>빌드 모드(아래 참조)는 필요하다면 자동으로 참조된 프로젝트를 빌드 합니다</li> </ul> <p>여러 프로젝트로 분리하는 것은, 타입 검사와 컴파일 속도를 크게 향상시키고, 에디터를 사용할 때 메모리 사용량을 줄이며, 프로그램의 논리적 그룹화를 향상시킵니다.</p> <h1 id=\"composite\" style=\"position:relative;\"><code>composite</code></h1> <p>참조 된 프로젝트는 반드시 새로운 <code>composite</code> 설정이 활성화되어야 합니다. 이 설정은 TypeScript가 참조된 프로젝트의 출력을 어디서 찾아야 할지 빠르게 결정하도록 하기 위해 필요합니다. <code>composite</code> 플래그를 활성화하면 몇 가지가 변합니다:</p> <ul> <li>만약 <code>rootDir</code> 설정이 명시적으로 지정되지 않으면, 기본 값은 <code>tsconfig</code> 파일을 가진 디렉터리입니다</li> <li>모든 구현 파일은 반드시 <code>include</code> 패턴에 맞거나 <code>files</code> 배열 안에 있어야 합니다. 만약 이 제약조건을 위반하면, <code>tsc</code>는 어떤 파일이 지정되지 않았는지 알려줍니다</li> <li>\n<code>declaration</code>은 반드시 켜져 있어야 합니다</li> </ul> <h1 id=\"declarationmaps\" style=\"position:relative;\">\n<code>declarationMap</code>s</h1> <p><a href=\"https://github.com/Microsoft/TypeScript/issues/14479\">선언 소스 맵</a>에 대한 지원도 추가했습니다. 만약 <code>--declarationMap</code>을 활성화하면, “정의로 이동”과 이름 변경과 같은 에디터 기능을 사용하여 지원하는 에디터에서 투명하게 탐색하고 프로젝트 경계를 넘어 코드를 수정할 수 있습니다.</p> <h1 id=\"prepend와-outfile-prepend-with-outfile\" style=\"position:relative;\">\n<code>prepend</code>와 <code>outFile</code> (<code>prepend</code> with <code>outFile</code>)</h1> <p>레퍼런스에서 <code>prepend</code> 옵션을 사용하여 의존성의 출력을 덧붙이는 것을 활성화할 수 있습니다:</p> <pre data-language=\"js\">   \"references\": [\n       { \"path\": \"../utils\", \"prepend\": true }\n   ]</pre> <p>프로젝트를 덧붙이는 것은 프로젝트의 출력을 현재 프로젝트의 출력 위에 포함시킵니다. 이는 <code>.js</code> 파일과 <code>.d.ts</code> 파일에 모두 동작하고, 소스맵 파일 역시 올바르게 방출됩니다.</p> <p><code>tsc</code>는 이 작업을 위해 디스크에 있는 기존 파일만 사용합니다, 그래서 어떤 프로젝트의 출력이 결과 파일에 한 번 이상 나타날 수 있기 때문에, 올바른 출력 파일이 생성될 수 없는 프로젝트를 생성하는 것이 가능합니다. 예를 들어:</p> <pre data-language=\"txt\">   A\n  ^ ^\n /   \\\nB     C\n ^   ^\n  \\ /\n   D</pre> <p>이 상황에서 각 레퍼런스에 덧붙이지 않는 것이 중요한데, 왜냐하면 <code>D</code>의 출력에 <code>A</code>의 두 가지 복사본이 나오기 때문입니다 - 이는 예상치 못한 결과를 초래할 수 있습니다.</p> <h1 id=\"프로젝트-레퍼런스에-대한-주의사항-caveats-for-project-references\" style=\"position:relative;\">프로젝트 레퍼런스에 대한 주의사항 (Caveats for Project References)</h1> <p>프로젝트 레퍼런스는 반드시 주의해야 할 몇 가지 트레이드오프가 있습니다.</p> <p>왜냐하면 의존성 있는 프로젝트는 의존성으로부터 빌드 된 <code>.d.ts</code> 파일을 사용하기 때문에, 에디터에서 잘못된 오류를 보지 않고 프로젝트를 탐색할 수 있기 전에 특정 빌드 출력을 검사하거나 <em>혹은</em> 클론 후 프로젝트를 빌드 해야 합니다. 이를 개선할 수 있는 .d.ts 생성 과정을 작업하고 있습니다만, 지금은 클론 이후에 빌드 하는 것을 개발자분들에게 추천드립니다.</p> <p>추가적으로, 기존 빌드 작업 흐름과의 호환성을 유지하기 위해, <code>tsc</code>는 <code>--build</code> 스위치를 호출하지 않는 한 자동으로 의존성 빌드를 하지 <em>않습니다</em>. <code>--build</code>에 대해 배워봅시다.</p> <h1 id=\"typescript를-위한-빌드-모드-build-mode-for-typescript\" style=\"position:relative;\">TypeScript를 위한 빌드 모드 (Build Mode for TypeScript)</h1> <p>오래 기다린 기능은 TypeScript 프로젝트를 위한 똑똑한 증분 빌드입니다. 3.0에서 <code>tsc</code>에서 <code>--build</code> 플래그를 사용할 수 있게 되었습니다. 이것은 단순한 컴파일러보다 빌드 관리자처럼 동작하는 <code>tsc</code>의 새로운 진입점입니다.</p> <p><code>tsc --build</code> (약식은 <code>tsc -b</code>)를 실행하면 다음의 작업을 합니다:</p> <ul> <li>참조된 모든 프로젝트를 찾습니다</li> <li>최신 상태인지 감지합니다</li> <li>올바른 순서로 최신 상태가 아닌 프로젝트를 빌드 합니다</li> </ul> <p><code>tsc -b</code>에 여러 config 파일 경로를 제공할 수 있습니다 (예를 들어. <code>tsc -b src test</code>). <code>tsc -p</code>처럼, 만약 config 파일 이름이 <code>tsconfig.json</code>이라면 이름을 지정하지 않아도 됩니다.</p> <h2 id=\"tsc--b-명령줄-tsc--b-commandline\" style=\"position:relative;\">\n<code>tsc -b</code> 명령줄 (<code>tsc -b</code> Commandline)</h2> <p>config 파일을 원하는 만큼 지정할 수 있습니다:</p> <pre data-language=\"shell\"> &gt; tsc -b                            # 현재 디렉터리에 있는 tsconfig.json 사용\n &gt; tsc -b src                        # src/tsconfig.json 사용\n &gt; tsc -b foo/prd.tsconfig.json bar  # foo/prd.tsconfig.json 와 bar/tsconfig.json 사용</pre> <p>명령줄에 전달한 파일의 순서에 대해서는 걱정하지 마세요 - 필요하면 <code>tsc</code>가 재배열하기 때문에 의존성이 언제나 먼저 빌드 됩니다.</p> <p><code>tsc -b</code>에 지정할 수 있는 몇 가지 플래그들이 더 있습니다:</p> <ul> <li>\n<code>--verbose</code>: 어떻게 진행되고 있는지 자세한 로그를 출력해 줍니다 (다른 플래그와 결합할 수 있습니다)</li> <li>\n<code>--dry</code>: 실제로 빌드 하지 않지만 어떻게 될지 보여줍니다</li> <li>\n<code>--clean</code>: 지정된 프로젝트의 출력을 제거합니다 (<code>--dry</code>와 결합할 수 있습니다)</li> <li>\n<code>--force</code>: 모든 프로젝트가 최신이 아닌 것처럼 동작합니다</li> <li>\n<code>--watch</code>: 감시 모드 (<code>--verbose</code>를 제외한 다른 플래그와는 결합할 수 없습니다)</li> </ul> <h1 id=\"주의사항-caveats\" style=\"position:relative;\">주의사항 (Caveats)</h1> <p>일반적으로, <code>tsc</code>는 <code>noEmitOnError</code>가 활성화되어있지 않으면, 구문 또는 타입 오류가 있을 때 출력 (<code>.js</code>와 <code>.d.ts</code>)을 생성합니다. 이것을 증분 빌드 시스템에서 하는 것은 매우 안 좋습니다 - 만약 최신 상태가 아닌 의존성 중 하나가 새로운 오류가 있으면, 다음 빌드가 현재 최신 상태인 프로젝트를 빌드 하는 것을 건너뛸 것이기 때문에, <em>한번</em> 만 볼 수 있습니다. 이 이유로, <code>tsc -b</code>는 <code>noEmitOnError</code>가 모든 프로젝트에서 활성화된 것처럼 효과적으로 동작합니다.</p> <p>아무 빌드 출력 (<code>.js</code>, <code>.d.ts</code>, <code>.d.ts.map</code>, 등)을 검사하는 경우, 소스 제어 도구가 로컬 사본과 원격 사본 사이의 타임스탬프를 보존하는지에 따라 특정 소스 제어 연산 후에 <code>--force</code> 빌드를 실행해야 할 수도 있습니다.</p> <h1 id=\"msbuild\" style=\"position:relative;\">MSBuild</h1> <p>만약 msbuild 프로젝트가 있으면, 다음을 추가하여 빌드 모드를 proj 파일에</p> <pre data-language=\"xml\">    &lt;TypeScriptBuildMode&gt;true&lt;/TypeScriptBuildMode&gt;</pre> <p>활성화할 수 있습니다. 이는 제거뿐만 아니라 자동 증분 빌드를 활성화합니다.</p> <p><code>tsconfig.json</code> / <code>-p</code>와 마찬가지로, 기존 TypeScript 프로젝트 프로퍼티는 고려되지 않음에 유의하십시오 - 모든 설정은 tsconfig 파일을 사용하여 관리해야 합니다.</p> <p>일부 팀들은 tsconfig 파일들이 함께 병행하여 관리되는 프로젝트와 같은 <em>암시적</em> 그래프 순서를 가지며 msbuild 기반의 작업 흐름을 설정했습니다. 만약 해결책이 이와 같다면, 프로젝트 레퍼런스와 함께 <code>msbuild</code>를 <code>tsc -p</code>와 계속 사용할 수 있습니다; 이들은 완전히 상호 운용 가능합니다.</p> <h1 id=\"안내-guidance\" style=\"position:relative;\">안내 (Guidance)</h1> <h2 id=\"전체-구조-overall-structure\" style=\"position:relative;\">전체 구조 (Overall Structure)</h2> <p>더 많은 <code>tsconfig.json</code> 파일과 함께, 공통의 컴파일러 옵션들을 중앙 통제하기 위해 <a href=\"https://www.typescriptlang.org/docs/handbook/tsconfig-json.html\">구성 파일 상속</a>을 사용하고 싶으실 겁니다. 이 방법으로 여러 파일을 수정하지 않고 한 파일에서 설정을 변경할 수 있습니다.</p> <p>또 다른 좋은 방법은 단순히 모든 리프-노드 프로젝트에 <code>references</code>를 가지고 <code>files</code>를 빈 배열로 설정하는 “솔루션” <code>tsconfig.json</code> 파일을 갖는 것입니다 (그렇지 않으면 솔루션 파일 때문에 파일이 두 번 컴파일됩니다). 3.0부터 적어도 하나의 <code>reference</code>가 <code>tsconfig.json</code>에 있으면, 빈 <code>files</code> 배열을 갖는 것은 더 이상 오류가 아님에 유의하세요.</p> <p>이는 간단한 진입점을 제공합니다; 예를 들어, TypeScript 저장소에서 <code>src/tsconfig.json</code> 안에 모든 하위 프로젝트를 나열하기 때문에 단순히 <code>tsc -b src</code> 실행하여 모든 엔드포인트를 빌드 합니다.</p> <p>이 패턴들은 TypeScript 저장소에서 볼 수 있습니다 - 주 예제로 <code>src/tsconfig_base.json</code>, <code>src/tsconfig.json</code>, 그리고 <code>src/tsc/tsconfig.json</code>를 보세요.</p> <h2 id=\"상대-모듈-구조화하기-structuring-for-relative-modules\" style=\"position:relative;\">상대 모듈 구조화하기 (Structuring for relative modules)</h2> <p>일반적으로, 상대 모듈을 사용하여 저장소를 전환하는 데에는 별 다른 것이 필요 없습니다. 간단하게 부모 폴더의 <code>tsconfig.json</code> 파일을 각 하위 디렉터리 안에 위치시키고, 프로그램의 의도된 계층과 일치하도록 <code>reference</code>를 이 config 파일에 추가하십시오. <code>outDir</code>을 출력 폴더의 명시적인 하위 폴더로 설정하거나, <code>rootDir</code>을 모든 프로젝트 폴더의 공통 루트로 설정해야 합니다.</p> <h2 id=\"outfiles-구조화하기-structuring-for-outfiles\" style=\"position:relative;\">outFiles 구조화하기 (Structuring for outFiles)</h2> <p><code>outFile</code>을 사용한 컴파일의 레이아웃은 상대 경로가 크게 중요하지 않기 때문에 더 유연합니다. 기억해야 할 한 가지는 “마지막” 프로젝트 전까지는 <code>prepend</code>를 사용하고 싶지 않다는 것입니다 - 이는 빌드 시간을 개선하고 주어진 빌드에 필요한 I/O 숫자를 줄여줄 것입니다. TypeScript 저장소 자체는 여기서 좋은 레퍼런스입니다 - 몇 가지 “라이브러리” 프로젝트와 “엔드포인트” 프로젝트가 있습니다; “엔드포인트” 프로젝트는 가능한 작게 유지되고 있고 필요한 라이브러리만 pull 합니다.</p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2012-2023 Microsoft<br>Licensed under the Apache License, Version 2.0.<br>\n    <a href=\"https://www.typescriptlang.org/ko/docs/handbook/project-references.html\" class=\"_attribution-link\">https://www.typescriptlang.org/ko/docs/handbook/project-references.html</a>\n  </p>\n</div>\n","utility-types":"<h1>Utility Types</h1>\n<p>TypeScript는 일반적인 타입 변환을 쉽게 하기 위해서 몇 가지 유틸리티 타입을 제공합니다. 이러한 유틸리티는 전역으로 사용 가능합니다.</p> <h2 id=\"partialtype\" style=\"position:relative;\"><code>Partial&lt;Type&gt;</code></h2> <p><code>Type</code> 집합의 모든 프로퍼티를 선택적으로 타입을 생성합니다. 이 유틸리티는 주어진 타입의 모든 하위 타입 집합을 나타내는 타입을 반환합니다.</p> <h5 id=\"예제\" style=\"position:relative;\">예제</h5> <pre data-language=\"ts\">interface Todo {\n  title: string;\n  description: string;\n}\n \nfunction updateTodo(todo: Todo, fieldsToUpdate: Partial&lt;Todo&gt;) {\n  return { ...todo, ...fieldsToUpdate };\n}\n \nconst todo1 = {\n  title: \"organize desk\",\n  description: \"clear clutter\",\n};\n \nconst todo2 = updateTodo(todo1, {\n  description: \"throw out trash\",\n});</pre> <h2 id=\"requiredtype\" style=\"position:relative;\"><code>Required&lt;Type&gt;</code></h2> <p><code>Type</code> 집합의 모든 프로퍼티를 필수로 설정한 타입을 생성합니다. <a href=\"#partialtype\"><code>Partial</code></a>의 반대입니다.</p> <h5 id=\"예제-1\" style=\"position:relative;\">예제</h5> <pre data-language=\"ts\">interface Props {\n  a?: number;\n  b?: string;\n}\n \nconst obj: Props = { a: 5 };\n \nconst obj2: Required&lt;Props&gt; = { a: 5 };</pre> <h2 id=\"readonlytype\" style=\"position:relative;\"><code>Readonly&lt;Type&gt;</code></h2> <p><code>Type</code> 집합의 모든 프로퍼티<code>읽기 전용(readonly)</code>으로 설정한 타입을 생성합니다, 즉 생성된 타입의 프로퍼티는 재할당될 수 없습니다.</p> <h5 id=\"예제-2\" style=\"position:relative;\">예제</h5> <pre data-language=\"ts\">interface Todo {\n  title: string;\n}\n \nconst todo: Readonly&lt;Todo&gt; = {\n  title: \"Delete inactive users\",\n};\n \ntodo.title = \"Hello\";</pre> <p>이 유틸리티는 런타임에 실패할 할당 표현식을 표현할 때 유용합니다(예. <a href=\"https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Object/freeze\">frozen 객체</a> 의 프로퍼티에 재할당하려고 하는 경우).</p> <h5 id=\"objectfreeze\" style=\"position:relative;\"><code>Object.freeze</code></h5> <pre data-language=\"ts\">function freeze&lt;Type&gt;(obj: Type): Readonly&lt;Type&gt;;</pre> <h2 id=\"recordkeystype\" style=\"position:relative;\"><code>Record&lt;Keys,Type&gt;</code></h2> <p>타입 <code>Type</code>의 프로퍼티 <code>키</code>의 집합으로 타입을 생성합니다. 이 유틸리티는 타입의 프로퍼티를 다른 타입에 매핑 시키는데 사용될 수 있습니다.</p> <h5 id=\"예제-3\" style=\"position:relative;\">예제</h5> <pre data-language=\"ts\">interface PageInfo {\n  title: string;\n}\n \ntype Page = \"home\" | \"about\" | \"contact\";\n \nconst nav: Record&lt;Page, PageInfo&gt; = {\n  about: { title: \"about\" },\n  contact: { title: \"contact\" },\n  home: { title: \"home\" },\n};\n \nnav.about;</pre> <h2 id=\"picktype-keys\" style=\"position:relative;\"><code>Pick&lt;Type, Keys&gt;</code></h2> <p><code>Type</code>에서 프로퍼티 <code>Keys</code>의 집합을 선택해 타입을 생성합니다.</p> <h5 id=\"예제-4\" style=\"position:relative;\">예제</h5> <pre data-language=\"ts\">interface Todo {\n  title: string;\n  description: string;\n  completed: boolean;\n}\n \ntype TodoPreview = Pick&lt;Todo, \"title\" | \"completed\"&gt;;\n \nconst todo: TodoPreview = {\n  title: \"Clean room\",\n  completed: false,\n};\n \ntodo;</pre> <h2 id=\"omittype-keys\" style=\"position:relative;\"><code>Omit&lt;Type, Keys&gt;</code></h2> <p><code>Type</code>에서 모든 프로퍼티를 선택하고 <code>키</code>를 제거한 타입을 생성합니다.</p> <h5 id=\"예제-5\" style=\"position:relative;\">예제</h5> <pre data-language=\"ts\">interface Todo {\n  title: string;\n  description: string;\n  completed: boolean;\n}\n \ntype TodoPreview = Omit&lt;Todo, \"description\"&gt;;\n \nconst todo: TodoPreview = {\n  title: \"Clean room\",\n  completed: false,\n};\n \ntodo;</pre> <h2 id=\"excludetype-excludedunion\" style=\"position:relative;\"><code>Exclude&lt;Type, ExcludedUnion&gt;</code></h2> <p><code>ExcludedUnion</code>에 할당할 수 있는 모든 유니온 멤버를 <code>Type</code>에서 제외하여 타입을 생성합니다.</p> <h5 id=\"예제-6\" style=\"position:relative;\">예제</h5> <pre data-language=\"ts\">type T0 = Exclude&lt;\"a\" | \"b\" | \"c\", \"a\"&gt;;\ntype T1 = Exclude&lt;\"a\" | \"b\" | \"c\", \"a\" | \"b\"&gt;;\ntype T2 = Exclude&lt;string | number | (() =&gt; void), Function&gt;;</pre> <h2 id=\"extracttype-union\" style=\"position:relative;\"><code>Extract&lt;Type, Union&gt;</code></h2> <p><code>Union</code>에 할당할 수 있는 모든 유니온 멤버를 <code>Type</code>에서 가져와서 타입을 생성합니다.</p> <h5 id=\"예제-7\" style=\"position:relative;\">예제</h5> <pre data-language=\"ts\">type T0 = Extract&lt;\"a\" | \"b\" | \"c\", \"a\" | \"f\"&gt;;\ntype T1 = Extract&lt;string | number | (() =&gt; void), Function&gt;;</pre> <h2 id=\"nonnullabletype\" style=\"position:relative;\"><code>NonNullable&lt;Type&gt;</code></h2> <p><code>Type</code>에서 <code>null</code>과 <code>정의되지 않은 것(undefined)</code>을 제외하고 타입을 생성합니다.</p> <h5 id=\"예제-8\" style=\"position:relative;\">예제</h5> <pre data-language=\"ts\">type T0 = NonNullable&lt;string | number | undefined&gt;;\ntype T1 = NonNullable&lt;string[] | null | undefined&gt;;</pre> <h2 id=\"parameterstype\" style=\"position:relative;\"><code>Parameters&lt;Type&gt;</code></h2> <p>함수 타입 <code>Type</code>의 매개변수에 사용된 타입에서 튜플 타입을 생성합니다.</p> <h5 id=\"예제-9\" style=\"position:relative;\">예제</h5> <pre data-language=\"ts\">declare function f1(arg: { a: number; b: string }): void;\n \ntype T0 = Parameters&lt;() =&gt; string&gt;;\ntype T1 = Parameters&lt;(s: string) =&gt; void&gt;;\ntype T2 = Parameters&lt;&lt;T&gt;(arg: T) =&gt; T&gt;;\ntype T3 = Parameters&lt;typeof f1&gt;;\ntype T4 = Parameters&lt;any&gt;;\ntype T5 = Parameters&lt;never&gt;;\ntype T6 = Parameters&lt;string&gt;;\ntype T7 = Parameters&lt;Function&gt;;</pre> <h2 id=\"constructorparameterstype\" style=\"position:relative;\"><code>ConstructorParameters&lt;Type&gt;</code></h2> <p>생성자 함수 타입의 타입에서 튜플 또는 배열 타입을 생성합니다. 모든 매개변수 타입을 가지는 튜플 타입(또는 <code>Type</code>이 함수가 아닌 경우 타입 <code>never</code>)을 생성합니다.</p> <h5 id=\"예제-10\" style=\"position:relative;\">예제</h5> <pre data-language=\"ts\">type T0 = ConstructorParameters&lt;ErrorConstructor&gt;;\ntype T1 = ConstructorParameters&lt;FunctionConstructor&gt;;\ntype T2 = ConstructorParameters&lt;RegExpConstructor&gt;;\ntype T3 = ConstructorParameters&lt;any&gt;;\n \ntype T4 = ConstructorParameters&lt;Function&gt;;</pre> <h2 id=\"returntypetype\" style=\"position:relative;\"><code>ReturnType&lt;Type&gt;</code></h2> <p>함수 <code>Type</code>의 반환 타입으로 구성된 타입을 생성합니다.</p> <h5 id=\"예제-11\" style=\"position:relative;\">예제</h5> <pre data-language=\"ts\">declare function f1(): { a: number; b: string };\n \ntype T0 = ReturnType&lt;() =&gt; string&gt;;\ntype T1 = ReturnType&lt;(s: string) =&gt; void&gt;;\ntype T2 = ReturnType&lt;&lt;T&gt;() =&gt; T&gt;;\ntype T3 = ReturnType&lt;&lt;T extends U, U extends number[]&gt;() =&gt; T&gt;;\ntype T4 = ReturnType&lt;typeof f1&gt;;\ntype T5 = ReturnType&lt;any&gt;;\ntype T6 = ReturnType&lt;never&gt;;\ntype T7 = ReturnType&lt;string&gt;;\ntype T8 = ReturnType&lt;Function&gt;;</pre> <h2 id=\"instancetypetype\" style=\"position:relative;\"><code>InstanceType&lt;Type&gt;</code></h2> <p><code>Type</code>의 생성자 함수의 인스턴스 타입으로 구성된 타입을 생성합니다.</p> <h5 id=\"예제-12\" style=\"position:relative;\">예제</h5> <pre data-language=\"ts\">class C {\n  x = 0;\n  y = 0;\n}\n \ntype T0 = InstanceType&lt;typeof C&gt;;\ntype T1 = InstanceType&lt;any&gt;;\ntype T2 = InstanceType&lt;never&gt;;\ntype T3 = InstanceType&lt;string&gt;;\ntype T4 = InstanceType&lt;Function&gt;;</pre> <h2 id=\"thisparametertypetype\" style=\"position:relative;\"><code>ThisParameterType&lt;Type&gt;</code></h2> <p>함수 타입의 <a href=\"https://www.typescriptlang.org/docs/handbook/functions.html#this-parameters\">this</a> 매개변수의 타입, 또는 함수 타입에 <code>this</code>매개변수가 없을 경우 <a href=\"https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-0.html#new-unknown-top-type\">unknown</a> 을 추출합니다.</p> <h5 id=\"예제-13\" style=\"position:relative;\">예제</h5> <pre data-language=\"ts\">function toHex(this: Number) {\n  return this.toString(16);\n}\n \nfunction numberToString(n: ThisParameterType&lt;typeof toHex&gt;) {\n  return toHex.apply(n);\n}</pre> <h2 id=\"omitthisparametertype\" style=\"position:relative;\"><code>OmitThisParameter&lt;Type&gt;</code></h2> <p><code>Type</code>에서 <a href=\"https://www.typescriptlang.org/docs/handbook/functions.html#this-parameters\"><code>this</code></a> 매개변수를 제거합니다. <code>Type</code>에 명시적으로 선언된 <code>this</code>매개변수가 없는 경우에, 단순히 <code>Type</code>입니다. 반면에, <code>this</code>매개변수가 없는 새로운 함수 타입은 <code>Type</code>에서 생성됩니다. 제네릭은 사라지고 마지막 오버로드 시그니처만 새로운 함수 타입으로 전파됩니다.</p> <h5 id=\"예제-14\" style=\"position:relative;\">예제</h5> <pre data-language=\"ts\">function toHex(this: Number) {\n  return this.toString(16);\n}\n \nconst fiveToHex: OmitThisParameter&lt;typeof toHex&gt; = toHex.bind(5);\n \nconsole.log(fiveToHex());</pre> <h2 id=\"thistypetype\" style=\"position:relative;\"><code>ThisType&lt;Type&gt;</code></h2> <p>이 유틸리티는 변형된 타입을 반환하지 않습니다. 대신에, 문맥적 <a href=\"https://www.typescriptlang.org/docs/handbook/functions.html#this\"><code>this</code></a> 타입에 표시하는 역할을 합니다. 이 유틸리티를 사용하기 위해서는 <code>--noImplicitThis</code> 플래그를 사용해야 하는 것을 기억하세요.</p> <h5 id=\"예제-15\" style=\"position:relative;\">예제</h5> <pre data-language=\"ts\">type ObjectDescriptor&lt;D, M&gt; = {\n  data?: D;\n  methods?: M &amp; ThisType&lt;D &amp; M&gt;; // Type of 'this' in methods is D &amp; M\n};\n \nfunction makeObject&lt;D, M&gt;(desc: ObjectDescriptor&lt;D, M&gt;): D &amp; M {\n  let data: object = desc.data || {};\n  let methods: object = desc.methods || {};\n  return { ...data, ...methods } as D &amp; M;\n}\n \nlet obj = makeObject({\n  data: { x: 0, y: 0 },\n  methods: {\n    moveBy(dx: number, dy: number) {\n      this.x += dx; // Strongly typed this\n      this.y += dy; // Strongly typed this\n    },\n  },\n});\n \nobj.x = 10;\nobj.y = 20;\nobj.moveBy(5, 5);</pre> <p>위 예제에서, <code>makeObject</code>의 인수인 <code>methods</code> 객체는 <code>ThisType&lt;D &amp; M&gt;</code> 을 포함한 문맥적 타입을 가지고 따라서 <code>methods</code> 객체의 메서드 안에 <a href=\"https://www.typescriptlang.org/docs/handbook/functions.html#this\">this</a> 타입은 <code>{ x: number, y: number } &amp; { moveBy(dx: number, dy: number): number }</code>입니다. <code>methods</code> 프로퍼티의 타입은 추론 대상인 동시에 메서드의 <code>this</code> 타입의 출처인 것에 주목하세요.</p> <p><code>ThisType&lt;T&gt;</code> 마커 인터페이스는 단지 <code>lib.d.ts</code>에 선언된 빈 인터페이스입니다. 객체 리터럴의 문맥적 타입으로 인식되는 것을 넘어, 그 인터페이스는 빈 인터페이스처럼 동작합니다.</p> <h2 id=\"내장-문자열-조작-타입\" style=\"position:relative;\">내장 문자열 조작 타입</h2> <h3 id=\"uppercasestringtype\" style=\"position:relative;\"><code>Uppercase&lt;StringType&gt;</code></h3> <h3 id=\"lowercasestringtype\" style=\"position:relative;\"><code>Lowercase&lt;StringType&gt;</code></h3> <h3 id=\"capitalizestringtype\" style=\"position:relative;\"><code>Capitalize&lt;StringType&gt;</code></h3> <h3 id=\"uncapitalizestringtype\" style=\"position:relative;\"><code>Uncapitalize&lt;StringType&gt;</code></h3> <p>템플릿 문자열 리터럴에서의 문자열 조작을 돕기 위해, TypeScript는 타입 시스템 내에서 문자열 조작에 사용할 수 있는 타입 집합이 포함되어 있습니다. <a href=\"https://www.typescriptlang.org/docs/handbook/2/template-literal-types.html#intrinsic-string-manipulation-types\">이 링크</a>에서 예제를 확인하세요.</p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2012-2023 Microsoft<br>Licensed under the Apache License, Version 2.0.<br>\n    <a href=\"https://www.typescriptlang.org/ko/docs/handbook/utility-types.html\" class=\"_attribution-link\">https://www.typescriptlang.org/ko/docs/handbook/utility-types.html</a>\n  </p>\n</div>\n","2/everyday-types":"<h1>Everyday Types</h1>\n<p>이번 장에서는 JavaScript 코드에서 찾아볼 수 있는 가장 흔한 타입들을 다루고, 이 타입들을 TypeScript에서 어떻게 기술하는지 각각의 대응하는 방식에 대하여 설명하겠습니다. 이 문서에서 빠짐없이 전부 다루고자 하는 것이 아니며, 타입을 만들고 사용하는 더 많은 방법들은 이후 이어지는 장에서 다룰 것입니다.</p> <p>타입은 단지 타입 표기 이외에도 훨씬 다양한 <em>위치</em>에 나타날 수 있습니다. 타입 자체에 대하여 배우는 것과 더불어, 새로운 구조체를 만들고자 할 때 타입을 참조하는 경우들에 대하여 알아볼 것입니다.</p> <p>우선 JavaScript 또는 TypeScript 코드를 작성할 때 가장 기본적이면서 흔히 만날 수 있는 타입들을 다시 살펴보는 데에서 시작해보겠습니다. 이 타입들은 이후에 다루는 보다 복잡한 타입을 이루는 핵심 구성 요소입니다.</p> <h2 id=\"원시-타입--string-number-그리고-boolean\" style=\"position:relative;\">원시 타입 : <code>string</code>, <code>number</code>, 그리고 <code>boolean</code>\n</h2> <p>JavaScript에서 아주 흔하게 사용되는 세 가지의 <a href=\"https://developer.mozilla.org/ko/docs/Glossary/Primitive\">원시 타입</a>으로 <code>string</code>, <code>number</code>, 그리고 <code>boolean</code>이 있습니다. 이 타입들은 TypeScript에서 각자 대응하는 타입이 존재합니다. 아마도 예상하셨듯이, 이 타입들은 JavaScript에서 각 타입별 값에 <code>typeof</code> 연산자를 사용하였을 때 얻을 수 있는 것과 동일한 이름을 가집니다.</p> <ul> <li>\n<code>string</code>은 <code>\"Hello, world\"</code>와 같은 문자열 값을 나타냅니다</li> <li>\n<code>number</code>은 <code>42</code>와 같은 숫자를 나타냅니다. JavaScript는 정수를 위한 런타임 값을 별도로 가지지 않으므로, <code>int</code> 또는 <code>float</code>과 같은 것은 존재하지 않습니다. 모든 수는 단순히 <code>number</code>입니다</li> <li>\n<code>boolean</code>은 <code>true</code>와 <code>false</code>라는 두 가지 값만을 가집니다</li> </ul> <blockquote> <p><code>String</code>, <code>Number</code>, <code>Boolean</code>와 같은 (대문자로 시작하는) 타입은 유효한 타입이지만, 코드상에서 이러한 특수 내장 타입을 사용하는 경우는 극히 드뭅니다. <em>항상</em> <code>string</code>, <code>number</code>, <code>boolean</code> 타입을 사용하세요.</p> </blockquote> <h2 id=\"배열\" style=\"position:relative;\">배열</h2> <p><code>[1, 2, 3]</code>과 같은 배열의 타입을 지정할 때 <code>number[]</code> 구문을 사용할 수 있습니다. 이 구문은 모든 타입에서 사용할 수 있습니다(예를 들어, <code>string[]</code>은 문자열의 배열입니다). 위 타입은 <code>Array&lt;number&gt;</code>와 같은 형태로 적을 수 있으며, 동일한 의미를 가집니다. <code>T&lt;U&gt;</code> 구문에 대한 내용은 <em>제네릭</em> 을 다룰 때 좀 더 알아보겠습니다.</p> <blockquote> <p><code>[number]</code>는 전혀 다른 의미를 가집니다. <em>튜플 타입</em> 부분을 참조하세요.</p> </blockquote> <h2 id=\"any\" style=\"position:relative;\"><code>any</code></h2> <p>TypeScript는 또한 <code>any</code>라고 불리는 특별한 타입을 가지고 있으며, 특정 값으로 인하여 타입 검사 오류가 발생하는 것을 원하지 않을 때 사용할 수 있습니다.</p> <p>어떤 값의 타입이 <code>any</code>이면, 해당 값에 대하여 임의의 속성에 접근할 수 있고(이때 반환되는 값의 타입도 <code>any</code>입니다), 함수인 것처럼 호출할 수 있고, 다른 임의 타입의 값에 할당하거나(받거나), 그 밖에도 구문적으로 유효한 것이라면 무엇이든 할 수 있습니다.</p> <pre data-language=\"ts\">let obj: any = { x: 0 };\n// 아래 이어지는 코드들은 모두 오류 없이 정상적으로 실행됩니다.\n// `any`를 사용하면 추가적인 타입 검사가 비활성화되며,\n// 당신이 TypeScript보다 상황을 더 잘 이해하고 있다고 가정합니다.\nobj.foo();\nobj();\nobj.bar = 100;\nobj = \"hello\";\nconst n: number = obj;</pre> <p><code>any</code> 타입은 코드상의 특정 라인에 문제가 없다고 TypeScript를 안심시킨다는 목적 단지 하나 때문에 긴 타입을 새로 정의하고 싶지 않을 때 유용하게 사용할 수 있습니다.</p> <h3 id=\"noimplicitany\" style=\"position:relative;\"><code>noImplicitAny</code></h3> <p>타입이 지정되지 않은 값에 대하여 TypeScript가 문맥으로부터 그 타입을 추론해낼 수 없다면, 컴파일러는 <code>any</code> 타입을 부여하는 것이 기본 동작입니다.</p> <p>하지만 이런 상황은 보통 선호되지 않습니다. 왜냐하면 <code>any</code>는 타입 검사가 이루어지지 않기 때문입니다. 컴파일러 플래그 <a href=\"https://www.typescriptlang.org/tsconfig#noImplicitAny\"><code>noImplicitAny</code></a>를 사용하면 암묵적으로 <code>any</code>로 간주하는 모든 경우에 오류를 발생시킵니다.</p> <h2 id=\"변수에-대한-타입-표기\" style=\"position:relative;\">변수에 대한 타입 표기</h2> <p><code>const</code>, <code>var</code>, 또는 <code>let</code> 등을 사용하여 변수를 선언할 때, 변수의 타입을 명시적으로 지정하기 위하여 타입 표기를 추가할 수 있으며 이는 선택 사항입니다.</p> <pre data-language=\"ts\">let myName: string = \"Alice\";</pre> <blockquote> <p>TypeScript는 <code>int x = 0;</code>과 같이 “타입을 왼쪽에 쓰는” 식의 표기법을 사용하지 않습니다. 타입 표기는 항상 타입의 대상 <em>뒤쪽에</em> 위치합니다.</p> </blockquote> <p>하지만 대부분의 경우, 타입 표기는 필요하지 않습니다. 가능하다면 TypeScript는 자동으로 코드 내의 있는 타입들을 <em>추론</em>하고자 시도합니다. 예를 들어, 변수의 타입은 해당 변수의 초깃값의 타입을 바탕으로 추론됩니다.</p> <pre data-language=\"ts\">// 타입 표기가 필요하지 않습니다. 'myName'은 'string' 타입으로 추론됩니다.\nlet myName = \"Alice\";</pre> <p>대부분의 경우 추론 규칙을 명시적으로 학습하지 않아도 됩니다. 이제 막 TypeScript를 시작하는 단계라면, 가능한 타입 표기를 적게 사용하도록 해보세요. 코드 흐름을 완전히 파악하는 데에 타입이 그다지 많이 필요하지 않다는 사실에 놀라실 겁니다.</p> <h2 id=\"함수\" style=\"position:relative;\">함수</h2> <p>함수는 JavaScript에서 데이터를 주고 받는 주요 수단입니다. TypeScript에서는 함수의 입력 및 출력 타입을 지정할 수 있습니다.</p> <h3 id=\"매개변수-타입-표기\" style=\"position:relative;\">매개변수 타입 표기</h3> <p>함수를 선언할 때, 함수가 허용할 매개변수 타입을 선언하기 위하여 각 매개변수 뒤에 타입을 표기할 수 있습니다. 매개변수 타입은 매개변수 이름 뒤에 표기합니다.</p> <pre data-language=\"ts\">// 매개변수 타입 표기\nfunction greet(name: string) {\n  console.log(\"Hello, \" + name.toUpperCase() + \"!!\");\n}</pre> <p>매개변수에 타입이 표기되었다면, 해당 함수에 대한 인자는 검사가 이루어집니다.</p> <pre data-language=\"ts\">// 만약 실행되면 런타임 오류가 발생하게 됩니다!\ngreet(42);</pre> <blockquote> <p>매개변수에 타입을 표기하지 않았더라도, 여전히 TypeScript는 올바른 개수의 인자가 전달되었는지 여부를 검사합니다.</p> </blockquote> <h3 id=\"반환-타입-표기\" style=\"position:relative;\">반환 타입 표기</h3> <p>반환 타입 또한 표기할 수 있습니다. 반환 타입은 매개변수 목록 뒤에 표기합니다.</p> <pre data-language=\"ts\">function getFavoriteNumber(): number {\n  return 26;\n}</pre> <p>변수의 타입 표기와 마찬가지로, 반환 타입은 표기하지 않아도 되는 것이 일반적입니다. 왜냐하면 TypeScript가 해당 함수에 들어있는 <code>return</code> 문을 바탕으로 반환 타입을 추론할 것이기 때문입니다. 위 예시에서 사용된 타입 표기는 큰 의미를 갖지 않습니다. 때에 따라 문서화를 목적으로, 또는 코드의 잘못된 수정을 미연에 방지하고자, 혹은 지극히 개인적인 선호에 의하여 명시적인 타입 표기를 수행하는 코드도 존재합니다.</p> <h3 id=\"익명-함수\" style=\"position:relative;\">익명 함수</h3> <p>익명 함수는 함수 선언과는 조금 다릅니다. 함수가 코드상에서 위치한 곳을 보고 해당 함수가 어떻게 호출될지 알아낼 수 있다면, TypeScript는 해당 함수의 매개 변수에 자동으로 타입을 부여합니다.</p> <p>아래는 그 예시입니다.</p> <pre data-language=\"ts\">// 아래 코드에는 타입 표기가 전혀 없지만, TypeScript는 버그를 감지할 수 있습니다.\nconst names = [\"Alice\", \"Bob\", \"Eve\"];\n \n// 함수에 대한 문맥적 타입 부여\nnames.forEach(function (s) {\n  console.log(s.toUppercase());\n});\n \n// 화살표 함수에도 문맥적 타입 부여는 적용됩니다\nnames.forEach((s) =&gt; {\n  console.log(s.toUppercase());\n});</pre> <p>매개 변수 <code>s</code>에는 타입이 표기되지 않았음에도 불구하고, TypeScript는 <code>s</code>의 타입을 알아내기 위하여 배열의 추론된 타입과 더불어 <code>forEach</code> 함수의 타입을 활용하였습니다.</p> <p>이 과정은 <em>문맥적 타입 부여</em>라고 불리는데, 왜냐하면 함수가 실행되는 <em>문맥</em>을 통하여 해당 함수가 가져야 하는 타입을 알 수 있기 때문입니다. 추론 규칙과 비슷하게, 이 과정이 어떻게 일어나는지를 명시적으로 배울 필요는 없지만, 이것이 <em>실제로 일어나는 과정</em>이라는 것을 이해하면 타입 표기가 불필요한 경우를 구분하는 데에 도움이 됩니다. 값이 발생하는 문맥이 해당 값의 타입에 영향을 끼치는 예시들은 이후에 살펴보도록 하겠습니다.</p> <h2 id=\"객체-타입\" style=\"position:relative;\">객체 타입</h2> <p>원시 타입을 제외하고 가장 많이 마주치는 타입은 <em>객체 타입</em>입니다. 객체는 프로퍼티를 가지는 JavaScript 값을 말하는데, 대부분의 경우가 이에 해당하죠! 객체 타입을 정의하려면, 해당 객체의 프로퍼티들과 각 프로퍼티의 타입들을 나열하기만 하면 됩니다.</p> <p>예를 들어, 아래 함수는 좌표로 보이는 객체를 인자로 받고 있습니다.</p> <pre data-language=\"ts\">// 매개 변수의 타입은 객체로 표기되고 있습니다.\nfunction printCoord(pt: { x: number; y: number }) {\n  console.log(\"The coordinate's x value is \" + pt.x);\n  console.log(\"The coordinate's y value is \" + pt.y);\n}\nprintCoord({ x: 3, y: 7 });</pre> <p>위에서 매개변수는 <code>x</code>와 <code>y</code>라는 두 개의 프로퍼티로 이루어진 타입으로 표기되고 있는데, 두 값은 모두 <code>number</code> 타입입니다. 각 프로퍼티를 구분할 때 <code>,</code> 또는 <code>;</code>를 사용할 수 있고, 가장 마지막에 위치한 구분자의 표기는 선택 사항입니다.</p> <p>각 프로퍼티의 타입 표기 또한 선택 사항입니다. 만약 타입을 지정하지 않는다면, 해당 프로퍼티는 <code>any</code> 타입으로 간주합니다.</p> <h3 id=\"옵셔널-프로퍼티\" style=\"position:relative;\">옵셔널 프로퍼티</h3> <p>객체 타입은 일부 또는 모든 프로퍼티의 타입을 선택적인 타입, 즉 <em>옵셔널</em>로 지정할 수 있습니다. 프로퍼티 이름 뒤에 <code>?</code>를 붙이면 됩니다.</p> <pre data-language=\"ts\">function printName(obj: { first: string; last?: string }) {\n  // ...\n}\n// 둘 다 OK\nprintName({ first: \"Bob\" });\nprintName({ first: \"Alice\", last: \"Alisson\" });</pre> <p>JavaScript에서는 존재하지 않는 프로퍼티에 접근하였을 때, 런타임 오류가 발생하지 않고 <code>undefined</code> 값을 얻게 됩니다. 이 때문에 옵셔널 프로퍼티를 <em>읽었을</em> 때, 해당 값을 사용하기에 앞서 <code>undefined</code>인지 여부를 확인해야 합니다.</p> <pre data-language=\"ts\">function printName(obj: { first: string; last?: string }) {\n  // 오류 - `obj.last`의 값이 제공되지 않는다면 프로그램이 멈추게 됩니다!\n  console.log(obj.last.toUpperCase());\n  if (obj.last !== undefined) {\n    // OK\n    console.log(obj.last.toUpperCase());\n  }\n \n  // 최신 JavaScript 문법을 사용하였을 때 또 다른 안전한 코드\n  console.log(obj.last?.toUpperCase());\n}</pre> <h2 id=\"유니언-타입\" style=\"position:relative;\">유니언 타입</h2> <p>TypeScript의 타입 시스템에서는 기존의 타입을 기반으로 다양한 연산자를 사용하여 새로운 타입을 만들 수 있습니다. 몇몇 타입들을 사용하는 법을 알았으니, 이제 이 타입들을 <em>조합하여</em> 흥미로운 방식으로 사용해볼 시간입니다.</p> <h3 id=\"유니언-타입-정의하기\" style=\"position:relative;\">유니언 타입 정의하기</h3> <p>타입을 조합하는 첫 번째 방법은 <em>유니언</em> 타입을 사용하는 것입니다. 유니언 타입은 서로 다른 두 개 이상의 타입들을 사용하여 만드는 것으로, 유니언 타입의 값은 타입 조합에 사용된 타입 중 <em>무엇이든 하나</em>를 타입으로 가질 수 있습니다. 조합에 사용된 각 타입을 유니언 타입의 <em>멤버</em>라고 부릅니다.</p> <p>문자열 또는 숫자를 받을 수 있는 함수를 작성해보겠습니다.</p> <pre data-language=\"ts\">function printId(id: number | string) {\n  console.log(\"Your ID is: \" + id);\n}\n// OK\nprintId(101);\n// OK\nprintId(\"202\");\n// 오류\nprintId({ myID: 22342 });</pre> <h3 id=\"유니언-타입-사용하기\" style=\"position:relative;\">유니언 타입 사용하기</h3> <p>유니언 타입에 맞는 값을 <em>제공하는</em> 것은 간단합니다. 유니언 타입의 멤버 중 하나에 해당하는 타입을 제공하면 됩니다. 유니언 타입인 값이 코드상에 <em>존재할 때</em>, 이를 어떻게 사용해야 할까요?</p> <p>TypeScript에서 유니언을 다룰 때는 해당 유니언 타입의 <em>모든</em> 멤버에 대하여 유효한 작업일 때에만 허용됩니다. 예를 들어 <code>string | number</code>라는 유니언 타입의 경우, <code>string</code> 타입에만 유효한 메서드는 사용할 수 없습니다.</p> <pre data-language=\"ts\">function printId(id: number | string) {\n  console.log(id.toUpperCase());\n}</pre> <p>이를 해결하려면 코드상에서 유니언을 <em>좁혀야</em> 하는데, 이는 타입 표기가 없는 JavaScript에서 벌어지는 일과 동일합니다. <em>좁히기</em>란 TypeScript가 코드 구조를 바탕으로 어떤 값을 보다 구체적인 타입으로 추론할 수 있을 때 발생합니다.</p> <p>예를 들어, TypeScript는 오직 <code>string</code> 값만이 <code>typeof</code> 연산의 결괏값으로 <code>\"string\"</code>을 가질 수 있다는 것을 알고 있습니다.</p> <pre data-language=\"ts\">function printId(id: number | string) {\n  if (typeof id === \"string\") {\n    // 이 분기에서 id는 'string' 타입을 가집니다\n \n    console.log(id.toUpperCase());\n  } else {\n    // 여기에서 id는 'number' 타입을 가집니다\n    console.log(id);\n  }\n}</pre> <p>또 다른 예시는 <code>Array.isArray</code>와 같은 함수를 사용하는 것입니다.</p> <pre data-language=\"ts\">function welcomePeople(x: string[] | string) {\n  if (Array.isArray(x)) {\n    // 여기에서 'x'는 'string[]' 타입입니다\n    console.log(\"Hello, \" + x.join(\" and \"));\n  } else {\n    // 여기에서 'x'는 'string' 타입입니다\n    console.log(\"Welcome lone traveler \" + x);\n  }\n}</pre> <p><code>else</code> 분기 문에서는 별도 처리를 하지 않아도 된다는 점에 유의하시기 바랍니다. <code>x</code>의 타입이 <code>string[]</code>가 아니라면, <code>x</code>의 타입은 반드시 <code>string</code>일 것입니다.</p> <p>때로는 유니언의 모든 멤버가 무언가 공통점을 가질 수도 있습니다. 에를 들어, 배열과 문자열은 둘 다 <code>slice</code> 메서드를 내장합니다. 유니언의 모든 멤버가 어떤 프로퍼티를 공통으로 가진다면, 좁히기 없이도 해당 프로퍼티를 사용할 수 있게 됩니다.</p> <pre data-language=\"ts\">// 반환 타입은 'number[] | string'으로 추론됩니다\nfunction getFirstThree(x: number[] | string) {\n  return x.slice(0, 3);\n}</pre> <blockquote> <p>유니언은 의미상 <em>합집합</em>을 뜻하는데, 실제로는 유니언 타입이 프로퍼티들의 <em>교집합</em>을 가리키는 것처럼 보여 헷갈리게 느낄 수 있습니다. 이는 지극히 우연이 아닙니다. <em>유니언</em>이라는 명칭은 타입 이론에서 비롯된 것입니다. <code>number | string</code> <em>유니언</em> 타입은 각각의 타입을 가지는 <em>값들에 대하여</em> 합집합을 취하여 구성됩니다. 두 집합과 각각의 집합에 대한 특성이 주어졌을 때, 두 집합의 <em>유니언</em>에는 각각의 특성들의 <em>교집합</em>만이 적용된다는 점에 유의하시기 바랍니다. 예를 들어, 한 방에는 모자를 쓰고 키가 큰 사람들이 있고 다른 방에는 모자를 쓰고 스페인어를 사용하는 사람들이 있다고 합시다. 이때 두 방을 합친다면, <em>모든</em> 사람들에 대하여 우리가 알 수 있는 사실은 바로 누구나 반드시 모자를 쓰고 있다는 것입니다.</p> </blockquote> <h2 id=\"타입-별칭\" style=\"position:relative;\">타입 별칭</h2> <p>지금까지는 객체 타입과 유니언 타입을 사용할 때 직접 해당 타입을 표기하였습니다. 이는 편리하지만, 똑같은 타입을 한 번 이상 재사용하거나 또 다른 이름으로 부르고 싶은 경우도 존재합니다.</p> <p><em>타입 별칭</em>은 바로 이런 경우를 위하여 존재하며, <em>타입</em>을 위한 <em>이름</em>을 제공합니다. 타입 별칭의 구문은 아래와 같습니다.</p> <pre data-language=\"ts\">type Point = {\n  x: number;\n  y: number;\n};\n \n// 앞서 사용한 예제와 동일한 코드입니다\nfunction printCoord(pt: Point) {\n  console.log(\"The coordinate's x value is \" + pt.x);\n  console.log(\"The coordinate's y value is \" + pt.y);\n}\n \nprintCoord({ x: 100, y: 100 });</pre> <p>타입 별칭을 사용하면 단지 객체 타입뿐이 아닌 모든 타입에 대하여 새로운 이름을 부여할 수 있습니다. 예를 들어, 아래와 같이 유니언 타입에 대하여 타입 별칭을 부여할 수도 있습니다.</p> <pre data-language=\"ts\">type ID = number | string;</pre> <p>타입 별칭은 <em>단지</em> 별칭에 지나지 않는다는 점에 유의하시기 바랍니다. 즉, 타입 별칭을 사용하여도 동일 타입에 대하여 각기 구별되는 “여러 버전”을 만드는 것은 아닙니다. 별칭을 사용하는 것은, 별도로 이름 붙인 타입을 새로 작성하는 것입니다. 다시 말해, 아래 코드는 틀린 것처럼 <em>보일 수</em> 있지만, TypeScript에서는 이것이 정상인데 그 이유는 각각의 타입들이 동일 타입에 대한 별칭들이기 때문입니다.</p> <pre data-language=\"ts\">type UserInputSanitizedString = string;\n \nfunction sanitizeInput(str: string): UserInputSanitizedString {\n  return sanitize(str);\n}\n \n// 보안 처리를 마친 입력을 생성\nlet userInput = sanitizeInput(getInput());\n \n// 물론 새로운 문자열을 다시 대입할 수도 있습니다\nuserInput = \"new input\";</pre> <h2 id=\"인터페이스\" style=\"position:relative;\">인터페이스</h2> <p><em>인터페이스 선언</em>은 객체 타입을 만드는 또 다른 방법입니다.</p> <pre data-language=\"ts\">interface Point {\n  x: number;\n  y: number;\n}\n \nfunction printCoord(pt: Point) {\n  console.log(\"The coordinate's x value is \" + pt.x);\n  console.log(\"The coordinate's y value is \" + pt.y);\n}\n \nprintCoord({ x: 100, y: 100 });</pre> <p>타입 별칭을 사용한 경우와 마찬가지로, 위 예시 코드는 마치 타입이 없는 임의의 익명 객체를 사용하는 것처럼 동작합니다. TypeScript는 오직 <code>printCoord</code>에 전달된 값의 <em>구조</em>에만 관심을 가집니다. 즉, 예측된 프로퍼티를 가졌는지 여부만을 따집니다. 이처럼, 타입이 가지는 구조와 능력에만 관심을 가진다는 점은 TypeScript가 <em>구조적</em> 타입 시스템이라고 불리는 이유입니다.</p> <h3 id=\"타입-별칭과-인터페이스의-차이점\" style=\"position:relative;\">타입 별칭과 인터페이스의 차이점</h3> <p>타입 별칭과 인터페이스는 매우 유사하며, 대부분의 경우 둘 중 하나를 자유롭게 선택하여 사용할 수 있습니다. <code>interface</code>가 가지는 대부분의 기능은 <code>type</code>에서도 동일하게 사용 가능합니다. 이 둘의 가장 핵심적인 차이는, 타입은 새 프로퍼티를 추가하도록 개방될 수 없는 반면, 인터페이스의 경우 항상 확장될 수 있다는 점입니다.</p> <table class=\"full-width-table\"> <tbody> <tr> <th><code>인터페이스</code></th> <th><code>타입</code></th> </tr> <tr> <td> <p>인터페이스 확장하기</p> <code><pre data-language=\"typescript\">\r\ninterface Animal {\r\n  name: string\r\n}\r\ninterface Bear extends Animal {\r\n  honey: boolean\r\n}\r\nconst bear = getBear()\r\nbear.name\r\nbear.honey\r\n        </pre></code> </td> <td> <p>교집합을 통하여 타입 확장하기</p> <code><pre data-language=\"typescript\">\r\ntype Animal = {\r\n  name: string\r\n}\r\ntype Bear = Animal &amp; {\r\n  honey: Boolean\r\n}\r\nconst bear = getBear();\r\nbear.name;\r\nbear.honey;\r\n        </pre></code> </td> </tr> <tr> <td> <p>기존의 인터페이스에 새 필드를 추가하기</p> <code><pre data-language=\"typescript\">\r\ninterface Window {\r\n  title: string\r\n}\r\ninterface Window {\r\n  ts: TypeScriptAPI\r\n}\r\nconst src = 'const a = \"Hello World\"';\r\nwindow.ts.transpileModule(src, {});\r\n        </pre></code> </td> <td> <p>타입은 생성된 뒤에는 달라질 수 없다</p> <code><pre data-language=\"typescript\">\r\ntype Window = {\r\n  title: string\r\n}\r\ntype Window = {\r\n  ts: TypeScriptAPI\r\n}\r\n // Error: Duplicate identifier 'Window'.\r\n        </pre></code> </td> </tr> </tbody> </table> <p>위 개념에 대하여서는 이후에 이어지는 장에서 좀 더 자세히 배우므로, 지금 위 내용을 잘 이해하지 못하였더라도 걱정하지 마세요.</p> <ul> <li>TypeScript 4.2 이전 버전에서는, 타입 별칭 이름이 오류 메시지에 <a href=\"https://www.typescriptlang.org/play?#code/PTAEGEHsFsAcEsA2BTATqNrLusgzngIYDm+oA7koqIYuYQJ56gCueyoAUCKAC4AWHAHaFcoSADMaQ0PCG80EwgGNkALk6c5C1EtWgAsqOi1QAb06groEbjWg8vVHOKcAvpokshy3vEgyyMr8kEbQJogAFND2YREAlOaW1soBeJAoAHSIkMTRmbbI8e6aPMiZxJmgACqCGKhY6ABGyDnkFFQ0dIzMbBwCwqIccabcYLyQoKjIEmh8kwN8DLAc5PzwwbLMyAAeK77IACYaQSEjUWZWhfYAjABMAMwALA+gbsVjoADqgjKESytQPxCHghAByXigYgBfr8LAsYj8aQMUASbDQcRSExCeCwFiIQh+AKfAYyBiQFgOPyIaikSGLQo0Zj-aazaY+dSaXjLDgAGXgAC9CKhDqAALxJaw2Ib2RzOISuDycLw+ImBYKQflCkWRRD2LXCw6JCxS1JCdJZHJ5RAFIbFJU8ADKC3WzEcnVZaGYE1ABpFnFOmsFhsil2uoHuzwArO9SmAAEIsSFrZB-GgAjjA5gtVN8VCEc1o1C4Q4AGlR2AwO1EsBQoAAbvB-gJ4HhPgB5aDwem-Ph1TCV3AEEirTp4ELtRbTPD4vwKjOfAuioSQHuDXBcnmgACC+eCONFEs73YAPGGZVT5cRyyhiHh7AAON7lsG3vBggB8XGV3l8-nVISOgghxoLq9i7io-AHsayRWGaFrlFauq2rg9qaIGQHwCBqChtKdgRo8TxRjeyB3o+7xAA\">나타날 수 있고</a>, 때로는 동등한 익명 타입을 대신하여 나타날 수 있습니다(이는 경우에 따라 바람직할 수도 있고 아닐 수도 있습니다). 인터페이스는 항상 오류 메시지에 이름이 나타납니다.</li> <li>타입 별칭은 <a href=\"https://www.typescriptlang.org/play?#code/PTAEEEDtQS0gXApgJwGYEMDGjSfdAIx2UQFoB7AB0UkQBMAoEUfO0Wgd1ADd0AbAK6IAzizp16ALgYM4SNFhwBZdAFtV-UAG8GoPaADmNAcMmhh8ZHAMMAvjLkoM2UCvWad+0ARL0A-GYWVpA29gyY5JAWLJAwGnxmbvGgALzauvpGkCZmAEQAjABMAMwALLkANBl6zABi6DB8okR4Jjg+iPSgABboovDk3jjo5pbW1d6+dGb5djLwAJ7UoABKiJTwjThpnpnGpqPBoTLMAJrkArj4kOTwYmycPOhW6AR8IrDQ8N04wmo4HHQCwYi2Waw2W1S6S8HX8gTGITsQA\">선언 병합에 포함될 수 없지만, 인터페이스는 포함될 수 있습니다</a>.</li> <li>인터페이스는 <a href=\"https://www.typescriptlang.org/play?#code/PTAEAkFMCdIcgM6gC4HcD2pIA8CGBbABwBtIl0AzUAKBFAFcEBLAOwHMUBPQs0XFgCahWyGBVwBjMrTDJMAshOhMARpD4tQ6FQCtIE5DWoixk9QEEWAeV37kARlABvaqDegAbrmL1IALlAEZGV2agBfampkbgtrWwMAJlAAXmdXdy8ff0Dg1jZwyLoAVWZ2Lh5QVHUJflAlSFxROsY5fFAWAmk6CnRoLGwmILzQQmV8JmQmDzI-SOiKgGV+CaYAL0gBBdyy1KCQ-Pn1AFFplgA5enw1PtSWS+vCsAAVAAtB4QQWOEMKBuYVUiVCYvYQsUTQcRSBDGMGmKSgAAa-VEgiQe2GLgKQA\">오직 객체의 모양을 선언하는 데에만 사용되며, 기존의 원시 타입에 별칭을 부여하는 데에는 사용할 수는 없습니다</a>.</li> <li>인터페이스의 이름은 <a href=\"https://www.typescriptlang.org/play?#code/PTAEGEHsFsAcEsA2BTATqNrLusgzngIYDm+oA7koqIYuYQJ56gCueyoAUCKAC4AWHAHaFcoSADMaQ0PCG80EwgGNkALk6c5C1EtWgAsqOi1QAb06groEbjWg8vVHOKcAvpokshy3vEgyyMr8kEbQJogAFND2YREAlOaW1soBeJAoAHSIkMTRmbbI8e6aPMiZxJmgACqCGKhY6ABGyDnkFFQ0dIzMbBwCwqIccabcYLyQoKjIEmh8kwN8DLAc5PzwwbLMyAAeK77IACYaQSEjUWY2Q-YAjABMAMwALA+gbsVjNXW8yxySoAADaAA0CCaZbPh1XYqXgOIY0ZgmcK0AA0nyaLFhhGY8F4AHJmEJILCWsgZId4NNfIgGFdcIcUTVfgBlZTOWC8T7kAJ42G4eT+GS42QyRaYbCgXAEEguTzeXyCjDBSAAQSE8Ai0Xsl0K9kcziExDeiQs1lAqSE6SyOTy0AKQ2KHk4p1V6s1OuuoHuzwArMagA\">항상 있는 그대로</a> 오류 메시지에 나타납니다. 단, 이는 <em>오직</em> 코드상에서 해당 인터페이스가 이름으로 사용되었을 때에만 해당합니다.</li> </ul> <p>대부분의 경우 개인적 선호에 따라 인터페이스와 타입 중에서 선택할 수 있으며, 필요하다면 TypeScript가 다른 선택을 제안할 것입니다. 잘 모르겠다면, 우선 <code>interface</code>를 사용하고 이후 문제가 발생하였을 때 <code>type</code>을 사용하기 바랍니다.</p> <h2 id=\"타입-단언\" style=\"position:relative;\">타입 단언</h2> <p>때로는 TypeScript보다 당신이 어떤 값의 타입에 대한 정보를 더 잘 아는 경우도 존재합니다.</p> <p>예를 들어 코드상에서 <code>document.getElementById</code>가 사용되는 경우, TypeScript는 이때 <code>HTMLElement</code> 중에 <em>무언가</em>가 반환된다는 것만을 알 수 있는 반면에, 당신은 페이지 상에서 사용되는 ID로는 언제나 <code>HTMLCanvasElement</code>가 반환된다는 사실을 이미 알고 있을 수도 있습니다.</p> <p>이런 경우, <em>타입 단언</em>을 사용하면 타입을 좀 더 구체적으로 명시할 수 있습니다.</p> <pre data-language=\"ts\">const myCanvas = document.getElementById(\"main_canvas\") as HTMLCanvasElement;</pre> <p>타입 표기와 마찬가지로, 타입 단언은 컴파일러에 의하여 제거되며 코드의 런타임 동작에는 영향을 주지 않습니다.</p> <p>꺾쇠괄호를 사용하는 것 또한 (코드가 <code>.tsx</code> 파일이 아닌 경우) 가능하며, 이는 동일한 의미를 가집니다.</p> <pre data-language=\"ts\">const myCanvas = &lt;HTMLCanvasElement&gt;document.getElementById(\"main_canvas\");</pre> <blockquote> <p>기억하세요: 타입 단언은 컴파일 시간에 제거되므로, 타입 단언에 관련된 검사는 런타임 중에 이루어지지 않습니다. 타입 단언이 틀렸더라도 예외가 발생하거나 <code>null</code>이 생성되지 않을 것입니다.</p> </blockquote> <p>TypeScript에서는 <em>보다 구체적인</em> 또는 <em>덜 구체적인</em> 버전의 타입으로 변환하는 타입 단언만이 허용됩니다. 이러한 규칙은 아래와 같은 “불가능한” 강제 변환을 방지합니다.</p> <pre data-language=\"ts\">const x = \"hello\" as number;</pre> <p>이 규칙이 때로는 지나치게 보수적으로 작용하여, 복잡하기는 하지만 유효할 수 있는 강제 변환이 허용되지 않기도 합니다. 이런 경우, 두 번의 단언을 사용할 수 있습니다. <code>any</code>(또는 이후에 소개할 <code>unknown</code>)로 우선 변환한 뒤, 그다음 원하는 타입으로 변환하면 됩니다.</p> <pre data-language=\"ts\">const a = (expr as any) as T;</pre> <h2 id=\"리터럴-타입\" style=\"position:relative;\">리터럴 타입</h2> <p><code>string</code>과 <code>number</code>와 같은 일반적인 타입 이외에도, <em>구체적인</em> 문자열과 숫자 값을 타입 위치에서 지정할 수 있습니다.</p> <p>이를 이해하려면, JavaScript에서 변수 선언에 제공되는 다양한 방법들을 떠올려보시기 바랍니다. <code>var</code>와 <code>let</code> 모두 변수에 저장 가능한 값의 종류를 변경할 수 있으며, <code>const</code>는 이것이 불가능합니다. 이러한 특징들은 TypeScript가 리터럴 값을 위한 타입을 생성하는 방식에 그대로 반영됩니다.</p> <pre data-language=\"ts\">let changingString = \"Hello World\";\nchangingString = \"Olá Mundo\";\n// 변수 `changingString`은 어떤 문자열이든 모두 나타낼 수 있으며,\n// 이는 TypeScript의 타입 시스템에서 문자열 타입 변수를 다루는 방식과 동일합니다.\nchangingString;\n \nconst constantString = \"Hello World\";\n// 변수 `constantString`은 오직 단 한 종류의 문자열만 나타낼 수 있으며,\n// 이는 리터럴 타입의 표현 방식입니다.\nconstantString;</pre> <p>리터럴 타입은 그 자체만으로는 그다지 유의미하지 않습니다.</p> <pre data-language=\"ts\">let x: \"hello\" = \"hello\";\n// OK\nx = \"hello\";\n// ...\nx = \"howdy\";</pre> <p>단 하나의 값만을 가질 수 있는 변수는 그다지 쓸모가 없죠!</p> <p>하지만 리터럴을 유니언과 <em>함께 사용하면</em>, 보다 유용한 개념들을 표현할 수 있게 됩니다. 예를 들어, 특정 종류의 값들만을 인자로 받을 수 있는 함수를 정의하는 경우가 있습니다.</p> <pre data-language=\"ts\">function printText(s: string, alignment: \"left\" | \"right\" | \"center\") {\n  // ...\n}\nprintText(\"Hello, world\", \"left\");\nprintText(\"G'day, mate\", \"centre\");</pre> <p>숫자 리터럴 타입 또한 같은 방식으로 사용할 수 있습니다.</p> <pre data-language=\"ts\">function compare(a: string, b: string): -1 | 0 | 1 {\n  return a === b ? 0 : a &gt; b ? 1 : -1;\n}</pre> <p>물론, 리터럴이 아닌 타입과도 함께 사용할 수 있습니다.</p> <pre data-language=\"ts\">interface Options {\n  width: number;\n}\nfunction configure(x: Options | \"auto\") {\n  // ...\n}\nconfigure({ width: 100 });\nconfigure(\"auto\");\nconfigure(\"automatic\");</pre> <p>또 하나의 리터럴 타입이 있습니다. 바로 불 리터럴 타입입니다. 불 리터럴에는 오직 두 개의 타입만이 존재하며, 이는 익히 예상하셨듯이 <code>true</code>와 <code>false</code>입니다. <code>boolean</code> 타입 자체는 사실 단지 <code>true | false</code> 유니언 타입의 별칭입니다.</p> <h3 id=\"리터럴-추론\" style=\"position:relative;\">리터럴 추론</h3> <p>객체를 사용하여 변수를 초기화하면, TypeScript는 해당 객체의 프로퍼티는 이후에 그 값이 변화할 수 있다고 가정합니다. 예를 들어, 아래와 같은 코드를 작성하는 경우를 보겠습니다.</p> <pre data-language=\"ts\">const obj = { counter: 0 };\nif (someCondition) {\n  obj.counter = 1;\n}</pre> <p>기존에 값이 <code>0</code>이었던 필드에 <code>1</code>을 대입하였을 때 TypeScript는 이를 오류로 간주하지 않습니다. 이를 달리 말하면 <code>obj.counter</code>는 반드시 <code>number</code> 타입을 가져야 하며, <code>0</code> 리터럴 타입을 가질 수 없다는 의미입니다. 왜냐하면 타입은 <em>읽기</em> 및 <em>쓰기</em> 두 동작을 결정하는 데에 사용되기 때문입니다.</p> <p>동일한 사항이 문자열에도 적용됩니다.</p> <pre data-language=\"ts\">const req = { url: \"https://example.com\", method: \"GET\" };\nhandleRequest(req.url, req.method);</pre> <p>위 예시에서 <code>req.method</code>는 <code>string</code>으로 추론되지, <code>\"GET\"</code>으로 추론되지 않습니다. <code>req</code>의 생성 시점과 <code>handleRequest</code>의 호출 시점 사이에도 얼마든지 코드 평가가 발생할 수 있고, 이때 <code>req.method</code>에 <code>\"GUESS\"</code>와 같은 새로운 문자열이 대입될 수도 있으므로, TypeScript는 위 코드에 오류가 있다고 판단합니다.</p> <p>이러한 경우를 해결하는 데에는 두 가지 방법이 있습니다.</p> <ol> <li> <p>둘 중에 한 위치에 타입 단언을 추가하여 추론 방식을 변경할 수 있습니다.</p> <pre data-language=\"ts\">// 수정 1:\nconst req = { url: \"https://example.com\", method: \"GET\" as \"GET\" };\n// 수정 2\nhandleRequest(req.url, req.method as \"GET\");</pre> <p>수정 1은 <code>req.method</code>가 항상 <em>리터럴 타입</em> <code>\"GET\"</code>이기를 의도하며, 이에 따라 해당 필드에 <code>\"GUESS\"</code>와 같은 값이 대입되는 경우를 미연에 방지하겠다”는 것을 의미합니다. 수정 2는 “무슨 이유인지, <code>req.method</code>가 <code>\"GET\"</code>을 값으로 가진다는 사실을 알고 있다”는 것을 의미합니다.</p> </li> <li> <p><code>as const</code>를 사용하여 객체 전체를 리터럴 타입으로 변환할 수 있습니다.</p> <pre data-language=\"ts\">const req = { url: \"https://example.com\", method: \"GET\" } as const;\nhandleRequest(req.url, req.method);</pre> </li> </ol> <p><code>as const</code> 접미사는 일반적인 <code>const</code>와 유사하게 작동하는데, 해당 객체의 모든 프로퍼티에 <code>string</code> 또는 <code>number</code>와 같은 보다 일반적인 타입이 아닌 리터럴 타입의 값이 대입되도록 보장합니다.</p> <h2 id=\"null과-undefined\" style=\"position:relative;\">\n<code>null</code>과 <code>undefined</code>\n</h2> <p>JavaScript에는 빈 값 또는 초기화되지 않은 값을 가리키는 두 가지 원시값이 존재합니다. 바로 <code>null</code>과 <code>undefined</code>입니다.</p> <p>TypeScript에는 각 값에 대응하는 동일한 이름의 두 가지 <em>타입</em>이 존재합니다. 각 타입의 동작 방식은 <code>strictNullChecks</code> 옵션의 설정 여부에 따라 달라집니다.</p> <h3 id=\"strictnullchecks가-설정되지-않았을-때\" style=\"position:relative;\">\n<code>strictNullChecks</code>가 설정되지 않았을 때</h3> <p><code>strictNullChecks</code>가 <em>설정되지 않았다면</em>, 어떤 값이 <code>null</code> 또는 <code>undefined</code>일 수 있더라도 해당 값에 평소와 같이 접근할 수 있으며, <code>null</code>과 <code>undefined</code>는 모든 타입의 변수에 대입될 수 있습니다. 이는 Null 검사를 하지 않는 언어(C#, Java 등)의 동작 방식과 유사합니다. Null 검사의 부재는 버그의 주요 원인이 되기도 합니다. 별다른 이유가 없다면, 코드 전반에 걸쳐 <code>strictNullChecks</code> 옵션을 설정하는 것을 항상 권장합니다.</p> <h3 id=\"strictnullchecks-설정되었을-때\" style=\"position:relative;\">\n<code>strictNullChecks</code> 설정되었을 때</h3> <p><code>strictNullChecks</code>가 <em>설정되었다면</em>, 어떤 값이 <code>null</code> 또는 <code>undefined</code>일 때, 해당 값과 함께 메서드 또는 프로퍼티를 사용하기에 앞서 해당 값을 테스트해야 합니다. 옵셔널 프로퍼티를 사용하기에 앞서 <code>undefined</code> 여부를 검사하는 것과 마찬가지로, <em>좁히기</em>를 통하여 <code>null</code>일 수 있는 값에 대한 검사를 수행할 수 있습니다.</p> <pre data-language=\"ts\">function doSomething(x: string | undefined) {\n  if (x === undefined) {\n    // 아무 것도 하지 않는다\n  } else {\n    console.log(\"Hello, \" + x.toUpperCase());\n  }\n}</pre> <h3 id=\"null-아님-단언-연산자-접미사-\" style=\"position:relative;\">Null 아님 단언 연산자 (접미사 <code>!</code>)</h3> <p>TypeScript에서는 명시적인 검사를 하지 않고도 타입에서 <code>null</code>과 <code>undefined</code>를 제거할 수 있는 특별한 구문을 제공합니다. 표현식 뒤에 <code>!</code>를 작성하면 해당 값이 <code>null</code> 또는 <code>undefined</code>가 아니라고 타입 단언하는 것입니다.</p> <pre data-language=\"ts\">function liveDangerously(x?: number | undefined) {\n  // 오류 없음\n  console.log(x!.toFixed());\n}</pre> <p>다른 타입 단언과 마찬가지로 이 구문은 코드의 런타임 동작을 변화시키지 않으므로, <code>!</code> 연산자는 반드시 해당 값이 <code>null</code> 또는 <code>undefined</code>가 <em>아닌</em> 경우에만 사용해야 합니다.</p> <h2 id=\"열거형\" style=\"position:relative;\">열거형</h2> <p>열거형은 TypeScript가 JavaScript에 추가하는 기능으로, 어떤 값이 <em>이름이 있는 상수 집합</em>에 속한 값 중 하나일 수 있도록 제한하는 기능입니다. 대부분의 TypeScript 기능과 달리, 이 기능은 JavaScript에 타입 수준이 <em>아닌</em>, 언어와 런타임 수준에 추가되는 기능입니다. 따라서 열거형이 무엇인지는 알 필요가 있겠으나, 그 사용법을 명확하게 파악하지 않았다면 실제 사용은 보류하는 것이 좋습니다. 열거형에 대한 자세한 내용을 확인하려면 <a href=\"../enums\">열거형 문서</a>를 읽어보시기 바랍니다.</p> <h2 id=\"자주-사용되지-않는-원시형-타입\" style=\"position:relative;\">자주 사용되지 않는 원시형 타입</h2> <p>앞서 언급한 타입 이외에, 타입 시스템에 존재하는 나머지 JavaScript 원시 타입들을 다루도록 하겠습니다. 물론, 여기서 깊게 다루지는 않을 것입니다.</p> <h4 id=\"bigint\" style=\"position:relative;\"><code>bigint</code></h4> <p>ES2020 이후, 아주 큰 정수를 다루기 위한 원시 타입이 JavaScript에 추가되었습니다. 바로 <code>bigint</code>입니다.</p> <pre data-language=\"ts\">// BigInt 함수를 통하여 bigint 값을 생성\nconst oneHundred: bigint = BigInt(100);\n \n// 리터럴 구문을 통하여 bigint 값을 생성\nconst anotherHundred: bigint = 100n;</pre> <p>BigInt에 대한 더 자세한 내용은 <a href=\"https://www.typescriptlang.org/ko/docs/handbook/2/(/docs/handbook/release-notes/typescript-3-2.html#bigint)\">TypeScript 3.2 릴리즈 노트</a>에서 확인할 수 있습니다.</p> <h4 id=\"symbol\" style=\"position:relative;\"><code>symbol</code></h4> <p><code>symbol</code>은 전역적으로 고유한 참조값을 생성하는 데에 사용할 수 있는 원시 타입이며, <code>Symbol()</code> 함수를 통하여 생성할 수 있습니다.</p> <pre data-language=\"ts\">const firstName = Symbol(\"name\");\nconst secondName = Symbol(\"name\");\n \nif (firstName === secondName) {\n  // 절대로 일어날 수 없습니다\n}</pre> <p>Symbol에 대한 더 자세한 내용은 <a href=\"../symbols\">심벌 문서</a>에서 확인할 수 있습니다.</p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2012-2023 Microsoft<br>Licensed under the Apache License, Version 2.0.<br>\n    <a href=\"https://www.typescriptlang.org/ko/docs/handbook/2/everyday-types.html\" class=\"_attribution-link\">https://www.typescriptlang.org/ko/docs/handbook/2/everyday-types.html</a>\n  </p>\n</div>\n","namespaces":"<h1>Namespaces</h1>\n<blockquote> <p><strong>용어에 대한 설명:</strong> TypeScript 1.5 버전부터 용어가 변경되었습니다. “Internal modules” 은 “네임스페이스” 로 변경되었습니다. “External modules” 은 “모듈” 로 변경되었습니다. 이는 <a href=\"http://www.ecma-international.org/ecma-262/6.0/\">ECMAScript 2015</a>의 용어와 통일시키기 위함입니다. (<code>module X {</code> 는 현재 선호되는 <code>namespace X {</code> 와 동일합니다.)</p> </blockquote> <p>이 게시물에서는 TypeScript에서 네임스페이스(구 “internal modules”)를 사용하여 코드를 구성하는 다양한 방법을 간략하게 설명합니다. 위에서 설명했듯이, “internal modules” 은 “네임스페이스” 로 변경되었습니다. 이에 따라, 인터널 모듈을 선언하기 위해 쓰였던 <code>module</code> 키워드는 <code>namespace</code> 키워드로 대체되어야 합니다. 이를 통해 신규 사용자의 혼란을 방지할 수 있습니다.</p> <h1 id=\"첫-번째-단계-first-steps\" style=\"position:relative;\">첫 번째 단계 (First steps)</h1> <p><b><a href=\"#table-of-contents\">↥ 위로</a></b></p> <p>이 페이지 전체에서 예제로 사용할 프로그램을 시작하겠습니다. 웹 페이지의 양식에 대한 사용자 입력을 확인하거나 외부로부터 받은 데이터 파일의 형식을 확인하기 위해 간단한 문자열 검사기 세트를 작성했습니다.</p> <h2 id=\"단일-파일-검사기-validators-in-a-single-file\" style=\"position:relative;\">단일 파일 검사기 (Validators in a single file)</h2> <pre data-language=\"ts\">interface StringValidator {\n    isAcceptable(s: string): boolean;\n}\n\nlet lettersRegexp = /^[A-Za-z]+$/;\nlet numberRegexp = /^[0-9]+$/;\n\nclass LettersOnlyValidator implements StringValidator {\n    isAcceptable(s: string) {\n        return lettersRegexp.test(s);\n    }\n}\n\nclass ZipCodeValidator implements StringValidator {\n    isAcceptable(s: string) {\n        return s.length === 5 &amp;&amp; numberRegexp.test(s);\n    }\n}\n\n// 시도해 볼 샘플\nlet strings = [\"Hello\", \"98052\", \"101\"];\n\n// 사용할 검사기\nlet validators: { [s: string]: StringValidator; } = {};\nvalidators[\"ZIP code\"] = new ZipCodeValidator();\nvalidators[\"Letters only\"] = new LettersOnlyValidator();\n\n// 각 문자열이 각 검사기를 통과했는지 표시\nfor (let s of strings) {\n    for (let name in validators) {\n        let isMatch = validators[name].isAcceptable(s);\n        console.log(`'${ s }' ${ isMatch ? \"matches\" : \"does not match\" } '${ name }'.`);\n    }\n}</pre> <h1 id=\"네임스페이스-적용하기-namespacing\" style=\"position:relative;\">네임스페이스 적용하기 (Namespacing)</h1> <p>더 많은 검사기를 추가하게 되면, 타입을 추적하고 다른 객체와 이름 충돌을 방지하기 위해 일종의 구조 체계가 필요합니다. 전역 네임스페이스에 다른 이름을 많이 넣는 대신, 객체들을 하나의 네임스페이스로 감싸겠습니다.</p> <p>이 예에서는 모든 검사기 관련 개체를 <code>Validation</code>이라는 하나의 네임스페이스로 옮기겠습니다.<br> 여기서 인터페이스 및 클래스가 네임스페이스 외부에서도 접근 가능하도록 선언부에 <code>export</code>를 붙입니다.<br> 반면, 변수 <code>letterRegexp</code>와 <code>numberRegexp</code>는 구현 세부 사항이므로 외부로 내보내지 않아 네임스페이스 외부 코드에서 접근할 수 없습니다. 파일 하단의 테스트 코드에서, 네임스페이스 외부에서 사용될 때 타입의 이름을 검증해야 합니다 (예: <code>Validation.LetterOnlyValidator</code>).</p> <h2 id=\"네임스페이스화된-검사기-namespaced-validators\" style=\"position:relative;\">네임스페이스화된 검사기 (Namespaced Validators)</h2> <pre data-language=\"ts\">namespace Validation {\n    export interface StringValidator {\n        isAcceptable(s: string): boolean;\n    }\n\n    const lettersRegexp = /^[A-Za-z]+$/;\n    const numberRegexp = /^[0-9]+$/;\n\n    export class LettersOnlyValidator implements StringValidator {\n        isAcceptable(s: string) {\n            return lettersRegexp.test(s);\n        }\n    }\n\n    export class ZipCodeValidator implements StringValidator {\n        isAcceptable(s: string) {\n            return s.length === 5 &amp;&amp; numberRegexp.test(s);\n        }\n    }\n}\n\n// 시도해 볼 샘플\nlet strings = [\"Hello\", \"98052\", \"101\"];\n\n// 사용할 검사기\nlet validators: { [s: string]: Validation.StringValidator; } = {};\nvalidators[\"ZIP code\"] = new Validation.ZipCodeValidator();\nvalidators[\"Letters only\"] = new Validation.LettersOnlyValidator();\n\n// 각 문자열이 각 검사기를 통과했는지 표시\nfor (let s of strings) {\n    for (let name in validators) {\n        console.log(`\"${ s }\" - ${ validators[name].isAcceptable(s) ? \"matches\" : \"does not match\" } ${ name }`);\n    }\n}</pre> <h1 id=\"파일-간-분할-splitting-across-files\" style=\"position:relative;\">파일 간 분할 (Splitting Across Files)</h1> <p><b><a href=\"#table-of-contents\">↥ 위로</a></b></p> <p>애플리케이션 규모가 커지면, 코드를 여러 파일로 분할해야 유지 보수가 용이합니다.</p> <h2 id=\"다중-파일-네임스페이스-multi-file-namespaces\" style=\"position:relative;\">다중 파일 네임스페이스 (Multi-file namespaces)</h2> <p><b><a href=\"#table-of-contents\">↥ 위로</a></b></p> <p>여기서 <code>Validation</code> 네임스페이스를 여러 파일로 분할합니다. 파일이 분리되어 있어도 같은 네임스페이스에 기여할 수 있고 마치 한 곳에서 정의된 것처럼 사용할 수 있습니다. 파일 간 의존성이 존재하므로, 참조 태그를 추가하여 컴파일러에게 파일 간의 관계를 알립니다. 그 외에 테스트 코드는 변경되지 않았습니다.</p> <h5 id=\"validationts\" style=\"position:relative;\">Validation.ts</h5> <pre data-language=\"ts\">namespace Validation{\n    export interface StringValidator{\n        isAcceptable(s: string): boolean;\n    }\n}</pre> <h5 id=\"lettersonlyvalidatorsts\" style=\"position:relative;\">LettersOnlyValidators.ts</h5> <pre data-language=\"ts\">/// &lt;reference path=\"Validation.ts\" /&gt;\nnamespace Validation {\n    const lettersRegexp = /^[A-Za-z]+$/;\n    export class LettersOnlyValidator implements StringValidator {\n        isAcceptable(s: string) {\n            return lettersRegexp.test(s);\n        }\n    }\n}</pre> <h5 id=\"zipcodevalidatorsts\" style=\"position:relative;\">ZipCodeValidators.ts</h5> <pre data-language=\"ts\">/// &lt;reference path=\"Validation.ts\" /&gt;\nnamespace Validation {\n    const numberRegexp = /^[0-9]+$/;\n    export class ZipCodeValidator implements StringValidator {\n        isAcceptable(s: string) {\n            return s.length === 5 &amp;&amp; numberRegexp.test(s);\n        }\n    }\n}</pre> <h5 id=\"testts\" style=\"position:relative;\">Test.ts</h5> <pre data-language=\"ts\">/// &lt;reference path=\"Validation.ts\" /&gt;\n/// &lt;reference path=\"LettersOnlyValidator.ts\" /&gt;\n/// &lt;reference path=\"ZipCodeValidator.ts\" /&gt;\n\n// Some samples to try\nlet strings = [\"Hello\", \"98052\", \"101\"];\n\n// Validators to use\nlet validators: { [s: string]: Validation.StringValidator; } = {};\nvalidators[\"ZIP code\"] = new Validation.ZipCodeValidator();\nvalidators[\"Letters only\"] = new Validation.LettersOnlyValidator();\n\n// Show whether each string passed each validator\nfor (let s of strings) {\n    for (let name in validators) {\n        console.log(`\"${ s }\" - ${ validators[name].isAcceptable(s) ? \"matches\" : \"does not match\" } ${ name }`);\n    }\n}</pre> <p>파일이 여러 개 있으면 컴파일된 코드가 모두 로드되는지 확인해야 합니다. 이를 수행하는 두 가지 방법이 있습니다.</p> <p>먼저, 모든 입력 파일을 하나의 JavaScript 출력 파일로 컴파일하기 위해 <code>--outFile</code> 플래그를 사용하여 연결 출력(concatenated output)을 사용할 수 있습니다:</p> <pre data-language=\"shell\">tsc --outFile sample.js Test.ts</pre> <p>컴파일러는 파일에 있는 참조 태그를 기반으로 출력 파일을 자동으로 정렬합니다. 각 파일을 개별적으로 지정할 수도 있습니다:</p> <pre data-language=\"shell\">tsc --outFile sample.js Validation.ts LettersOnlyValidator.ts ZipCodeValidator.ts Test.ts</pre> <p>또는 파일별 컴파일 (기본값)을 사용하여 각 입력 파일을 하나의 JavaScript 파일로 생성할 수 있습니다. 여러 JS 파일이 생성되는 경우, 웹 페이지에서 생성된 개별 파일을 적절한 순서로 로드하기 위해 <code>&lt;script&gt;</code> 태그를 사용해야 합니다. 예를 들어:</p> <h5 id=\"mytestpagehtml-인용\" style=\"position:relative;\">MyTestPage.html (인용)</h5> <pre data-language=\"html\">    &lt;script src=\"Validation.js\" type=\"text/javascript\" /&gt;\n    &lt;script src=\"LettersOnlyValidator.js\" type=\"text/javascript\" /&gt;\n    &lt;script src=\"ZipCodeValidator.js\" type=\"text/javascript\" /&gt;\n    &lt;script src=\"Test.js\" type=\"text/javascript\" /&gt;</pre> <h1 id=\"별칭-aliases\" style=\"position:relative;\">별칭 (Aliases)</h1> <p><b><a href=\"#table-of-contents\">↥ 위로</a></b></p> <p>네임스페이스 작업을 단순화할 수 있는 또 다른 방법은 일반적으로 사용되는 객체의 이름을 더 짧게 만들기 위해 <code>import q = x.y.z</code>를 사용하는 것입니다. 모듈을 로드하는 데 사용되는 <code>import x = require (\"name\")</code> 구문과 혼동하지 않기 위해, 이 구문은 단순히 특정 심벌에 별칭을 생성합니다. 이러한 종류의 가져오기(일반적으로 별칭이라고 함)는 모듈 가져오기에서 생성된 객체를 포함하여 모든 종류의 식별자에 대해 사용할 수 있습니다.</p> <pre data-language=\"ts\">namespace Shapes {\n    export namespace Polygons {\n        export class Triangle { }\n        export class Square { }\n    }\n}\n\nimport polygons = Shapes.Polygons;\nlet sq = new polygons.Square(); // 'new Shapes.Polygons.Square()'와 동일</pre> <p><code>require</code> 키워드를 사용하지 않는다는 것을 명심하세요; 대신 가져오는 심벌은 정해진 이름으로 직접 할당합니다. <code>var</code>를 사용하는 것과 비슷하지만, 가져온 심벌의 타입 및 네임스페이스 의미에 대해서도 동작합니다. 특히, 값의 경우 <code>import</code>는 원래 심벌와 별개의 참조이므로 별칭 <code>var</code>에 대한 변경 내용은 원래 변수에 반영되지 않습니다.</p> <h1 id=\"다른-javascript-라이브러리로-작업하기-working-with-other-javascript-libraries\" style=\"position:relative;\">다른 JavaScript 라이브러리로 작업하기 (Working with Other JavaScript Libraries)</h1> <p><b><a href=\"#table-of-contents\">↥ 위로</a></b></p> <p>TypeScript로 작성되지 않은 라이브러리의 형태를 설명하려면, 라이브러리가 외부에 제공하는 API를 선언해야 합니다. 대부분의 JavaScript 라이브러리는 소수의 최상위 객체만 노출하므로 네임스페이스를 사용하는 것이 좋습니다.</p> <p>구현을 정의하지 않은 선언을 “ambient”라고 부릅니다. 일반적으로 이것은 <code>.d.ts</code> 파일에 정의되어 있습니다. C/C++에 익숙하다면 이를 <code>.h</code> 파일로 생각할 수 있습니다. 몇 가지 예를 살펴보겠습니다.</p> <h2 id=\"ambient-네임스페이스-ambient-namespaces\" style=\"position:relative;\">Ambient 네임스페이스 (Ambient Namespaces)</h2> <p><b><a href=\"#table-of-contents\">↥ 위로</a></b></p> <p>널리 사용되는 D3 라이브러리는 <code>d3</code>이라는 전역 객체에서 기능을 정의합니다. 이 라이브러리는 <code>&lt;script&gt;</code> 태그를 통해 로드되므로(모듈 로더 대신) 형태를 정의하기 위해 선언할 때 네임스페이스를 사용합니다. TypeScript 컴파일러는 이 형태를 보기 위해, ambient 네임스페이스 선언을 사용합니다. 예를 들어 다음과 같이 작성할 수 있습니다:</p> <h5 id=\"d3dts-간단한-인용\" style=\"position:relative;\">D3.d.ts (간단한 인용)</h5> <pre data-language=\"ts\">declare namespace D3 {\n    export interface Selectors {\n        select: {\n            (selector: string): Selection;\n            (element: EventTarget): Selection;\n        };\n    }\n\n    export interface Event {\n        x: number;\n        y: number;\n    }\n\n    export interface Base extends Selectors {\n        event: Event;\n    }\n}\n\ndeclare var d3: D3.Base;</pre><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2012-2023 Microsoft<br>Licensed under the Apache License, Version 2.0.<br>\n    <a href=\"https://www.typescriptlang.org/ko/docs/handbook/namespaces.html\" class=\"_attribution-link\">https://www.typescriptlang.org/ko/docs/handbook/namespaces.html</a>\n  </p>\n</div>\n","configuring-watch":"<h1>Configuring Watch</h1>\n<p>컴파일러가 어떻게 파일과 디렉터리를 감시할지에 대해</p> <ul> <li>TypeScript 3.8+: 컴파일러 플래그</li> <li>그보다 이전 버전: 환경 변수</li> </ul> <p>를 사용하여 설정합니다.</p> <h2 id=\"배경-background\" style=\"position:relative;\">배경 (Background)</h2> <p>컴파일러의 <code>--watch</code> 구현은 node에서 제공하는 <code>fs.watch</code>와 <code>fs.watchFile</code>에 의존하며, 이 두 방법 모두 장단점이 있습니다.</p> <p><code>fs.watch</code>는 파일 시스템 이벤트를 사용하여 파일/디렉터리의 변경 사항을 알립니다. 하지만 OS에 따라 다르며, 알림은 완전히 믿을 수가 없고, 많은 OS에서 예상대로 동작하지 않습니다. 또한, 생성할 수 있는 watcher의 수에 제한이 있을 수 있으며(예: linux), 파일 수가 많은 프로그램을 사용하면 매우 빠르게 소진할 수 있습니다. 그러나 이 작업은 파일 시스템 이벤트를 사용하기 때문에 CPU cycle에 많이 관여하진 않습니다. 컴파일러는 일반적으로 <code>fs.watch</code>를 사용하여 디렉터리를 감시합니다. (예: 설정 파일에 포함된 소스 디렉터리, 모듈 확인을 실패한 디렉터리 … 등) 변경 사항에 대한 알림에서 누락된 정밀도를 처리할 수 있습니다. 그러나 재귀 감시 기능은 Windows와 OSX에서만 지원됩니다. 즉, 다른 OS들은 재귀적 특성을 대체할 무언가가 필요합니다.</p> <p><code>fs.watchFile</code>은 폴링을 사용하므로 CPU 주기를 포함합니다. 하지만 이는 파일/디렉터리 상태에 대한 업데이트를 받을 수 있는 가장 신뢰할 수 있는 메커니즘입니다. 컴파일러는 일반적으로 <code>fs.watchFile</code>을 사용하여 소스 파일, 구성 파일 및 누락된 파일(누락된 파일 참조)을 감시하는데 이는 CPU 사용량이 프로그램의 파일 수에 따라 달라진다는 것을 의미합니다.</p> <h2 id=\"configuring-file-watching-using-a-tsconfigjson\" style=\"position:relative;\">Configuring file watching using a <code>tsconfig.json</code>\n</h2> <pre tsconfig=\"true\" data-language=\"typescript\">{\n  // Some typical compiler options\n  \"compilerOptions\": {\n    \"target\": \"es2020\",\n    \"moduleResolution\": \"node\"\n    // ...\n  },\n\n  // NEW: Options for file/directory watching\n  \"watchOptions\": {\n    // Use native file system events for files and directories\n    \"watchFile\": \"useFsEvents\",\n    \"watchDirectory\": \"useFsEvents\",\n\n    // Poll files for updates more frequently\n    // when they're updated a lot.\n    \"fallbackPolling\": \"dynamicPriority\"\n  }\n}</pre> <p>You can read more about this in <a href=\"https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-8.html#better-directory-watching-on-linux-and-watchoptions\">the release notes</a>.</p> <h2 id=\"환경-변수-tscwatchfile을-사용하여-파일-감시-설정-configuring-file-watching-using-environment-variable-tscwatchfile\" style=\"position:relative;\">환경 변수 <code>TSC*WATCHFILE</code>을 사용하여 파일 감시 설정 (Configuring file watching using environment variable <code>TSC*WATCHFILE</code>)</h2>  <table> <thead> <tr> <th>옵션</th> <th>설명</th> </tr> </thead> <tbody> <tr> <td><code>PriorityPollingInterval</code></td> <td>\n<code>fs.watchFile</code>을 사용하지만 소스 파일, 설정 파일 및 누락된 파일에 대해 다른 폴링 주기(polling intervals)를 사용합니다.</td> </tr> <tr> <td><code>DynamicPriorityPolling</code></td> <td>자주 수정되는 파일을 자주 폴링하고 변경되지 않은 파일을 덜 자주 폴링 하는 동적 큐를 사용합니다.</td> </tr> <tr> <td><code>UseFsEvents</code></td> <td>파일 시스템 이벤트를 사용하는 <code>fs.watch</code>를 사용하여 파일 변경/생성/삭제에 대한 알림을 받습니다. (<code>fs.watch</code>는 OS마다 다르게 작동할 수 있습니다.) 예를 들어. 리눅스는 watcher 수에 제한이 있으며 <code>fs.watch</code>를 사용하여 watcher를 만들지 못하면, <code>fs.watchFile</code>를 대신 사용하여 watcher를 만들게 됩니다.</td> </tr> <tr> <td><code>UseFsEventsWithFallbackDynamicPolling</code></td> <td>이 옵션은 <code>fs.watch</code>를 사용하여 감시자를 만들지 못한 경우 폴링이 동적 큐를 통해 수행된다는 것을 제외하고는 <code>UseFsEvents</code> 옵션과 비슷합니다.(동적 큐에 대한 것은 <code>DynamicPriorityPolling</code>옵션에서 설명하였습니다.).</td> </tr> <tr> <td><code>UseFsEventsOnParentDirectory</code></td> <td>이 옵션은 <code>fs.watch</code>(파일 시스템 이벤트 사용하는)로 파일의 상위 디렉터리를 감시합니다. 다만, CPU 사용량이 늘어나고 정확도는 떨어질 수 있습니다.</td> </tr> <tr> <td>default (no value specified)</td> <td>환경 변수<code>TSC*NONPOLLING*WATCHER</code>가 true로 설정되면 파일의 상위 디렉터리를 감시합니다. (<code>UseFsEventsOnParentDirectory</code>와 동일).false 일 때는 <code>fs.watchFile</code>을 사용하여 <code>250ms</code> 시간 제한과 함께 모든 파일들을 감시합니다.</td> </tr> </tbody> </table> <h2 id=\"환경-변수tscwatchdirectory를-사용하여-디렉터리-감시-설정-configuring-directory-watching-using-environment-variable-tscwatchdirectory\" style=\"position:relative;\">환경 변수<code>TSC*WATCHDIRECTORY</code>를 사용하여 디렉터리 감시 설정 (Configuring directory watching using environment variable <code>TSC*WATCHDIRECTORY</code>)</h2> <p>기본적으로 node에서 디렉터리의 재귀적인 감시를 지원하지 않는 플랫폼에서, 디렉터리 감시 기능은 <code>TSC*WATCHDIRECTORY</code>에서 선택한 다양한 옵션을 사용하여 하위 디렉터리에 대한 디렉터리 watcher를 재귀적으로 생성함으로써 지원됩니다. 기본적으로 재귀 디렉터리 감시(예: windows)를 지원하는 플랫폼에서는 이 환경 변수의 값이 무시됩니다.</p>  <table> <thead> <tr> <th>옵션</th> <th>설명</th> </tr> </thead> <tbody> <tr> <td><code>RecursiveDirectoryUsingFsWatchFile</code></td> <td>\n<code>fs.watchFile</code>을 사용하여 폴링 감시(CPU cycles 사용)인 디렉터리 및 하위 디렉터리를 감시합니다.</td> </tr> <tr> <td><code>RecursiveDirectoryUsingDynamicPriorityPolling</code></td> <td>동적 폴링 큐를 사용하여 디렉터리 및 하위 디렉터리에 대한 변경사항을 폴링 합니다.</td> </tr> <tr> <td>default (no value specified)</td> <td>\n<code>fs.watch</code>를 사용하여 디렉터리 및 하위 디렉터리를 감시합니다.</td> </tr> </tbody> </table><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2012-2023 Microsoft<br>Licensed under the Apache License, Version 2.0.<br>\n    <a href=\"https://www.typescriptlang.org/ko/docs/handbook/configuring-watch.html\" class=\"_attribution-link\">https://www.typescriptlang.org/ko/docs/handbook/configuring-watch.html</a>\n  </p>\n</div>\n","enums":"<h1>Enums</h1>\n<p>열거형은 TypeScript가 제공하는 기능 중 하나입니다.</p> <p>열거형으로 이름이 있는 상수들의 집합을 정의할 수 있습니다. 열거형을 사용하면 의도를 문서화 하거나 구분되는 사례 집합을 더 쉽게 만들수 있습니다. TypeScript는 숫자와 문자열-기반 열거형을 제공합니다.</p> <h2 id=\"숫자-열거형-numeric-enums\" style=\"position:relative;\">숫자 열거형 (Numeric enums)</h2> <p>다른 언어를 배워 보신 분들이라면 친숙하게 느끼실 수 있는 숫자 열거형에 대해서 먼저 배워보겠습니다. 열거형은 <code>enum</code> 키워드를 사용해 정의할 수 있습니다.</p> <pre data-language=\"ts\">enum Direction {\n  Up = 1,\n  Down,\n  Left,\n  Right,\n}</pre> <p>위 코드에서 <code>Up</code>이 <code>1</code> 로 초기화된 숫자 열거형을 선언했습니다. 그 지점부터 뒤따르는 멤버들은 자동으로-증가된 값을 갖습니다. 즉 <code>Direction.Up</code> 은 <code>1</code>, <code>Down</code> 은 <code>2</code>, <code>Left</code> 는 <code>3</code>, <code>Right</code> 은 <code>4</code> 을 값으로 가집니다.</p> <p>원한다면, 전부 초기화 하지 않을 수도 있습니다:</p> <pre data-language=\"ts\">enum Direction {\n  Up,\n  Down,\n  Left,\n  Right,\n}</pre> <p>위 경우 <code>Up</code> 값은 <code>0</code>, <code>Down</code> 은 <code>1</code> 이 됩니다. 자동-증가하는 기능은 멤버 값 자체에는 신경 쓰지 않지만, 각 값이 같은 열거형의 다른 값과 구별돼야 하는 경우에 유용합니다.</p> <p>열거형을 사용하는 것은 간단합니다: 그냥 열거형 자체에서 프로퍼티로 모든 멤버에 접근하며, 열거형의 이름을 사용해 타입을 선언합니다.</p> <pre data-language=\"ts\">enum UserResponse {\n  No = 0,\n  Yes = 1,\n}\n \nfunction respond(recipient: string, message: UserResponse): void {\n  // ...\n}\n \nrespond(\"Princess Caroline\", UserResponse.Yes);</pre> <p>숫자 열거형은 <a href=\"#%EA%B3%84%EC%82%B0%EB%90%9C-%EB%A9%A4%EB%B2%84%EC%99%80-%EC%83%81%EC%88%98-%EB%A9%A4%EB%B2%84-computed-and-constant-members\">계산된 멤버와 상수 멤버 (아래 참조)</a>를 섞어서 사용할 수 있습니다. 간단히 말해, 초기화되지 않은 열거형이 먼저 나오거나, 숫자 상수 혹은 다른 상수 열거형 멤버와 함께 초기화된 숫자 열거형 이후에 와야 합니다. 즉 아래 방식은 허용되지 않습니다:</p> <pre data-language=\"ts\">enum E {\n  A = getSomeValue(),\n  B, // 오류! 앞에 나온 A가 계산된 멤버이므로 초기화가 필요합니다.\n}</pre> <h2 id=\"문자열-열거형-string-enums\" style=\"position:relative;\">문자열 열거형 (String enums)</h2> <p>문자열 열거형은 유사한 개념이지만 아래 설명된 것과 같이 <a href=\"#%EB%9F%B0%ED%83%80%EC%9E%84%EC%97%90%EC%84%9C-%EC%97%B4%EA%B1%B0%ED%98%95-enums-at-runtime\">런타임에서 열거형</a>의 동작이 약간 다릅니다. 문자열 열거형에서 각 멤버들은 문자열 리터럴 또는 다른 문자열 열거형의 멤버로 상수 초기화 해야 합니다.</p> <pre data-language=\"ts\">enum Direction {\n  Up = \"UP\",\n  Down = \"DOWN\",\n  Left = \"LEFT\",\n  Right = \"RIGHT\",\n}</pre> <p>문자열 열거형은 숫자 열거형처럼 자동-증가하는 기능은 없지만, “직렬화”를 잘한다는 이점이 있습니다. 다시 말해서 만약 당신이 숫자 열거형을 이용해서 디버깅하고 있고 그 값을 읽어야 한다면, 종종 그 값이 불확실한 경우가 있습니다 - 숫자만으로는 이것이 어떤 의미인지 유의미한 정보를 제공해주지 않기 때문입니다. (<a href=\"#%EC%97%AD-%EB%A7%A4%ED%95%91-Reverse-mappings\">역 매핑</a> 을 이용하면 도움이 될지라도 말입니다), 반면 문자열 열거형을 이용하면 코드를 실행할 때, 열거형 멤버에 지정된 이름과는 무관하게 유의미하고 읽기 좋은 값을 이용하여 실행할 수 있습니다.</p> <h2 id=\"이종-열거형-heterogeneous-enums\" style=\"position:relative;\">이종 열거형 (Heterogeneous enums)</h2> <p>기술적으로 열거형은 숫자와 문자를 섞어서 사용할 수 있지만 굳이 그렇게 할 이유는 없습니다.</p> <pre data-language=\"ts\">enum BooleanLikeHeterogeneousEnum {\n  No = 0,\n  Yes = \"YES\",\n}</pre> <p>확실하게 JavaScript 런타임에서 장점을 취하려는 것이 아니라면, 이렇게 사용하지 않는 것을 권장합니다.</p> <h2 id=\"계산된-멤버와-상수-멤버-computed-and-constant-members\" style=\"position:relative;\">계산된 멤버와 상수 멤버 (Computed and constant members)</h2> <p>각 열거형의 멤버는 <em>상수</em>이거나 <em>계산된</em> 값일 수 있습니다. 열거형의 멤버는 아래의 경우 상수로 간주합니다:</p> <ul> <li> <p>열거형의 첫 번째 데이터이며 초기화 값이 없는 경우, 0으로 값이 할당됩니다.</p> <pre data-language=\"ts\">// E.X는 상수입니다:\nenum E {\n  X,\n}</pre> </li> <li> <p>초기화 값이 없으며 숫자 상수로 초기화된 열거형 멤버 뒤에 따라 나오는 경우. 앞에 나온 상수 값에 1씩 증가한 값을 상수로 갖습니다.</p> <pre data-language=\"ts\">// 'E1' 과 'E2' 의 모든 열거형 멤버는 상수입니다.\n \nenum E1 {\n  X,\n  Y,\n  Z,\n}\n \nenum E2 {\n  A = 1,\n  B,\n  C,\n}</pre> </li> <li> <p>열거형 멤버는 상수 열거형 표현식으로 초기화됩니다. 상수 열거형 표현식은 컴파일 시 알아낼 수 있는 TypeScript 표현식의 일부입니다. 아래의 경우 상수 열거형 표현식이라고 합니다:</p> <ol> <li>리터럴 열거형 표현식 (기본적으로 문자 리터럴 또는 숫자 리터럴)</li> <li>이전에 정의된 다른 상수 열거형 멤버에 대한 참조 (다른 열거형에서 시작될 수 있음)</li> <li>괄호로 묶인 상수 열거형 표현식</li> <li>상수 열거형 표현식에 단항 연산자 <code>+</code>, <code>-</code>, <code>~</code> 를 사용한 경우</li> <li>상수 열거형 표현식을 이중 연산자 <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>, <code>%</code>, <code>&lt;&lt;</code>, <code>&gt;&gt;</code>, <code>&gt;&gt;&gt;</code>, <code>&amp;</code>, <code>|</code>, <code>^</code> 의 피연산자로 사용할 경우</li> </ol> <p>상수 열거형 표현식 값이 <code>NaN</code> 이거나 <code>Infinity</code> 이면 컴파일 시점에 오류가 납니다.</p> </li> </ul> <p>이외 다른 모든 경우 열거형 멤버는 계산된 것으로 간주합니다.</p> <pre data-language=\"ts\">enum FileAccess {\n  // 상수 멤버\n  None,\n  Read = 1 &lt;&lt; 1,\n  Write = 1 &lt;&lt; 2,\n  ReadWrite = Read | Write,\n  // 계산된 멤버\n  G = \"123\".length,\n}</pre> <h2 id=\"유니언-열거형과-열거형-멤버-타입-union-enums-and-enum-member-types\" style=\"position:relative;\">유니언 열거형과 열거형 멤버 타입 (Union enums and enum member types)</h2> <p>계산되지 않는 상수 열거 멤버의 특수한 부분 집합이 있습니다: 리터럴 열거형 멤버 리터럴 열거형 멤버는 초기화 값이 존재하지 않거나, 아래 값들로 초기화되는 멤버입니다.</p> <ul> <li>문자 리터럴 (예시. <code>\"foo\"</code>, <code>\"bar</code>, <code>\"baz\"</code>)</li> <li>숫자 리터럴 (예시. <code>1</code>, <code>100</code>)</li> <li>숫자 리터럴에 단항 연산자 <code>-</code> 가 적용된 경우 (e.g. <code>-1</code>, <code>-100</code>)</li> </ul> <p>열거형의 모든 멤버가 리터럴 열거형 값을 가지면 특별한 의미로 쓰이게 됩니다.</p> <p>첫째로 열거형 멤버를 타입처럼 사용할 수 있습니다! 예를 들어 특정 멤버는 <em>오직</em> 열거형 멤버의 값만 가지게 할 수 있습니다.</p> <pre data-language=\"ts\">enum ShapeKind {\n  Circle,\n  Square,\n}\n \ninterface Circle {\n  kind: ShapeKind.Circle;\n  radius: number;\n}\n \ninterface Square {\n  kind: ShapeKind.Square;\n  sideLength: number;\n}\n \nlet c: Circle = {\n  kind: ShapeKind.Square, // 오류! 'ShapeKind.Circle' 타입에 'ShapeKind.Square' 타입을 할당할 수 없습니다.\n  radius: 100,\n};</pre> <p>또 다른 점은 열거형 타입 자체가 효율적으로 각각의 열거형 멤버의 <em>유니언</em>이 된다는 점입니다. 유니언 타입 열거형을 사용하면 타입 시스템이 열거형 자체에 존재하는 정확한 값의 집합을 알고 있다는 사실을 활용할 수 있다는 점만 알아두면 됩니다. 이 때문에 TypeScript는 값을 잘못 비교하는 어리석은 버그를 잡을 수 있습니다. 예를 들어:</p> <pre data-language=\"ts\">enum E {\n  Foo,\n  Bar,\n}\n \nfunction f(x: E) {\n  if (x !== E.Foo || x !== E.Bar) {\n    //             ~~~~~~~~~~~\n    // 에러! E 타입은 Foo, Bar 둘 중 하나이기 때문에 이 조건은 항상 true를 반환합니다.\n  }\n}</pre> <p>이 예제에서 우리는 <code>x</code> 가 <code>E.Foo</code> 가 <em>아닌지</em> 확인합니다. 만약 이 조건이 true 라면, <code>||</code> 조건은 더는 체크할 필요가 없으므로 if 아래의 body가 실행될 것입니다. 그러나 만약 이 조건이 통과되지 않는다면, <code>x</code> 는 반드시 <code>E.Foo</code> 이기 때문에, x가 <code>E.Bar</code> 가 아닌지 묻는 조건과 비교하는 것은 적절하지 않습니다.</p> <h2 id=\"런타임에서의-열거형-enums-at-runtime\" style=\"position:relative;\">런타임에서의 열거형 (Enums at runtime)</h2> <p>열거형은 런타임에 존재하는 실제 객체입니다. 예를 들어 아래와 같은 열거형은</p> <pre data-language=\"ts\">enum E {\n  X,\n  Y,\n  Z,\n}</pre> <p>실제로 아래와 같이 함수로 전달될 수 있습니다.</p> <pre data-language=\"ts\">enum E {\n  X,\n  Y,\n  Z,\n}\n \nfunction f(obj: { X: number }) {\n  return obj.X;\n}\n \n// E가 X라는 숫자 프로퍼티를 가지고 있기 때문에 동작하는 코드입니다.\nf(E);</pre> <h2 id=\"컴파일-시점에서-열거형-enums-at-compile-time\" style=\"position:relative;\">컴파일 시점에서 열거형 (Enums at compile time)</h2> <p>열거형이 런타임에 존재하는 실제 객체라고 할지라도, <code>keyof</code> 키워드는 일반적인 객체에서 기대하는 동작과 다르게 동작합니다. 대신, <code>keyof typeof</code> 를 사용하면 모든 열거형의 키를 문자열로 나타내는 타입을 가져옵니다.</p> <pre data-language=\"ts\">enum LogLevel {\n  ERROR,\n  WARN,\n  INFO,\n  DEBUG,\n}\n \n/**\n * 이것은 아래와 동일합니다. :\n * type LogLevelStrings = 'ERROR' | 'WARN' | 'INFO' | 'DEBUG';\n */\ntype LogLevelStrings = keyof typeof LogLevel;\n \nfunction printImportant(key: LogLevelStrings, message: string) {\n  const num = LogLevel[key];\n  if (num &lt;= LogLevel.WARN) {\n    console.log(\"Log level key is:\", key);\n    console.log(\"Log level value is:\", num);\n    console.log(\"Log level message is:\", message);\n  }\n}\nprintImportant(\"ERROR\", \"This is a message\");</pre> <h3 id=\"역-매핑-reverse-mappings\" style=\"position:relative;\">역 매핑 (Reverse mappings)</h3> <p>숫자 열거형 멤버는 멤버의 프로퍼티 이름을 가진 객체를 생성하는 것 외에도 열거형 값에서 열거형 이름으로 <em>역 매핑</em> 을 받습니다. 예를 들어 아래의 예제에서:</p> <pre data-language=\"ts\">enum Enum {\n  A,\n}\n \nlet a = Enum.A;\nlet nameOfA = Enum[a]; // \"A\"</pre> <p>TypeScript는 아래와 같은 JavaScript 코드로 컴파일할 겁니다.</p> <pre data-language=\"ts\">\"use strict\";\nvar Enum;\n(function (Enum) {\n    Enum[Enum[\"A\"] = 0] = \"A\";\n})(Enum || (Enum = {}));\nlet a = Enum.A;\nlet nameOfA = Enum[a]; // \"A\"\n </pre> <p>이렇게 생성된 코드에서, 열거형은 정방향 (<code>name</code> -&gt; <code>value</code>) 매핑과 역방향 (<code>value</code> -&gt; <code>name</code>) 매핑 두 정보를 모두 저장하는 객체로 컴파일됩니다. 다른 열거형 멤버 참조는 항상 프로퍼티 접근으로 노출되며 인라인되지 않습니다.</p> <p>문자열 열거형은 역 매핑을 생성하지 <em>않는다</em> 는 것을 명심하시길 바랍니다.</p> <h3 id=\"const-열거형-const-enums\" style=\"position:relative;\">\n<code>const</code> 열거형 (<code>const</code> enums)</h3> <p>대부분의 경우, 열거형은 완벽하게 유효한 해결책입니다. 하지만 종종 열거형의 요구사항이 좀 더 엄격해 집니다. 열거형 값에 접근할 때, 추가로 생성된 코드 및 추가적인 간접 참조에 대한 비용을 피하기 위해 <code>const</code> 열거형을 사용할 수 있습니다. const 열거형은 <code>const</code> 지정자를 열거형에 붙여 정의합니다.</p> <pre data-language=\"ts\">const enum Enum {\n  A = 1,\n  B = A * 2,\n}</pre> <p>const 열거형은 상수 열거형 표현식만 사용될 수 있으며 일반적인 열거형과 달리 컴파일 과정에서 완전히 제거됩니다. const 열거형은 사용하는 공간에 인라인됩니다. 이러한 동작은 const 열거형이 계산된 멤버를 가지고 있지 않기 때문에 가능합니다.</p> <pre data-language=\"ts\">const enum Direction {\n  Up,\n  Down,\n  Left,\n  Right,\n}\n \nlet directions = [\n  Direction.Up,\n  Direction.Down,\n  Direction.Left,\n  Direction.Right,\n];</pre> <p>위 코드는 아래와 같이 컴파일됩니다.</p> <pre data-language=\"ts\">\"use strict\";\nlet directions = [\n    0 /* Direction.Up */,\n    1 /* Direction.Down */,\n    2 /* Direction.Left */,\n    3 /* Direction.Right */,\n];\n </pre> <h2 id=\"ambient-열거형-ambient-enums\" style=\"position:relative;\">Ambient 열거형 (Ambient enums)</h2> <p>Ambient 열거형은 이미 존재하는 열거형 타입의 모습을 묘사하기 위해 사용됩니다.</p> <pre data-language=\"ts\">declare enum Enum {\n  A = 1,\n  B,\n  C = 2,\n}</pre> <p>ambient 열거형과 비-ambient 열거형의 가장 큰 차이점은, 일반적인 열거형에서 초기화되지 않은 멤버가 상수로 간주하는 멤버 뒤에 있다면, 이 멤버도 상수로 간주할 것입니다. 반면 (const가 아닌) ambient 열거형에서 초기화되지 않은 멤버는 <em>항상</em> 계산된 멤버로 간주합니다.</p> <h2 id=\"objects-vs-enums\" style=\"position:relative;\">Objects vs Enums</h2> <p>In modern TypeScript, you may not need an enum when an object with <code>as const</code> could suffice:</p> <pre data-language=\"ts\">const enum EDirection {\n  Up,\n  Down,\n  Left,\n  Right,\n}\n \nconst ODirection = {\n  Up: 0,\n  Down: 1,\n  Left: 2,\n  Right: 3,\n} as const;\n \nEDirection.Up;\n \nODirection.Up;\n \n// Using the enum as a parameter\nfunction walk(dir: EDirection) {}\n \n// It requires an extra line to pull out the keys\ntype Direction = typeof ODirection[keyof typeof ODirection];\nfunction run(dir: Direction) {}\n \nwalk(EDirection.Left);\nrun(ODirection.Right);</pre> <p>The biggest argument in favour of this format over is that it keeps your codebase aligned with the state of JavaScript, and <a href=\"https://github.com/rbuckton/proposal-enum\">when/if</a> enums are added to JavaScript then you can move to the additional syntax.</p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2012-2023 Microsoft<br>Licensed under the Apache License, Version 2.0.<br>\n    <a href=\"https://www.typescriptlang.org/ko/docs/handbook/enums.html\" class=\"_attribution-link\">https://www.typescriptlang.org/ko/docs/handbook/enums.html</a>\n  </p>\n</div>\n","type-inference":"<h1>Type Inference</h1>\n<p>TypeScript에는 명시적인 타입 표기가 없을 때 타입 정보를 제공하기 위해 타입 추론이 사용되는 여러 위치가 있습니다. 예를 들어, 이 코드에서 보면</p> <pre data-language=\"ts\">let x = 3;</pre> <p><code>x</code> 변수의 타입은 <code>number</code> 로 추론됩니다. 이러한 종류의 추론은 변수와 멤버를 초기화하고 매개변수 기본값을 설정하며, 함수 반환 타입을 결정할 때 발생합니다.</p> <p>대부분의 유형 추론은 간단합니다. 다음 부분에서는 유형을 추론하는 방법에 대한 몇 가지 뉘앙스를 살펴보겠습니다.</p> <h2 id=\"최적-공통-타입\" style=\"position:relative;\">최적 공통 타입</h2> <p>여러 표현 식에서 타입을 추론할 때, 표현식들의 타입을 이용해 “최적 공통 타입”을 계산합니다. 예를 들어서:</p> <pre data-language=\"ts\">let x = [0, 1, null];</pre> <p>위의 예에서 <code>x</code> 의 타입을 추론하려면 각 배열 요소의 타입들을 고려해야 합니다. 여기서 배열 타입에 대해 이 두 가지의 선택 사항을 제공합니다: <code>number</code> 와 <code>null</code>. 가장 일반적인 타입 알고리즘은 각 후보 타입을 고려해서, 다른 모든 후보와 호환되는 타입을 결정합니다.</p> <p>제공된 후보 타입에서 최적의 공통 타입을 선택해야 하므로 타입이 공통적인 구조를 공유하지만, 한 타입이 모든 후보 타입의 슈퍼 타입이 아닐 수가 있습니다. 예를 들면:</p> <pre data-language=\"ts\">let zoo = [new Rhino(), new Elephant(), new Snake()];</pre> <p>이상적으로는, <code>zoo</code> 가 <code>Animal[]</code> 로 추론되기를 원할 수 있지만, 배열에 <code>Animal</code> 타입의 객체가 없으므로 엄격하게 판단하여, 배열 요소 타입으로 추론하지 않습니다. 이를 수정하려면, 한 타입이 다른 모든 후보의 상위 타입이 아닌 경우 유형을 명시적으로 제공해야합니다:</p> <pre data-language=\"ts\">let zoo: Animal[] = [new Rhino(), new Elephant(), new Snake()];</pre> <p>최적 공통 타입이 발견되지 않으면, 추론 결과는 유니언 배열 타입 <code>(Rhino | Elephant | Snake)[]</code> 입니다.</p> <h2 id=\"문맥상-타이핑\" style=\"position:relative;\">문맥상 타이핑</h2> <p>TypeScript의 타입 추론은 때에 따라 “다른 방향”에서도 작동합니다. 이를 “문맥상 타이핑”이라고 합니다. 문맥상 타이핑은 표현식의 타입이 위치에 의해 암시될 때 발생합니다. 예를 들면:</p> <pre data-language=\"ts\">window.onmousedown = function (mouseEvent) {\n  console.log(mouseEvent.button); //&lt;- OK\n  console.log(mouseEvent.kangaroo); //&lt;- Error!\n};</pre> <p>여기서, TypeScript 타입 검사기는 <code>Window.onmousedown</code> 함수의 타입을 사용하여 오른쪽에 할당된 함수 표현식의 타입을 추론했습니다. 여기선, <code>button</code>이 포함된 <code>mouseEvent</code> 매개변수의 <a href=\"https://developer.mozilla.org/docs/Web/API/MouseEvent\">타입</a> 을 추론할 수 있었습니다. 그러나 <code>kangaroo</code> 는 아닙니다.</p> <p>TypeScript는 다른 문맥에서도 타입을 추론할 수 있을 만큼 똑똑합니다:</p> <pre data-language=\"ts\">window.onscroll = function (uiEvent) {\n  console.log(uiEvent.button); //&lt;- Error!\n};</pre> <p>위의 함수가 <code>Window.onscroll</code> 에 할당된다는 사실을 바탕으로, TypeScript는 <code>uiEvent</code> 가 이전 예제와 같은 <a href=\"https://developer.mozilla.org/docs/Web/API/MouseEvent\">MouseEvent</a> 가 아니라 <a href=\"https://developer.mozilla.org/docs/Web/API/UIEvent\">UIEvent</a> 임을 알고 있습니다. <code>UIEvent</code> 객체에는 <code>button</code> 프로퍼티가 없으므로, TypeScript에서 오류가 발생합니다.</p> <p>이 함수가 컨텍스트 타입 위치에 있지 않았을 때 함수의 인수는 암시적으로 <code>any</code> 타입을 가지며, 오류가 발생하지 않습니다. ( <code>--noImplicitAny</code> 옵션을 사용하지 않는다면):</p> <pre data-language=\"ts\">const handler = function (uiEvent) {\n  console.log(uiEvent.button); //&lt;- OK\n};</pre> <p>또한, 함수의 인수에 타입 정보를 명시적으로 제공하여 컨텍스트 타입을 재정의할 수도 있습니다.</p> <pre data-language=\"ts\">window.onscroll = function (uiEvent: any) {\n  console.log(uiEvent.button); //&lt;- Now, no error is given\n};</pre> <p>그러나 이 코드는 <code>uiEvent</code> 에 <code>button</code> 이라는 프로퍼티가 없으므로 <code>undefined</code> 을 기록합니다.</p> <p>문맥상 타이핑은 많은 경우에 적용됩니다. 일반적으로는 함수 호출에 대한 인수, 오른쪽에 할당된 것, 타입 어셜션(assertions), 개체 및 배열 리터럴의 멤버, 반환문이 포함됩니다. 컨텍스트 타입은 또한 가장 일반적인 타입에서 후보 타입으로 작동합니다. 예를 들면:</p> <pre data-language=\"ts\">function createZoo(): Animal[] {\n  return [new Rhino(), new Elephant(), new Snake()];\n}</pre> <p>이 예에서 가장 일반적인 타입에는, 이와 같은 네 가지의 후보 셋이 있습니다: <code>Animal</code>, <code>Rhino</code>, <code>Elephant</code>, and <code>Snake</code>. 이 중에서, <code>Animal</code> 은 최적 공통 타입 알고리즘으로 선택할 수 있습니다.</p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2012-2023 Microsoft<br>Licensed under the Apache License, Version 2.0.<br>\n    <a href=\"https://www.typescriptlang.org/ko/docs/handbook/type-inference.html\" class=\"_attribution-link\">https://www.typescriptlang.org/ko/docs/handbook/type-inference.html</a>\n  </p>\n</div>\n","2/generics":"<h1>Generics</h1>\n<p>잘 정의되고 일관된 API뿐만 아닌 재사용 가능한 컴포넌트를 구축하는 것도 소프트웨어 엔지니어링에서의 주요한 부분입니다. 현재의 데이터와 미래의 데이터 모두를 다룰 수 있는 컴포넌트는 거대한 소프트웨어 시스템을 구성하는 데 있어 가장 유연한 능력을 제공할 것입니다.</p> <p>C#과 Java 같은 언어에서, 재사용 가능한 컴포넌트를 생성하는 도구상자의 주요 도구 중 하나는 제네릭입니다, 즉, 단일 타입이 아닌 다양한 타입에서 작동하는 컴포넌트를 작성할 수 있습니다. 사용자는 제네릭을 통해 여러 타입의 컴포넌트나 자신만의 타입을 사용할 수 있습니다.</p> <h1 id=\"제네릭의-hello-world-hello-world-of-generics\" style=\"position:relative;\">제네릭의 Hello World (Hello World of Generics)</h1> <p>먼저 제네릭의 “hello world”인 identity 함수를 해봅시다. identity 함수는 인수로 무엇이 오던 그대로 반환하는 함수입니다. <code>echo</code> 명령과 비슷하게 생각할 수 있습니다.</p> <p>제네릭이 없다면, identity 함수에 특정 타입을 주어야 합니다:</p> <pre data-language=\"ts\">function identity(arg: number): number {\n  return arg;\n}</pre> <p>또는 <code>any</code> 타입을 사용하여 identity 함수를 기술할 수 있습니다:</p> <pre data-language=\"ts\">function identity(arg: any): any {\n  return arg;\n}</pre> <p><code>any</code>를 쓰는 것은 함수의 <code>arg</code>가 어떤 타입이든 받을 수 있다는 점에서 제네릭이지만, 실제로 함수가 반환할 때 어떤 타입인지에 대한 정보는 잃게 됩니다. 만약 number 타입을 넘긴다고 해도 any 타입이 반환된다는 정보만 얻을 뿐입니다.</p> <p>대신에 우리는 무엇이 반환되는지 표시하기 위해 인수의 타입을 캡처할 방법이 필요합니다. 여기서는 값이 아닌 타입에 적용되는 <em>타입 변수</em> 를 사용할 것입니다.</p> <pre data-language=\"ts\">function identity&lt;Type&gt;(arg: Type): Type {\n  return arg;\n}</pre> <p>identity 함수에 <code>Type</code>라는 타입 변수를 추가했습니다. <code>Type</code>는 유저가 준 인수의 타입을 캡처하고 (예 - <code>number</code>), 이 정보를 나중에 사용할 수 있게 합니다. 여기에서는 <code>Type</code>를 반환 타입으로 다시 사용합니다. 인수와 반환 타입이 같은 타입을 사용하고 있는 것을 확인할 수 있습니다. 이를 통해 타입 정보를 함수의 한쪽에서 다른 한쪽으로 운반할 수 있게끔 합니다.</p> <p>이 버전의 identity 함수는 타입을 불문하고 동작하므로 제네릭이라 할 수 있습니다. <code>any</code>를 쓰는 것과는 다르게 인수와 반환 타입에 number를 사용한 첫 번째 <code>identity</code> 함수만큼 정확합니다. (즉, 어떤 정보도 잃지 않습니다)</p> <p>일단 제네릭 identity 함수를 작성하고 나면, 두 가지 방법 중 하나로 호출할 수 있습니다. 첫 번째 방법은 함수에 타입 인수를 포함한 모든 인수를 전달하는 방법입니다.</p> <pre data-language=\"ts\">let output = identity&lt;string&gt;(\"myString\"); // 출력 타입은 'string'입니다.</pre> <p>여기서 우리는 함수를 호출할 때의 인수 중 하나로써 <code>Type</code>를 <code>string</code>으로 명시해 주고 인수 주변에 <code>()</code> 대신 <code>&lt;&gt;</code>로 감싸주었습니다.</p> <p>두 번째 방법은 아마 가장 일반적인 방법입니다. 여기서는 <em>타입 인수 추론</em> 을 사용합니다 — 즉, 우리가 전달하는 인수에 따라서 컴파일러가 <code>Type</code>의 값을 자동으로 정하게 하는 것입니다:</p> <pre data-language=\"ts\">let output = identity(\"myString\"); // 출력 타입은 'string'입니다.</pre> <p>타입 인수를 꺾쇠괄호(<code>&lt;&gt;</code>)에 담아 명시적으로 전달해 주지 않은 것을 주목하세요; 컴파일러는 값인 <code>\"myString\"</code>를 보고 그것의 타입으로 <code>Type</code>를 정합니다. 인수 추론은 코드를 간결하고 가독성 있게 하는 데 있어 유용하지만 더 복잡한 예제에서 컴파일러가 타입을 유추할 수 없는 경우엔 명시적인 타입 인수 전달이 필요할 수도 있습니다.</p> <h1 id=\"제네릭-타입-변수-작업-working-with-generic-type-variables\" style=\"position:relative;\">제네릭 타입 변수 작업 (Working with Generic Type Variables)</h1> <p>제네릭을 사용하기 시작하면, <code>identity</code>와 같은 제네릭 함수를 만들 때, 컴파일러가 함수 본문에 제네릭 타입화된 매개변수를 쓰도록 강요합니다. 즉, 이 매개변수들은 실제로 <code>any</code> 나 모든 타입이 될 수 있는 것처럼 취급할 수 있게 됩니다.</p> <p>앞에서 본 <code>identity</code> 함수를 살펴보도록 합니다:</p> <pre data-language=\"ts\">function identity&lt;Type&gt;(arg: Type): Type {\n  return arg;\n}</pre> <p>함수 호출 시마다 인수 <code>arg</code>의 길이를 로그에 찍으려면 어떻게 해야 합니까? 아마 이것을 쓰고 싶을 겁니다:</p> <pre data-language=\"ts\">function loggingIdentity&lt;Type&gt;(arg: Type): Type {\n  console.log(arg.length); // 오류: Type에는 .length 가 없습니다.\n  return arg;\n}</pre> <p>이렇게 하면, 컴파일러는 <code>arg</code>의 멤버 <code>.length</code>를 사용하고 있다는 오류를 낼 것입니다만, 어떤 곳에서도 <code>arg</code>가 이 멤버가 있다는 것이 명시되어 있지 않습니다. 이전에 이러한 변수 타입은 <code>any</code>나 모든 타입을 의미한다고 했던 것을 기억하십시오. 따라서 이 함수를 쓰고 있는 사용자는 <code>.length</code> 멤버가 없는 <code>number</code>를 대신 전달할 수도 있습니다</p> <p>실제로 이 함수가 <code>Type</code>가 아닌 <code>Type</code>의 배열에서 동작하도록 의도했다고 가정해봅시다. 배열로 사용하기 때문에 <code>.length</code> 멤버는 사용 가능합니다. 다른 타입들의 배열을 만드는 것처럼 표현할 수 있습니다.</p> <pre data-language=\"ts\">function loggingIdentity&lt;Type&gt;(arg: Type[]): Type[] {\n  console.log(arg.length); // 배열은 .length를 가지고 있습니다. 따라서 오류는 없습니다.\n  return arg;\n}</pre> <p><code>loggingIdentity</code>의 타입을 “제너릭 함수 <code>loggingIdentity</code>는 타입 매개변수 <code>Type</code>와 <code>Type</code> 배열인 인수 <code>arg</code>를 취하고 <code>Type</code> 배열을 반환한다.”라고 읽을 수 있습니다. 만약 우리가 number 배열을 넘기면 <code>Type</code>가 <code>number</code>에 바인딩 되므로 함수는 number 배열을 얻게 됩니다. 전체 타입변수를 쓰는 것보다 하나의 타입으로써 제네릭 타입변수 <code>Type</code>를 사용하는 것은 굉장한 유연함을 제공합니다.</p> <p>위 예제를 이렇게도 대체할 수 있습니다.</p> <pre data-language=\"ts\">function loggingIdentity&lt;Type&gt;(arg: Array&lt;Type&gt;): Array&lt;Type&gt; {\n  console.log(arg.length); // 배열은 .length를 가지고 있습니다. 따라서 오류는 없습니다.\n  return arg;\n}</pre> <p>다른 언어들과 비슷한 이런 타입 스타일이 이미 익숙할 것입니다. 다음 섹션에서는 어떻게 <code>Array&lt;T&gt;</code>와 같은 고유한 제네릭 타입을 만들 수 있는지에 대해 다루도록 하겠습니다.</p> <h1 id=\"제네릭-타입-generic-types\" style=\"position:relative;\">제네릭 타입 (Generic Types)</h1> <p>이전 섹션에서 우리는 타입을 초월한 제네릭 함수 <code>identity</code>를 만들었습니다. 이번 섹션에서는 함수 자체의 타입과 제네릭 인터페이스를 만드는 방법에 대해 살펴보겠습니다.</p> <p>제네릭 함수의 타입은 함수 선언과 유사하게 타입 매개변수가 먼저 나열되는, 비-제네릭 함수의 타입과 비슷합니다.</p> <pre data-language=\"ts\">function identity&lt;Type&gt;(arg: Type): Type {\n  return arg;\n}\n \nlet myIdentity: &lt;Type&gt;(arg: Type) =&gt; Type = identity;</pre> <p>또한 타입 변수의 수와 타입 변수가 사용되는 방식에 따라 타입의 제네릭 타입 매개변수에 다른 이름을 사용할 수도 있습니다.</p> <pre data-language=\"ts\">function identity&lt;Type&gt;(arg: Type): Type {\n  return arg;\n}\n \nlet myIdentity: &lt;Input&gt;(arg: Input) =&gt; Input = identity;</pre> <p>제네릭 타입을 객체 리터럴 타입의 함수 호출 시그니처로 작성할 수도 있습니다:</p> <pre data-language=\"ts\">function identity&lt;Type&gt;(arg: Type): Type {\n  return arg;\n}\n \nlet myIdentity: { &lt;Type&gt;(arg: Type): Type } = identity;</pre> <p>이것들로 첫 번째 제네릭 인터페이스를 작성할 수 있습니다. 앞서 예제의 객체 리터럴을 인터페이스로 가져옵니다:</p> <pre data-language=\"ts\">interface GenericIdentityFn {\n  &lt;Type&gt;(arg: Type): Type;\n}\n \nfunction identity&lt;Type&gt;(arg: Type): Type {\n  return arg;\n}\n \nlet myIdentity: GenericIdentityFn = identity;</pre> <p>비슷한 예제에서, 제네릭 매개변수를 전체 인터페이스의 매개변수로 옮기고 싶을지도 모릅니다. 이를 통해 제네릭 타입을 확인할 수 있습니다 (예 - <code>Dictionary</code> 가 아닌 <code>Dictionary&lt;string&gt;</code>). 이렇게 하면 인터페이스의 다른 모든 멤버가 타입 매개변수를 볼 수 있습니다.</p> <pre data-language=\"ts\">interface GenericIdentityFn&lt;Type&gt; {\n  (arg: Type): Type;\n}\n \nfunction identity&lt;Type&gt;(arg: Type): Type {\n  return arg;\n}\n \nlet myIdentity: GenericIdentityFn&lt;number&gt; = identity;</pre> <p>예제에 아주 작은 변화가 있었습니다. 제네릭 함수를 작성하는 것 대신 제네릭 타입의 일부인 비-제네릭 함수 시그니처를 가집니다. <code>GenericIdentityFn</code> 함수를 사용할 때, 시그니처가 사용할 것을 효과적으로 제한할 특정한 타입 인수가 필요합니다 (여기서는 <code>number</code>). 타입 매개변수를 호출 시그니처에 바로 넣을 때와 인터페이스 자체에 넣을 때를 이해하는 것은 타입의 제네릭 부분을 설명하는 데 도움이 됩니다.</p> <p>제네릭 인터페이스 외에도 제네릭 클래스를 만들 수 있습니다. 제네릭 열거형과 네임스페이스는 만들 수 없습니다.</p> <h1 id=\"제네릭-클래스-generic-classes\" style=\"position:relative;\">제네릭 클래스 (Generic Classes)</h1> <p>제네릭 클래스와 제네릭 인터페이스는 형태가 비슷합니다. 제네릭 클래스는 클래스 이름 뒤에 꺾쇠괄호(<code>&lt;&gt;</code>) 안쪽에 제네릭 타입 매개변수 목록을 가집니다.</p> <pre data-language=\"ts\">class GenericNumber&lt;NumType&gt; {\n  zeroValue: NumType;\n  add: (x: NumType, y: NumType) =&gt; NumType;\n}\n \nlet myGenericNumber = new GenericNumber&lt;number&gt;();\nmyGenericNumber.zeroValue = 0;\nmyGenericNumber.add = function (x, y) {\n  return x + y;\n};</pre> <p>이것은 <code>GenericNumber</code> 클래스의 문자 그대로 사용하지만 <code>number</code> 타입만 쓰도록 제한하는 것은 없습니다. 대신 <code>string</code>이나 훨씬 복잡한 객체를 사용할 수 있습니다.</p> <pre data-language=\"ts\">let stringNumeric = new GenericNumber&lt;string&gt;();\nstringNumeric.zeroValue = \"\";\nstringNumeric.add = function (x, y) {\n  return x + y;\n};\n \nconsole.log(stringNumeric.add(stringNumeric.zeroValue, \"test\"));</pre> <p>인터페이스와 마찬가지로 클래스 자체에 타입 매개변수를 넣으면 클래스의 모든 프로퍼티가 동일한 타입으로 동작하는 것을 확인할 수 있습니다.</p> <p><a href=\"classes.md\">클래스</a>에서 다뤘던 것처럼 클래스는 두 가지 타입을 가집니다: 정적 측면과 인스턴스 측면. 제네릭 클래스는 정적 측면이 아닌 인스턴스 측면에서만 제네릭이므로 클래스로 작업할 때 정적 멤버는 클래스의 타입 매개변수를 쓸 수 없습니다.</p> <h1 id=\"제네릭-제약조건-generic-constraints\" style=\"position:relative;\">제네릭 제약조건 (Generic Constraints)</h1> <p>앞쪽의 예제를 기억한다면 특정 타입들로만 동작하는 제네릭 함수를 만들고 싶을 수 있습니다. 앞서 <code>loggingIdentity</code> 예제에서 <code>arg</code>의 프로퍼티 <code>.length</code>에 접근하기를 원했지만, 컴파일러는 모든 타입에서 <code>.length</code> 프로퍼티를 가짐을 증명할 수 없으므로 경고합니다.</p> <pre data-language=\"ts\">function loggingIdentity&lt;Type&gt;(arg: Type): Type {\n  console.log(arg.length);\n  return arg;\n}</pre> <p>any와 모든 타입에서 동작하는 대신에, <code>.length</code> 프로퍼티가 있는 any와 모든 타입들에서 작동하는 것으로 제한하고 싶습니다. 타입이 이 멤버가 있는 한 허용하지만, 최소한 <code>.length</code> 가 있어야 합니다. 그렇게 하려면 <code>Type</code> 가 무엇이 될 수 있는지에 대한 제약 조건을 나열해야 합니다.</p> <p>이를 위해 우리의 제약조건이 명시하는 인터페이스를 만듭니다. 여기 하나의 프로퍼티 <code>.length</code>를 가진 인터페이스를 생성하였고, 우리의 제약사항을 <code>extends</code> 키워드로 표현한 인터페이스를 이용해 명시합니다:</p> <pre data-language=\"ts\">interface Lengthwise {\n  length: number;\n}\n \nfunction loggingIdentity&lt;Type extends Lengthwise&gt;(arg: Type): Type {\n  console.log(arg.length); // Now we know it has a .length property, so no more error\n  return arg;\n}</pre> <p>제네릭 함수는 이제 제한되어 있기 때문에 모든 타입에 대해서는 동작하지 않습니다:</p> <pre data-language=\"ts\">loggingIdentity(3);</pre> <p>대신 필요한 프로퍼티들이 있는 타입의 값을 전달해야 합니다:</p> <pre data-language=\"ts\">loggingIdentity({ length: 10, value: 3 });</pre> <h2 id=\"제네릭-제약조건에서-타입-매개변수-사용-using-type-parameters-in-generic-constraints\" style=\"position:relative;\">제네릭 제약조건에서 타입 매개변수 사용 (Using Type Parameters in Generic Constraints)</h2> <p>다른 타입 매개변수로 제한된 타입 매개변수를 선언할 수 있습니다. 이름이 있는 객체에서 프로퍼티를 가져오고 싶은 경우를 예로 들어 봅시다. 실수로 <code>obj</code>에 존재하지 않는 프로퍼티를 가져오지 않도록 하기 위해 두 가지 타입에 제약조건을 두었습니다.</p> <pre data-language=\"ts\">function getProperty&lt;Type, Key extends keyof Type&gt;(obj: Type, key: Key) {\n  return obj[key];\n}\n \nlet x = { a: 1, b: 2, c: 3, d: 4 };\n \ngetProperty(x, \"a\");\ngetProperty(x, \"m\");</pre> <h2 id=\"제네릭에서-클래스-타입-사용-using-class-types-in-generics\" style=\"position:relative;\">제네릭에서 클래스 타입 사용 (Using Class Types in Generics)</h2> <p>제네릭을 사용하는 TypeScript에서 팩토리를 생성할 때 생성자 함수로 클래스 타입을 참조해야 합니다. 예를 들면:</p> <pre data-language=\"ts\">function create&lt;Type&gt;(c: { new (): Type }): Type {\n  return new c();\n}</pre> <p>고급 예제에서는 prototype 프로퍼티를 사용하여 생성자 함수와 클래스 타입의 인스턴스 사이의 관계를 유추하고 제한합니다.</p> <pre data-language=\"ts\">class BeeKeeper {\n  hasMask: boolean;\n}\n \nclass ZooKeeper {\n  nametag: string;\n}\n \nclass Animal {\n  numLegs: number;\n}\n \nclass Bee extends Animal {\n  keeper: BeeKeeper;\n}\n \nclass Lion extends Animal {\n  keeper: ZooKeeper;\n}\n \nfunction createInstance&lt;A extends Animal&gt;(c: new () =&gt; A): A {\n  return new c();\n}\n \ncreateInstance(Lion).keeper.nametag; // 타입검사!\ncreateInstance(Bee).keeper.hasMask;  // 타입검사!</pre> <p>이 패턴은 <a href=\"https://www.typescriptlang.org/docs/handbook/mixins.html\">mixins</a> 디자인 패턴을 만드는 데에 사용되었습니다.</p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2012-2023 Microsoft<br>Licensed under the Apache License, Version 2.0.<br>\n    <a href=\"https://www.typescriptlang.org/ko/docs/handbook/2/generics.html\" class=\"_attribution-link\">https://www.typescriptlang.org/ko/docs/handbook/2/generics.html</a>\n  </p>\n</div>\n","integrating-with-build-tools":"<h1>Integrating with Build Tools</h1>\n<p>빌드 도구들</p> <ul> <li><a href=\"#babel\">Babel</a></li> <li><a href=\"#browserify\">Browserify</a></li> <li><a href=\"#duo\">Duo</a></li> <li><a href=\"#grunt\">Grunt</a></li> <li><a href=\"#gulp\">Gulp</a></li> <li><a href=\"#jspm\">Jspm</a></li> <li><a href=\"#webpack\">Webpack</a></li> <li><a href=\"#msbuild\">MSBuild</a></li> <li><a href=\"#nuget\">NuGet</a></li> </ul> <h1 id=\"babel\" style=\"position:relative;\">Babel</h1> <h3 id=\"설치\" style=\"position:relative;\">설치</h3> <pre data-language=\"shell\">npm install @babel/cli @babel/core @babel/preset-typescript --save-dev</pre> <h3 id=\"babelrc\" style=\"position:relative;\">.babelrc</h3> <pre data-language=\"js\">{\n  \"presets\": [\"@babel/preset-typescript\"]\n}</pre> <h3 id=\"커맨드-라인-인터페이스-사용\" style=\"position:relative;\">커맨드 라인 인터페이스 사용</h3> <pre data-language=\"shell\">./node_modules/.bin/babel --out-file bundle.js src/index.ts</pre> <h3 id=\"packagejson\" style=\"position:relative;\">package.json</h3> <pre data-language=\"js\">{\n  \"scripts\": {\n    \"build\": \"babel --out-file bundle.js main.ts\"\n  },\n}</pre> <h3 id=\"커맨드-라인-인터페이스-사용-1\" style=\"position:relative;\">커맨드 라인 인터페이스 사용</h3> <pre data-language=\"shell\">npm run build</pre> <h1 id=\"browserify\" style=\"position:relative;\">Browserify</h1> <h3 id=\"설치-1\" style=\"position:relative;\">설치</h3> <pre data-language=\"shell\">npm install tsify</pre> <h3 id=\"커맨드-라인-인터페이스-사용-2\" style=\"position:relative;\">커맨드 라인 인터페이스 사용</h3> <pre data-language=\"shell\">browserify main.ts -p [ tsify --noImplicitAny ] &gt; bundle.js</pre> <h3 id=\"api-사용\" style=\"position:relative;\">API 사용</h3> <pre data-language=\"js\">var browserify = require(\"browserify\");\nvar tsify = require(\"tsify\");\n\nbrowserify()\n    .add(\"main.ts\")\n    .plugin(\"tsify\", { noImplicitAny: true })\n    .bundle()\n    .pipe(process.stdout);</pre> <p>자세한 내용: <a href=\"https://github.com/smrq/tsify\">smrq/tsify</a></p> <h1 id=\"duo\" style=\"position:relative;\">Duo</h1> <h3 id=\"설치-2\" style=\"position:relative;\">설치</h3> <pre data-language=\"shell\">npm install duo-typescript</pre> <h3 id=\"커맨드-라인-인터페이스-사용-3\" style=\"position:relative;\">커맨드 라인 인터페이스 사용</h3> <pre data-language=\"shell\">duo --use duo-typescript entry.ts</pre> <h3 id=\"api-사용-1\" style=\"position:relative;\">API 사용</h3> <pre data-language=\"js\">var Duo = require(\"duo\");\nvar fs = require(\"fs\")\nvar path = require(\"path\")\nvar typescript = require(\"duo-typescript\");\n\nvar out = path.join(__dirname, \"output.js\")\n\nDuo(__dirname)\n    .entry(\"entry.ts\")\n    .use(typescript())\n    .run(function (err, results) {\n        if (err) throw err;\n        // 컴파일된 결과를 출력 파일에 작성합니다\n        fs.writeFileSync(out, results.code);\n    });</pre> <p>자세한 내용: <a href=\"https://github.com/frankwallis/duo-typescript\">frankwallis/duo-typescript</a></p> <h1 id=\"grunt\" style=\"position:relative;\">Grunt</h1> <h3 id=\"설치-3\" style=\"position:relative;\">설치</h3> <pre data-language=\"shell\">npm install grunt-ts</pre> <h3 id=\"기본-gruntfilejs\" style=\"position:relative;\">기본 Gruntfile.js</h3> <pre data-language=\"js\">module.exports = function(grunt) {\n    grunt.initConfig({\n        ts: {\n            default : {\n                src: [\"**/*.ts\", \"!node_modules/**/*.ts\"]\n            }\n        }\n    });\n    grunt.loadNpmTasks(\"grunt-ts\");\n    grunt.registerTask(\"default\", [\"ts\"]);\n};</pre> <p>자세한 내용: <a href=\"https://github.com/TypeStrong/grunt-ts\">TypeStrong/grunt-ts</a></p> <h1 id=\"gulp\" style=\"position:relative;\">Gulp</h1> <h3 id=\"설치-4\" style=\"position:relative;\">설치</h3> <pre data-language=\"shell\">npm install gulp-typescript</pre> <h3 id=\"기본-gulpfilejs\" style=\"position:relative;\">기본 gulpfile.js</h3> <pre data-language=\"js\">var gulp = require(\"gulp\");\nvar ts = require(\"gulp-typescript\");\n\ngulp.task(\"default\", function () {\n    var tsResult = gulp.src(\"src/*.ts\")\n        .pipe(ts({\n              noImplicitAny: true,\n              out: \"output.js\"\n        }));\n    return tsResult.js.pipe(gulp.dest(\"built/local\"));\n});</pre> <p>자세한 내용: <a href=\"https://github.com/ivogabe/gulp-typescript\">ivogabe/gulp-typescript</a></p> <h1 id=\"jspm\" style=\"position:relative;\">Jspm</h1> <h3 id=\"설치-5\" style=\"position:relative;\">설치</h3> <pre data-language=\"shell\">npm install -g jspm@beta</pre> <p><em>주의사항: 현재 jspm의 TypeScript 지원은 0.16beta 입니다.</em></p> <p>자세한 내용: <a href=\"https://github.com/Microsoft/TypeScriptSamples/tree/master/jspm\">TypeScriptSamples/jspm</a></p> <h1 id=\"webpack\" style=\"position:relative;\">Webpack</h1> <h3 id=\"설치-6\" style=\"position:relative;\">설치</h3> <pre data-language=\"shell\">npm install ts-loader --save-dev</pre> <h3 id=\"webpack-2-사용-시-기본-webpackconfigjs\" style=\"position:relative;\">Webpack 2 사용 시 기본 webpack.config.js</h3> <pre data-language=\"js\">module.exports = {\n    entry: \"./src/index.tsx\",\n    output: {\n        path: '/',\n        filename: \"bundle.js\"\n    },\n    resolve: {\n        extensions: [\".tsx\", \".ts\", \".js\", \".json\"]\n    },\n    module: {\n        rules: [\n            // '.ts' 또는 '.tsx' 확장자를 가진 모든 파일은 'ts-loader'에 의해 처리됩니다.\n            { test: /\\.tsx?$/, use: [\"ts-loader\"], exclude: /node_modules/ }\n        ]\n    }\n}</pre> <h3 id=\"webpack-1-사용-시-기본-webpackconfigjs\" style=\"position:relative;\">Webpack 1 사용 시 기본 webpack.config.js</h3> <pre data-language=\"js\">module.exports = {\n    entry: \"./src/index.tsx\",\n    output: {\n        filename: \"bundle.js\"\n    },\n    resolve: {\n        // '.ts'와 '.tsx'를 해석 가능한 확장자로 추가합니다.\n        extensions: [\"\", \".webpack.js\", \".web.js\", \".ts\", \".tsx\", \".js\"]\n    },\n    module: {\n        loaders: [\n            // '.ts' 또는 '.tsx' 확장자를 가진 모든 파일은 'ts-loader'에 의해 처리됩니다.\n            { test: /\\.tsx?$/, loader: \"ts-loader\" }\n        ]\n    }\n}</pre> <p><a href=\"https://www.npmjs.com/package/ts-loader\">ts-loader에 대한 자세한 내용</a>은 여기를 참조하세요.</p> <p>대안:</p> <ul> <li><a href=\"https://www.npmjs.com/package/awesome-typescript-loader\">awesome-typescript-loader</a></li> </ul> <h1 id=\"msbuild\" style=\"position:relative;\">MSBuild</h1> <p>로컬에 설치된 <code>Microsoft.TypeScript.Default.props</code> (맨 위)와 <code>Microsoft.TypeScript.targets</code> (맨 아래) 파일을 포함하도록 프로젝트 파일을 업데이트하세요:</p> <pre data-language=\"xml\">&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;\n&lt;Project ToolsVersion=\"4.0\" DefaultTargets=\"Build\" xmlns=\"http://schemas.microsoft.com/developer/msbuild/2003\"&gt;\n  &lt;!-- 하단에 default props 포함 --&gt;\n  &lt;Import\n      Project=\"$(MSBuildExtensionsPath32)\\Microsoft\\VisualStudio\\v$(VisualStudioVersion)\\TypeScript\\Microsoft.TypeScript.Default.props\"\n      Condition=\"Exists('$(MSBuildExtensionsPath32)\\Microsoft\\VisualStudio\\v$(VisualStudioVersion)\\TypeScript\\Microsoft.TypeScript.Default.props')\" /&gt;\n\n  &lt;!-- TypeScript 환경 설정 --&gt;\n  &lt;PropertyGroup Condition=\"'$(Configuration)' == 'Debug'\"&gt;\n    &lt;TypeScriptRemoveComments&gt;false&lt;/TypeScriptRemoveComments&gt;\n    &lt;TypeScriptSourceMap&gt;true&lt;/TypeScriptSourceMap&gt;\n  &lt;/PropertyGroup&gt;\n  &lt;PropertyGroup Condition=\"'$(Configuration)' == 'Release'\"&gt;\n    &lt;TypeScriptRemoveComments&gt;true&lt;/TypeScriptRemoveComments&gt;\n    &lt;TypeScriptSourceMap&gt;false&lt;/TypeScriptSourceMap&gt;\n  &lt;/PropertyGroup&gt;\n\n  &lt;!-- 하단에 default targets 포함 --&gt;\n  &lt;Import\n      Project=\"$(MSBuildExtensionsPath32)\\Microsoft\\VisualStudio\\v$(VisualStudioVersion)\\TypeScript\\Microsoft.TypeScript.targets\"\n      Condition=\"Exists('$(MSBuildExtensionsPath32)\\Microsoft\\VisualStudio\\v$(VisualStudioVersion)\\TypeScript\\Microsoft.TypeScript.targets')\" /&gt;\n&lt;/Project&gt;</pre> <p>MSBuild 컴파일러 옵션 정의에 대한 자세한 내용: <a href=\"compiler-options-in-msbuild.md\">MSBuild 프로젝트의 컴파일러 옵션 설정</a></p> <h1 id=\"nuget\" style=\"position:relative;\">NuGet</h1> <ul> <li>우-클릭 -&gt; Manage NuGet Packages</li> <li>\n<code>Microsoft.TypeScript.MSBuild</code>를 검색하세요</li> <li>\n<code>Install</code> 클릭</li> <li>설치가 완료되면 다시 빌드 하세요!</li> </ul> <p>자세한 내용은 <a href=\"http://docs.nuget.org/Consume/Package-Manager-Dialog\">패키지 매니저 다이얼로그</a>와 <a href=\"https://github.com/Microsoft/TypeScript/wiki/Nightly-drops#using-nuget-with-msbuild\">NuGet과 nightly builds 사용</a>을 참고하세요</p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2012-2023 Microsoft<br>Licensed under the Apache License, Version 2.0.<br>\n    <a href=\"https://www.typescriptlang.org/ko/docs/handbook/integrating-with-build-tools.html\" class=\"_attribution-link\">https://www.typescriptlang.org/ko/docs/handbook/integrating-with-build-tools.html</a>\n  </p>\n</div>\n","2/indexed-access-types":"<h1>Indexed Access Types</h1>\n<p>타입의 특정 프로퍼티를 찾기 위해서 <em>인덱싱된 접근 타입</em> 을 사용할 수 있습니다.</p> <pre data-language=\"ts\">type Person = { age: number; name: string; alive: boolean };\ntype Age = Person[\"age\"];</pre> <p>인덱싱된 타입은 그 자체로도 타입이라서 유니언, <code>keyof</code> 혹은 타입 전체에 사용할 수 있습니다.</p> <pre data-language=\"ts\">type I1 = Person[\"age\" | \"name\"];\n \ntype I2 = Person[keyof Person];\n \ntype AliveOrName = \"alive\" | \"name\";\ntype I3 = Person[AliveOrName];</pre> <p>존재하지 않는 프로퍼티를 인덱싱하려고 하면 오류가 발생합니다.</p> <pre data-language=\"ts\">type I1 = Person[\"alve\"];</pre> <p>또 다른 예로는 임의의 타입을 <code>number</code>로 인덱싱해서 배열 요소의 타입을 가져올 수 있습니다. <code>typeof</code>와 결합하면 편리하게 배열 리터럴의 요소 타입을 캡쳐할 수 있습니다.</p> <pre data-language=\"ts\">const MyArray = [\n  { name: \"Alice\", age: 15 },\n  { name: \"Bob\", age: 23 },\n  { name: \"Eve\", age: 38 },\n];\n \ntype Person = typeof MyArray[number];\ntype Age = typeof MyArray[number][\"age\"];\n// Or\ntype Age2 = Person[\"age\"];</pre> <p>인덱싱할 때 변수 참조를 위해 사용된 <code>const</code>는 사용할 수 없고, 오로지 타입만 사용 가능합니다.</p> <pre data-language=\"ts\">const key = \"age\";\ntype Age = Person[key];</pre> <p>하지만, 비슷한 스타일의 리팩터로 타입 별칭을 사용할 수 있습니다.</p> <pre data-language=\"ts\">type key = \"age\";\ntype Age = Person[key];</pre><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2012-2023 Microsoft<br>Licensed under the Apache License, Version 2.0.<br>\n    <a href=\"https://www.typescriptlang.org/ko/docs/handbook/2/indexed-access-types.html\" class=\"_attribution-link\">https://www.typescriptlang.org/ko/docs/handbook/2/indexed-access-types.html</a>\n  </p>\n</div>\n","type-checking-javascript-files":"<h1>Type Checking JavaScript Files</h1>\n<p><code>.ts</code> 파일과 <code>.js</code> 파일은 타입을 검사하는 방법에 몇 가지 주목할만한 차이점이 있습니다.</p> <h2 id=\"클래스-본문의-할당에서-추론된-프로퍼티-properties-are-inferred-from-assignments-in-class-bodies\" style=\"position:relative;\">클래스 본문의 할당에서 추론된 프로퍼티 (Properties are inferred from assignments in class bodies)</h2> <p>ES2015에는 클래스에 프로퍼티를 선언할 수 있는 수단이 없습니다. 프로퍼티는 객체 리터럴과 같이 동적으로 할당됩니다.</p> <p><code>.js</code> 파일에서, 컴파일러는 클래스 본문 내부에서 할당된 프로퍼티로부터 프로퍼티들을 추론합니다. 생성자가 정의되어 있지 않거나, 생성자에서 정의된 타입이 <code>undefined</code>나 <code>null</code>이 아닐 경우, 프로퍼티의 타입은 생성자에서 주어진 타입과 동일합니다. 전자에 해당 프로퍼티의 경우, 할당되었던 모든 값들의 타입을 가진 유니언 타입이 됩니다. 생성자에 정의된 프로퍼티는 항상 존재하는 것으로 가정하는 반면, 메서드, getter, setter에서만 정의된 프로퍼티는 선택적인 것으로 간주합니다.</p> <pre data-language=\"js\">class C {\n  constructor() {\n    this.constructorOnly = 0;\n    this.constructorUnknown = undefined;\n  }\n  method() {\n    this.constructorOnly = false; // 오류, constructorOnly는 Number 타입임\n    this.constructorUnknown = \"plunkbat\"; // 성공, constructorUnknown의 타입은 string | undefined\n    this.methodOnly = \"ok\"; // 성공, 그러나 methodOnly는 undefined 타입 또한 허용됨\n  }\n  method2() {\n    this.methodOnly = true; // 이 또한 성공, methodOnly의 타입은 string | boolean | undefined\n  }\n}</pre> <p>프로퍼티가 클래스 본문에서 설정되지 않았다면, 알 수 없는 것으로 간주합니다. 클래스에 읽기 전용 프로퍼티가 있는 경우, 생성자에서 선언에 JSDoc을 사용하여 타입을 추가하여 표시합니다. 이후엔 초기화하더라도 값을 지정할 필요가 없습니다.</p> <pre data-language=\"js\">class C {\n  constructor() {\n    /** @type {number | undefined} */\n    this.prop = undefined;\n    /** @type {number | undefined} */\n    this.count;\n  }\n}\n \nlet c = new C();\nc.prop = 0; // 성공\nc.count = \"string\"; // 오류: string 은 number|undefined에 할당할 수 없음</pre> <h2 id=\"생성자-함수와-클래스는-동일-constructor-functions-are-equivalent-to-classes\" style=\"position:relative;\">생성자 함수와 클래스는 동일 (Constructor functions are equivalent to classes)</h2> <p>ES2015 이전에는, JavaScript는 클래스 대신 생성자 함수를 사용했습니다. 컴파일러는 이러한 패턴을 지원하며 생성자 함수를 ES2015 클래스와 동일한 것으로 이해합니다. 앞서 설명한 프로퍼티 추론 규칙 또한 정확히 같은 방식으로 작용합니다.</p> <pre data-language=\"js\">function C() {\n  this.constructorOnly = 0;\n  this.constructorUnknown = undefined;\n}\nC.prototype.method = function () {\n  this.constructorOnly = false; // 오류\n  this.constructorUnknown = \"plunkbat\"; // 성공, 타입은 string | undefined가 됨\n};</pre> <h2 id=\"commonjs-모듈-지원-commonjs-modules-are-supported\" style=\"position:relative;\">CommonJS 모듈 지원 (CommonJS modules are supported)</h2> <p><code>.js</code> 파일에서, TypeScript는 CommonJS 모듈 포맷을 이해합니다. <code>exports</code>와 <code>module.exports</code> 할당은 export 선언으로 인식됩니다. 마찬가지로, <code>require</code> 함수 호출은 모듈 import로 인식됩니다. 예를 들어:</p> <pre data-language=\"js\">// `import module \"fs\"`와 같음\nconst fs = require(\"fs\");\n\n// `export function readFile`과 같음\nmodule.exports.readFile = function(f) {\n    return fs.readFileSync(f);\n}</pre> <p>JavaScript의 모듈 지원은 TypeScript의 모듈 지원보다 구문적으로 훨씬 관용적입니다. 따라서 대부분의 할당과 선언의 조합이 지원됩니다.</p> <h2 id=\"클래스-함수-객체-리터럴은-네임스페이스-classes-functions-and-object-literals-are-namespaces\" style=\"position:relative;\">클래스, 함수, 객체 리터럴은 네임스페이스 (Classes, functions, and object literals are namespaces)</h2> <p><code>.js</code> 파일에 있는 클래스는 네임스페이스입니다. 예를 들어, 다음과 같이 클래스를 중첩하는 데에 사용할 수 있습니다:</p> <pre data-language=\"js\">class C {}\nC.D = class {};</pre> <p>그리고 ES2015 이전 코드의 경우, 정적 메서드를 나타내는 데에 사용할 수도 있습니다:</p> <pre data-language=\"js\">function Outer() {\n  this.y = 2;\n}\n \nOuter.Inner = function () {\n  this.yy = 2;\n};\n \nOuter.innter();</pre> <p>또한 간단한 네임스페이스를 생성하는 데에 사용할 수도 있습니다:</p> <pre data-language=\"js\">var ns = {};\nns.C = class {};\nns.func = function () {};\n \nns;</pre> <p>다른 번형도 허용됩니다:</p> <pre data-language=\"js\">// 즉시 호출 함수 (IIFE)\nvar ns = (function (n) {\n  return n || {};\n})();\nns.CONST = 1;\n \n// 전역으로 기본 설정\nvar assign =\n  assign ||\n  function () {\n    // 여기엔 코드를\n  };\nassign.extra = 1;</pre> <h2 id=\"객체-리터럴은-확장-가능-object-literals-are-open-ended\" style=\"position:relative;\">객체 리터럴은 확장 가능 (Object literals are open-ended)</h2> <p><code>.ts</code> 파일에서, 변수 선언을 초기화하는 객체 리터럴은 선언에 해당 타입을 부여합니다. 원본 리터럴에 명시되어 있지 않은 새 멤버는 추가될 수 없습니다. 이 규칙은 <code>.js</code> 파일에선 완화됩니다; 객체 리터럴은 원본에 정의되지 않은 새로운 프로퍼티를 조회하고 추가하는 것이 허용되는 확장 가능한 타입(인덱스 시그니처)을 갖습니다. 예를 들어:</p> <pre data-language=\"js\">var obj = { a: 1 };\nobj.b = 2; // 허용됨</pre> <p>객체 리터럴은 마치 닫힌 객체가 아니라 열린 맵(maps)으로 다뤄지도록 <code>[x:string]: any</code>와 같은 인덱스 시그니처를 가진 것처럼 동작합니다.</p> <p>다른 특정 JavaScript 검사 동작과 마찬가지로, 해당 동작은 변수에 JSDoc 타입을 지정하여 변경할 수 있습니다. 예를 들어:</p> <pre data-language=\"js\">/** @type {{a: number}} */\nvar obj = { a: 1 };\nobj.b = 2; // 오류, {a: number}타입엔 b 프로퍼티가 없음</pre> <h2 id=\"null-undefined-및-빈-배열-이니셜라이저는-any-혹은-any-타입-null-undefined-and-empty-array-initializers-are-of-type-any-or-any\" style=\"position:relative;\">null, undefined 및 빈 배열 이니셜라이저는 any 혹은 any[] 타입 (null, undefined, and empty array initializers are of type any or any[])</h2> <p>null 또는 undefined로 초기화된 변수나 매개변수 또는 프로퍼티는, 엄격한 null 검사가 있더라도 any 타입을 갖게 될 것입니다. []로 초기화된 변수나 매개변수 또는 프로퍼티는, 엄격한 null 검사가 있더라도 any[] 타입을 갖게 될 것입니다. 위에서 설명한 여러 이니셜라이저(initializer)를 갖는 프로퍼티만이 유일한 예외입니다.</p> <pre data-language=\"js\">function Foo(i = null) {\n  if (!i) i = 1;\n  var j = undefined;\n  j = 2;\n  this.l = [];\n}\n \nvar foo = new Foo();\nfoo.l.push(foo.i);\nfoo.l.push(\"end\");</pre> <h2 id=\"함수-매개변수는-기본적으로-선택-사항-function-parameters-are-optional-by-default\" style=\"position:relative;\">함수 매개변수는 기본적으로 선택 사항 (Function parameters are optional by default)</h2> <p>ES2015 이전의 JavaScript는 선택적인 매개변수를 지정할 방법이 없었기 때문에, <code>.js</code> 파일에선 모든 함수의 매개변수는 선택적인 것으로 간주됩니다. 선언된 매개변수보다 적은 인수로 호출하는 것이 허용됩니다.</p> <p>그러나 너무 많은 인수를 넣어 호출하면 오류를 일으킨다는 것에 유의하세요.</p> <p>예를 들어:</p> <pre data-language=\"js\">function bar(a, b) {\n  console.log(a + \" \" + b);\n}\n \nbar(1); // 성공, 두 번째 인수는 선택 사항임\nbar(1, 2);\nbar(1, 2, 3); // 오류, 인수의 갯수가 너무 많음</pre> <p>JSDoc 표시가 된 함수는 이 규칙에서 예외입니다. JSDoc의 선택적 매개변수 구문 (<code>[</code> <code>]</code>) 을 사용하여 선택 사항을 표시할 수 있습니다. 예시:</p> <pre data-language=\"js\">/**\n * @param {string} [somebody] - 누군가의 이름\n */\nfunction sayHello(somebody) {\n  if (!somebody) {\n    somebody = \"John Doe\";\n  }\n  console.log(\"Hello \" + somebody);\n}\n \nsayHello();</pre> <h2 id=\"arguments-사용으로부터-추론된-var-args-매개변수-선언-var-args-parameter-declaration-inferred-from-use-of-arguments\" style=\"position:relative;\">\n<code>arguments</code> 사용으로부터 추론된 var-args 매개변수 선언 (Var-args parameter declaration inferred from use of <code>arguments</code>)</h2> <p><code>arguments</code> 참조를 참조하는 본문을 가진 함수는, 암묵적으로 var-args 매개변수(예: <code>(...arg: any[]) =&gt; any</code>)를 갖는 것으로 간주합니다. JSDoc의 var-args 구문을 사용하여 인수의 타입을 지정할 수 있습니다.</p> <pre data-language=\"js\">/** @param {...number} args */\nfunction sum(/* numbers */) {\n  var total = 0;\n  for (var i = 0; i &lt; arguments.length; i++) {\n    total += arguments[i];\n  }\n  return total;\n}</pre> <h2 id=\"타입이-지정되지-않은-매개변수는-기본적으로-any임-unspecified-type-parameters-default-to-any\" style=\"position:relative;\">타입이 지정되지 않은 매개변수는 기본적으로 <code>any</code>임 (Unspecified type parameters default to <code>any</code>)</h2> <p>JavaScript에는 제네릭 타입의 매개변수를 지정하는 구문이 없으므로, 타입이 지정되지 않은 매개변수는 기본적으로 <code>any</code> 타입입니다.</p> <h3 id=\"확장-절에서-in-extends-clause\" style=\"position:relative;\">확장 절에서 (In extends clause)</h3> <p>예를 들어, <code>React.Component</code>는 <code>Props</code>와 <code>State</code>라는 두 타입의 매개변수를 갖도록 정의되어 있습니다. <code>.js</code> 파일에는 이러한 것들을 확장 절에 지정할 수 있는 정당한 방법이 없습니다. 기본적으로 해당 타입 인수는 <code>any</code>가 될 것입니다:</p> <pre data-language=\"js\">import { Component } from \"react\";\n\nclass MyComponent extends Component {\n    render() {\n        this.props.b; // this.props의 타입이 any이므로 허용됨\n    }\n}</pre> <p>타입을 명시적으로 지정하려면 JSDoc의 <code>@augments</code>를 사용하세요. 예를 들어:</p> <pre data-language=\"js\">import { Component } from \"react\";\n\n/**\n * @augments {Component&lt;{a: number}, State&gt;}\n */\nclass MyComponent extends Component {\n    render() {\n        this.props.b; // 오류: b 는 {a:number}에 속하지 않음\n    }\n}</pre> <h3 id=\"jsdoc-참조에서-in-jsdoc-references\" style=\"position:relative;\">JSDoc 참조에서 (In JSDoc references)</h3> <p>JSDoc의 지정되지 않은 타입 인수는 기본적으로 any입니다:</p> <pre data-language=\"js\">/** @type{Array} */\nvar x = [];\n\nx.push(1);        // 성공\nx.push(\"string\"); // 성공, x는 Array&lt;any&gt; 타입임\n\n/** @type{Array.&lt;number&gt;} */\nvar y = [];\n\ny.push(1);        // 성공\ny.push(\"string\"); // 오류, string을 number 타입에 할당할 수 없음\n</pre> <h3 id=\"함수-호출에서-in-function-calls\" style=\"position:relative;\">함수 호출에서 (In function calls)</h3> <p>제네릭 함수의 호출은 인수를 사용해 타입 매개변수를 추론합니다. 때때로 이 과정은 추론 소스가 부족하여 어떠한 타입도 추론하지 못하는 경우가 있습니다; 이러한 경우, 매개변수 타입은 기본적으로 <code>any</code>입니다. 예를 들어:</p> <pre data-language=\"js\">var p = new Promise((resolve, reject) =&gt; { reject() });\n\np; // Promise&lt;any&gt;;</pre> <p>JSDoc의 모든 기능은 <a href=\"https://www.typescriptlang.org/docs/handbook/jsdoc-supported-types.html\">여기</a>에서 확인할 수 있습니다.</p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2012-2023 Microsoft<br>Licensed under the Apache License, Version 2.0.<br>\n    <a href=\"https://www.typescriptlang.org/ko/docs/handbook/type-checking-javascript-files.html\" class=\"_attribution-link\">https://www.typescriptlang.org/ko/docs/handbook/type-checking-javascript-files.html</a>\n  </p>\n</div>\n","declaration-files/do-s-and-don-ts":"<h1>Do's and Don'ts</h1>\n<h1 id=\"일반-타입-general-types\" style=\"position:relative;\">일반 타입 (General Types)</h1> <h2 id=\"number-string-boolean-symbol-and-object\" style=\"position:relative;\">\n<code>Number</code>, <code>String</code>, <code>Boolean</code>, <code>Symbol</code> and <code>Object</code>\n</h2> <p><code>Number</code>, <code>String</code>, <code>Boolean</code>, <code>Symbol</code>, <code>Object</code> 타입을 사용<em>하지 마세요</em>. 이 타입들은 JavaScript 코드에서 거의 사용되지 않는 비-원시형 박싱된 객체를 가르킵니다.</p> <pre data-language=\"ts\">/* 잘못됨 */\nfunction reverse(s: String): String;</pre> <p><code>number</code>, <code>string</code>, <code>boolean</code>, <code>symbol</code> 타입을 사용 <em>하세요</em>.</p> <pre data-language=\"ts\">/* 좋음 */\nfunction reverse(s: string): string;</pre> <p><code>Object</code> 대신에, <a href=\"https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-2.html#object-type\">TypeScript 2.2 에 추가된</a> 비-원시형 <code>object</code>타입을 사용<em>하세요</em>.</p> <h2 id=\"제네릭-generics\" style=\"position:relative;\">제네릭 (Generics)</h2> <p>타입 매개변수를 사용하지 않는 제네릭 타입을 사용<em>하지 마세요</em>. 더 자세한 내용은 <a href=\"https://github.com/Microsoft/TypeScript/wiki/FAQ#why-doesnt-type-inference-work-on-this-interface-interface-foot---\">TypeScript FAQ 페이지</a>에서 확인하세요.</p>  <h1 id=\"콜백-타입-callback-types\" style=\"position:relative;\">콜백 타입 (Callback Types)</h1> <h2 id=\"콜백의-반환-타입-return-types-of-callbacks\" style=\"position:relative;\">콜백의 반환 타입 (Return Types of Callbacks)</h2>  <p>사용하지 않는 콜백의 반환 값 타입에 <code>any</code>를 사용<em>하지 마세요</em>:</p> <pre data-language=\"ts\">/* 잘못됨 */\nfunction fn(x: () =&gt; any) {\n    x();\n}</pre> <p>사용하지 않는 콜백의 반환 값 타입은 <code>void</code>를 사용<em>하세요</em>:</p> <pre data-language=\"ts\">/* 좋음 */\nfunction fn(x: () =&gt; void) {\n    x();\n}</pre> <p><em>이유</em>: <code>void</code>를 사용하면 실수로 <code>x</code>의 반환 값을 사용하는 것을 방지 할 수 있기 때문에 더 안전합니다.:</p> <pre data-language=\"ts\">function fn(x: () =&gt; void) {\n    var k = x(); // oops! meant to do something else\n    k.doSomething(); // error, but would be OK if the return type had been 'any'\n}</pre> <h2 id=\"콜백에서-선택적-매개변수-optional-parameters-in-callbacks\" style=\"position:relative;\">콜백에서 선택적 매개변수 (Optional Parameters in Callbacks)</h2> <p>정말 의도한 것이 아니라면 콜백에 선택적 매개변수를 사용<em>하지 마세요</em>:</p> <pre data-language=\"ts\">/* 잘못됨 */\ninterface Fetcher {\n    getObject(done: (data: any, elapsedTime?: number) =&gt; void): void;\n}</pre> <p>이는 아주 구체적인 의미를 가지고 있습니다: <code>done</code> 콜백은 1개 혹은 2개의 인자로 호출될 수 있습니다. 작성자는 아마 <code>elapsedTime</code> 매개변수가 콜백에 상관없다는 것을 말하려는 의도였을 것입니다, 하지만 이를 위해 매개변수를 선택적으로 만들 필요는 없습니다 — 콜백에 더 적은 인수를 제공하는 것은 항상 허용됩니다.</p> <p>콜백 매개변수를 비-선택적으로 작성<em>하세요</em>:</p> <pre data-language=\"ts\">/* 좋음 */\ninterface Fetcher {\n    getObject(done: (data: any, elapsedTime: number) =&gt; void): void;\n}</pre> <h2 id=\"오버로드와-콜백-overloads-and-callbacks\" style=\"position:relative;\">오버로드와 콜백 (Overloads and Callbacks)</h2> <p>콜백의 인수만 다른 오버로드를 분리해서 작성 <em>하지 마세요</em>:</p> <pre data-language=\"ts\">/* 잘못됨 */\ndeclare function beforeAll(action: () =&gt; void, timeout?: number): void;\ndeclare function beforeAll(action: (done: DoneFn) =&gt; void, timeout?: number): void;</pre> <p>최대 인수를 사용해 하나의 오버로드를 작성 <em>하세요</em>:</p> <pre data-language=\"ts\">/* 좋음 */\ndeclare function beforeAll(action: (done: DoneFn) =&gt; void, timeout?: number): void;</pre> <p><em>이유</em>: 콜백이 매개변수를 무시하는 것은 항상 허용되므로, 짧은 오버로드는 필요하지 않습니다. 더 짧은 콜백을 먼저 작성하면 넘어오는 함수가 첫 번째 오버로드와 일치하기 때문에 잘못된-타입의 함수를 허용합니다.</p> <h1 id=\"함수-오버로드-function-overloads\" style=\"position:relative;\">함수 오버로드 (Function Overloads)</h1> <h2 id=\"순서-ordering\" style=\"position:relative;\">순서 (Ordering)</h2> <p>더 일반적인 오버로드를 더 구체적인 오버로드 이전에 두지 <em>마세요</em>:</p> <pre data-language=\"ts\">/* 잘못됨 */\ndeclare function fn(x: any): any;\ndeclare function fn(x: HTMLElement): number;\ndeclare function fn(x: HTMLDivElement): string;\n\nvar myElem: HTMLDivElement;\nvar x = fn(myElem); // x: any, wat?</pre> <p>구체적인 오버로드 뒤에 일반적인 오버로드가 위치하게 정렬 <em>하세요</em>:</p> <pre data-language=\"ts\">/* 좋음 */\ndeclare function fn(x: HTMLDivElement): string;\ndeclare function fn(x: HTMLElement): number;\ndeclare function fn(x: any): any;\n\nvar myElem: HTMLDivElement;\nvar x = fn(myElem); // x: string, :)</pre> <p><em>이유</em>: TypeScript는 함수 호출을 처리할 때 <em>첫 번째로 일치하는 오버로드</em>를 선택합니다. 이전의 오버로드가 뒤에 것보다 “더 구체적”이면, 뒤에 것은 사실상 가려져 호출되지 않습니다.</p> <h2 id=\"선택적-매개변수-사용-use-optional-parameters\" style=\"position:relative;\">선택적 매개변수 사용 (Use Optional Parameters)</h2> <p>뒤따라오는 매개변수만 다른 오버로드를 작성<em>하지 마세요</em>:</p> <pre data-language=\"ts\">/* 잘못됨 */\ninterface Example {\n    diff(one: string): number;\n    diff(one: string, two: string): number;\n    diff(one: string, two: string, three: boolean): number;\n}</pre> <p>가능한 선택적 매개변수를 사용 <em>하세요</em>:</p> <pre data-language=\"ts\">/* 좋음 */\ninterface Example {\n    diff(one: string, two?: string, three?: boolean): number;\n}</pre> <p>이 문제는 모든 오버로드가 같은 반환 타입을 가질 때만 발생한다는 점에 유의하세요.</p> <p><em>이유</em>: 두 가지 중요한 이유가 있습니다.</p> <p>TypeScript는 소스의 인수로 대상의 시그니처를 호출할 수 있는지 확인하여 시그니처 호환성을 결정합니다. <em>그리고 관계없는 인수가 허용됩니다</em> 예를 들어, 이 코드는 선택적 매개변수를 사용하여 올바르게 작성된 경우에만 버그를 노출합니다:</p> <pre data-language=\"ts\">function fn(x: (a: string, b: number, c: number) =&gt; void) { }\nvar x: Example;\n// 오버로드로 작성한 경우, OK -- 첫번째 오버로드가 사용됨\n// 선택적으로 작성한 경우, 올바르게 오류.\nfn(x.diff);</pre> <p>두 번째 이유는 사용자가 TypeScript의 “strict null checking” 기능을 사용할 때입니다. JavaScript에서 지정되지 않은 매개변수는 <code>undefined</code>로 나타나기 때문에, 일반적으로 선택적 매개변수가 있는 함수에 명시적으로 <code>undefined</code>를 전달하는 것이 좋습니다. 예를 들어, 이 코드는, strict null에서 문제없습니다.</p> <pre data-language=\"ts\">var x: Example;\n// 오버로드로 작성한 경우, `undefined`를 `string` 에 전달했기 때문에 잘못된 에러\n// 선택적으로 작성한 경우, 올바름\nx.diff(\"something\", true ? undefined : \"hour\");</pre> <h2 id=\"유니언-타입-사용-use-union-types\" style=\"position:relative;\">유니언 타입 사용 (Use Union Types)</h2> <p>한 인수 위치에서 타입만 다른 오버로드를 사용<em>하지 마세요</em>:</p> <pre data-language=\"ts\">/* 잘못됨 */\ninterface Moment {\n    utcOffset(): number;\n    utcOffset(b: number): Moment;\n    utcOffset(b: string): Moment;\n}</pre> <p>가능한 유니언 타입을 사용 <em>하세요</em>:</p> <pre data-language=\"ts\">/* 좋음 */\ninterface Moment {\n    utcOffset(): number;\n    utcOffset(b: number|string): Moment;\n}</pre> <p>시그니처의 반환 타입이 다르기 때문에 <code>b</code>를 선택적으로 만들지 않은 점에 유의하세요.</p> <p><em>이유</em>: 이는 함수에 값을 “전달하는” 사람들에게 중요합니다.:</p> <pre data-language=\"ts\">function fn(x: string): void;\nfunction fn(x: number): void;\nfunction fn(x: number|string) {\n    // 분리된 오버로드로 작성된 경우, 잘못된 에러\n    // 유니언 타입으로 작성된 경우, 올바름\n    return moment().utcOffset(x);\n}</pre><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2012-2023 Microsoft<br>Licensed under the Apache License, Version 2.0.<br>\n    <a href=\"https://www.typescriptlang.org/ko/docs/handbook/declaration-files/do-s-and-don-ts.html\" class=\"_attribution-link\">https://www.typescriptlang.org/ko/docs/handbook/declaration-files/do-s-and-don-ts.html</a>\n  </p>\n</div>\n","2/keyof-types":"<h1>Keyof Type Operator</h1>\n<h2 id=\"keyof-타입-연산자\" style=\"position:relative;\">\n<code>keyof</code> 타입 연산자</h2> <p><code>keyof</code> 연산자는 객체 타입에서 객체의 키 값들을 숫자나 문자열 리터럴 유니언을 생성합니다. 아래 타입 P는 “x” | “y”와 동일한 타입입니다.</p> <pre data-language=\"ts\">type Point = { x: number; y: number };\ntype P = keyof Point;</pre> <p>만약 타입이 <code>string</code>이나 <code>number</code> 인덱스 시그니쳐를 가지고 있다면, <code>keyof</code>는 해당 타입을 리턴합니다.</p> <pre data-language=\"ts\">type Arrayish = { [n: number]: unknown };\ntype A = keyof Arrayish;\n \ntype Mapish = { [k: string]: boolean };\ntype M = keyof Mapish;</pre> <p>위 예제에서 주목할 점은 <code>M</code>은 <code>string | number</code>라는 점입니다. — JavaScript 객체 키는 항상 문자열을 강제하기 때문에, <code>obj[0]</code>은 <code>obj[\"0\"]</code>과 동일합니다.</p> <p><code>keyof</code> 타입은 우리가 추후에 학습할 매핑된 타입과 함께 사용할 때 특히 유용합니다.</p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2012-2023 Microsoft<br>Licensed under the Apache License, Version 2.0.<br>\n    <a href=\"https://www.typescriptlang.org/ko/docs/handbook/2/keyof-types.html\" class=\"_attribution-link\">https://www.typescriptlang.org/ko/docs/handbook/2/keyof-types.html</a>\n  </p>\n</div>\n","declaration-files/library-structures":"<h1>Library Structures</h1>\n<h1 id=\"개요-overview\" style=\"position:relative;\">개요 (Overview)</h1> <p>일반적으로, 선언 파일을 <em>구조화</em>하는 방법은 라이브러리를 사용하는 방법에 따라 다릅니다. JavaScript에서 사용할 라이브러리를 제공하는 방법은 여러 가지가 있고, 이에 맞추어 선언 파일을 작성해야 합니다. 이 가이드는 일반적인 라이브러리 패턴을 식별하는 방법과, 그 패턴에 상응하는 선언 파일을 작성하는 방법에 대해 다룹니다.</p> <p>주요 라이브러리 각각의 구조화 패턴 유형은 <a href=\"https://www.typescriptlang.org/docs/handbook/declaration-files/templates.html\">템플릿</a> 섹션에 있습니다. 이 템플릿으로 시작하면 더 빠르게 진행할 수 있습니다.</p> <h1 id=\"라이브러리-종류-식별하기-identifying-kinds-of-libraries\" style=\"position:relative;\">라이브러리 종류 식별하기 (Identifying Kinds of Libraries)</h1> <p>첫 번째로, TypeScript 선언 파일이 나타낼 수 있는 라이브러리 종류를 다뤄보겠습니다. 각 종류의 라이브러리를 <em>사용하는</em> 방법과, <em>작성하는</em> 방법, 그리고 실제 라이브러리들의 예제를 볼 것입니다.</p> <p>라이브러리의 구조를 식별하는 것은 선언 파일을 작성하는 첫 단계입니다. <em>사용법</em>과 <em>코드</em>를 기반으로 구조를 식별하는 방법에 대한 힌트를 제공합니다. 라이브러리의 문서와 구성에 따라서, 어떤 건 다른 것보다 훨씬 쉬울 수 있습니다. 본인에게 더 편한 것을 사용할 것을 추천합니다.</p> <h2 id=\"어떤-사항을-고려해야-하는가-what-should-you-look-for\" style=\"position:relative;\">어떤 사항을 고려해야 하는가? (What should you look for?)</h2> <p>라이브러리를 사용하기 전에, 다음 사항을 고려해 볼 수 있습니다.</p> <ol> <li> <p>라이브러리를 다운로드하는 방식이 무엇인가?</p> <p>예를 들어, npm으로만 다운로드 할 수 있는가? 아니면 CDN 에서만 다운로드 할 수 있는가?</p> </li> <li> <p>라이브러리를 임포트하는 방식이 무엇인가?</p> <p>전역 객체를 추가하는 방식인가? 아니면 <code>require</code> 또는 <code>import</code>/<code>export</code> 구문을 사용하는 방식인가?</p> </li> </ol> <h2 id=\"여러-종류의-라이브러리에-대한-간단한-샘플\" style=\"position:relative;\">여러 종류의 라이브러리에 대한 간단한 샘플</h2> <h2 id=\"모듈형-라이브러리-modular-libraries\" style=\"position:relative;\">모듈형 라이브러리 (Modular Libraries)</h2> <p>어떤 라이브러리는 모듈 로더 환경에서만 동작합니다. 예를 들어, <code>express</code>는 Node.js에서만 동작하고 반드시 CommonJS의 <code>require</code> 함수로 로드되어야 합니다.</p> <p>ECMAScript 2015 (ES2015, ECMAScript 6, ES6로도 잘 알려진), CommonJS와 RequireJS는 <em>모듈</em>을 <em>importing</em>하는 비슷한 개념을 가지고 있습니다. JavaScript의 CommonJS (Node.js)를 예를 들면, 다음과 같이 작성합니다</p> <pre data-language=\"js\">var fs = require(\"fs\");</pre> <p>TypeScript나 ES6에서는, <code>import</code> 키워드가 같은 목적을 제공합니다:</p> <pre data-language=\"ts\">import fs = require(\"fs\");</pre> <p>일반적으로 모듈형 라이브러리의 문서에서 다음 코드들 중 하나를 볼 수 있습니다:</p> <pre data-language=\"js\">var someLib = require('someLib');</pre> <p>혹은</p> <pre data-language=\"js\">define(..., ['someLib'], function(someLib) {\n\n});</pre> <p>전역 모듈과 마찬가지로 UMD 모듈의 문서에서도 이 예제들을 볼 수 있으므로, 코드나 문서를 반드시 확인하세요.</p> <h3 id=\"코드에서-모듈-라이브러리-식별하기-identifying-a-module-library-from-code\" style=\"position:relative;\">코드에서 모듈 라이브러리 식별하기 (Identifying a Module Library from Code)</h3> <p>모듈형 라이브러리는 일반적으로 다음 중 몇 가지를 반드시 가지고 있습니다:</p> <ul> <li>\n<code>require</code> 혹은 <code>define</code>에 대한 무조건적인 호출</li> <li>\n<code>import * as a from 'b';</code> 혹은 <code>export c;</code> 같은 선언문</li> <li>\n<code>exports</code> 혹은 <code>module.exports</code>에 대한 할당</li> </ul> <p>다음은 거의 갖지 않습니다:</p> <ul> <li>\n<code>window</code> 혹은 <code>global</code> 프로퍼티 할당</li> </ul> <h3 id=\"모듈을-위한-템플릿-templates-for-modules\" style=\"position:relative;\">모듈을 위한 템플릿 (Templates For Modules)</h3> <p>모듈을 위한 네 가지 템플릿이 있습니다.</p> <ul> <li><a href=\"https://www.typescriptlang.org/docs/handbook/declaration-files/templates/module-d-ts.html\"><code>module.d.ts</code></a></li> <li><a href=\"https://www.typescriptlang.org/docs/handbook/declaration-files/templates/module-class-d-ts.html\"><code>module-class.d.ts</code></a></li> <li><a href=\"https://www.typescriptlang.org/docs/handbook/declaration-files/templates/module-function-d-ts.html\"><code>module-function.d.ts</code></a></li> <li><a href=\"https://www.typescriptlang.org/docs/handbook/declaration-files/templates/module-plugin-d-ts.html\"><code>module-plugin.d.ts</code></a></li> </ul> <p>각각이 어떻게 동작하는지에 대한 개요는 <a href=\"https://www.typescriptlang.org/docs/handbook/declaration-files/templates/module-d-ts.html\"><code>module.d.ts</code></a>를 참조하세요.</p> <p>만약 모듈을 함수처럼 <em>호출</em>할 수 있으면 <a href=\"https://www.typescriptlang.org/docs/handbook/declaration-files/templates/module-function-d-ts.html\"><code>module-function.d.ts</code></a>을 사용하세요:</p> <pre data-language=\"js\">const x = require(\"foo\");\n// 참고: 함수로 'x'를 호출\nconst y = x(42);</pre> <p>만약 모듈이 <code>new</code>를 사용하여 <em>생성</em>될 수 있다면 <a href=\"https://www.typescriptlang.org/docs/handbook/declaration-files/templates/module-class-d-ts.html\"><code>module-class.d.ts</code></a>를 사용하세요:</p> <pre data-language=\"js\">const x = require(\"bar\");\n// 참고: 'new' 연산자를 import된 변수에 사용\nconst y = new x(\"hello\");</pre> <p>임포트 되었을 때 다른 모듈에 수정사항을 만드는 모듈을 사용한다면, <a href=\"https://www.typescriptlang.org/docs/handbook/declaration-files/templates/module-plugin-d-ts.html\"><code>module-plugin.d.ts</code></a> 템플릿을 사용하세요:</p> <pre data-language=\"js\">const jest = require(\"jest\");\nrequire(\"jest-matchers-files\");</pre> <h2 id=\"전역-라이브러리-global-libraries\" style=\"position:relative;\">전역 라이브러리 (Global Libraries)</h2> <p><em>전역</em> 라이브러리는 전역 스코프 (즉, <code>import</code> 형식을 사용하지 않음)에서 접근 가능한 라이브러리입니다. 많은 라이브러리는 사용을 위해 간단히 하나 이상의 전역 변수를 노출합니다. 예를 들어, <a href=\"https://jquery.com/\">jQuery</a>를 사용한다면, <code>$</code> 변수를 참조해서 사용할 수 있습니다:</p> <pre data-language=\"ts\">$(() =&gt; { console.log('hello!'); } );</pre> <p>HTML 스크립트 태그로 라이브러리를 사용하는 방법은 라이브러리 문서에서 지침을 볼 수 있습니다:</p> <pre data-language=\"html\">&lt;script src=\"http://a.great.cdn.for/someLib.js\"&gt;&lt;/script&gt;</pre> <p>오늘날, 대부분의 전역에서 접근 가능한 유명 라이브러리들은 실제로 UMD 라이브러리로 작성되어 있습니다 (아래를 참조). UMD 라이브러리 문서는 전역 라이브러리 문서와 구별하기 어렵습니다. 전역 선언 파일을 작성하기 전에, 실제로는 UMD가 아닌지 확인하십시오.</p> <h3 id=\"코드에서-전역-라이브러리-식별하기-identifying-a-global-library-from-code\" style=\"position:relative;\">코드에서 전역 라이브러리 식별하기 (Identifying a Global Library from Code)</h3> <p>전역 라이브러리 코드는 대게 엄청 간단합니다. 전역 “Hello, world” 라이브러리는 다음과 같습니다:</p> <pre data-language=\"js\">function createGreeting(s) {\n    return \"Hello, \" + s;\n}</pre> <p>혹은 다음과 같습니다:</p> <pre data-language=\"js\">// Web\nwindow.createGreeting = function (s) {\n  return \"Hello, \" + s;\n};\n\n// Node\nglobal.createGreeting = function (s) {\n  return \"Hello, \" + s;\n};\n\n// Potentially any runtime\nglobalThis.createGreeting = function (s) {\n  return \"Hello, \" + s;\n};</pre> <p>전역 라이브러리의 코드를 보면, 보통 다음을 볼 수 있습니다:</p> <ul> <li>최상위 레벨 <code>var</code>문 이나 <code>function</code>선언</li> <li>하나 이상의 <code>window.someName</code> 할당</li> <li>DOM 인터페이스 <code>document</code> 혹은 <code>window</code>가 존재한다고 가정</li> </ul> <p>다음은 볼 수 <em>없습니다</em>:</p> <ul> <li>\n<code>require</code> 이나 <code>define</code> 같은 모듈 로더 검사 혹은 사용</li> <li>\n<code>var fs = require(\"fs\");</code> 형태의 CommonJS/Node.js-스타일 import</li> <li>\n<code>define(...)</code> 호출</li> <li>라이브러리를 <code>require</code> 혹은 import하는 방법에 대해 설명하는 문서</li> </ul> <h3 id=\"전역-라이브러리-예제-examples-of-global-libraries\" style=\"position:relative;\">전역 라이브러리 예제 (Examples of Global Libraries)</h3> <p>전역 라이브러리를 UMD 라이브러리로 바꾸는게 쉽기 때문에, 전역 스타일로 작성한 인기 라이브러리는 거의 없습니다. 하지만, 크기가 작고 DOM이 필요한 (혹은 의존성이 <em>없는</em>) 라이브러리는 여전히 전역입니다.</p> <h3 id=\"전역-라이브러리-템플릿-global-library-template\" style=\"position:relative;\">전역 라이브러리 템플릿 (Global Library Template)</h3> <p>템플릿 파일 <a href=\"templates/global.d.ts.md\"><code>global.d.ts</code></a>은 예제 라이브러리 <code>myLib</code>를 정의합니다. <a href=\"#preventing-name-conflicts\">“이름 충돌 방지” 각주</a>를 반드시 읽어보세요.</p> <h2 id=\"umd\" style=\"position:relative;\"><em>UMD</em></h2> <p><em>UMD</em> 모듈은 모듈로 (import를 통해) 사용할 수 있고 혹은 전역으로도 (모듈 로더 없는 환경에서 실행될 때) 사용할 수 있습니다. <a href=\"http://momentjs.com/\">Moment.js</a> 같은 많은 유명한 라이브러리들은 이 방법으로 작성되었습니다. 예를 들어, Node.js나 RequireJS를 사용하면, 다음과 같이 작성합니다:</p> <pre data-language=\"ts\">import moment = require(\"moment\");\nconsole.log(moment.format());</pre> <p>반면 바닐라 브라우저 환경에서는 다음과 같이 쓸 수 있습니다:</p> <pre data-language=\"js\">console.log(moment.format());</pre> <h3 id=\"umd-라이브러리-식별하기-identifying-a-umd-library\" style=\"position:relative;\">UMD 라이브러리 식별하기 (Identifying a UMD library)</h3> <p><a href=\"https://github.com/umdjs/umd\">UMD modules</a>은 모듈 로더 환경 유무를 검사합니다. 이는 다음과 같이 보이는 찾기 쉬운 패턴입니다:</p> <pre data-language=\"js\">(function (root, factory) {\n    if (typeof define === \"function\" &amp;&amp; define.amd) {\n        define([\"libName\"], factory);\n    } else if (typeof module === \"object\" &amp;&amp; module.exports) {\n        module.exports = factory(require(\"libName\"));\n    } else {\n        root.returnExports = factory(root.libName);\n    }\n}(this, function (b) {</pre> <p>만약 라이브러리 코드, 특히 파일 상단에서 <code>typeof define</code>, <code>typeof window</code> 혹은 <code>typeof module</code>에 대한 테스트를 보았다면, 거의 대부분 UMD 라이브러리입니다.</p> <p>UMD 라이브러리 문서에서는 <code>require</code>를 보여주는 “Node.js에서 사용하기” 예제를 종종 설명하고 “브라우저에서 사용하기” 예제에서는 <code>&lt;script&gt;</code> 태그를 사용해서 스크립트를 로드하는 방법을 보여줍니다.</p> <h3 id=\"umd-라이브러리-예제-examples-of-umd-libraries\" style=\"position:relative;\">UMD 라이브러리 예제 (Examples of UMD libraries)</h3> <p>유명한 라이브러리 대부분은 UMD 패키지로 사용할 수 있습니다. 예로는 <a href=\"https://jquery.com/\">jQuery</a>, <a href=\"http://momentjs.com/\">Moment.js</a>, <a href=\"https://loadash.com/\">loadash</a> 등 더 많이 있습니다.</p> <h3 id=\"템플릿-template\" style=\"position:relative;\">템플릿 (Template)</h3> <p><a href=\"https://www.typescriptlang.org/docs/handbook/declaration-files/templates/module-plugin-d-ts.html\"><code>module-plugin.d.ts</code></a> 템플릿을 사용하세요.</p> <h1 id=\"span-idconsuming-dependencies--의존성-사용하기-consuming-dependencies\" style=\"position:relative;\">\n 의존성 사용하기 (Consuming Dependencies)</h1> <p>라이브러리가 몇 가지 의존성을 가지고 있을 수 있습니다. 이번 섹션에서는 선언 파일 안에 의존성을 import 하는 방법을 설명합니다.</p> <h2 id=\"전역-라이브러리-의존성-dependencies-on-global-libraries\" style=\"position:relative;\">전역 라이브러리 의존성 (Dependencies on Global Libraries)</h2> <p>만약 라이브러리가 전역 라이브러리에 의존성이 있다면, <code>/// &lt;reference types=\"...\" /&gt;</code> 디렉티브를 사용하세요:</p> <pre data-language=\"ts\">/// &lt;reference types=\"someLib\" /&gt;\n\nfunction getThing(): someLib.thing;</pre> <h2 id=\"모듈-의존성-dependencies-on-modules\" style=\"position:relative;\">모듈 의존성 (Dependencies on Modules)</h2> <p>만약 라이브러리가 모듈에 의존성이 있다면, <code>import</code>문을 사용하세요:</p> <pre data-language=\"ts\">import * as moment from \"moment\";\n\nfunction getThing(): moment;</pre> <h2 id=\"umd-라이브러리-의존성-dependencies-on-umd-libraries\" style=\"position:relative;\">UMD 라이브러리 의존성 (Dependencies on UMD libraries)</h2> <h3 id=\"전역-라이브러리에서-from-a-global-library\" style=\"position:relative;\">전역 라이브러리에서 (From a Global Library)</h3> <p>만약 전역 라이브러리가 UMD 모듈에 의존성이 있다면, <code>/// &lt;reference types</code> 디렉티브를 사용하세요:</p> <pre data-language=\"ts\">/// &lt;reference types=\"moment\" /&gt;\n\nfunction getThing(): moment;</pre> <h3 id=\"모듈이나-umd-라이브러리에서-from-a-module-or-umd-library\" style=\"position:relative;\">모듈이나 UMD 라이브러리에서 (From a Module or UMD Library)</h3> <p>만약 모듈이나 UMD 라이브러리가 UMD 라이브러리에 의존성이 있다면, <code>import</code>문을 사용하세요:</p> <pre data-language=\"ts\">import * as someLib from 'someLib';</pre> <p>UMD 라이브러리에 대한 의존성 선언에 <code>/// &lt;reference</code> 디렉티브를 사용하지 <em>마세요</em>!</p> <h1 id=\"각주-footnotes\" style=\"position:relative;\">각주 (Footnotes)</h1> <h2 id=\"span-idpreventing-name-conflicts--이름-충돌-방지하기-preventing-name-conflicts\" style=\"position:relative;\">\n 이름 충돌 방지하기 (Preventing Name Conflicts)</h2> <p>전역 선언 파일을 작성할 때, 전역 스코프에 많은 타입을 정의할 수 있다는 점을 유의하세요. 많은 선언 파일이 프로젝트 내에 있을 때, 해결할 수 없는 이름 충돌이 발생할 수 있으므로 이를 사용하지 않는 것이 좋습니다.</p> <p>따라야 하는 간단한 규칙은 라이브러리가 정의한 전역 변수가 무엇이든 타입을 <em>네임스페이스</em>로 정의하는 것입니다. 예를 들어, 만약 라이브러리가 전역 값 ‘cats’를 정의하면, 다음과 같이 작성하고</p> <pre data-language=\"ts\">declare namespace cats {\n    interface KittySettings { }\n}</pre> <p>이렇게 하지는 <em>마세요</em></p> <pre data-language=\"ts\">// 최상위-레벨에서\ninterface CatsKittySettings { }</pre> <p>이 가이드는 선언 파일 사용자가 중단하지 않고 라이브러리를 UMD로 전환할 수 있도록 합니다.</p> <h2 id=\"span-idthe-impact-of-es6-on-module-plugins--es6가-모듈-플러그인에-미치는-영향-the-impact-of-es6-on-module-plugins\" style=\"position:relative;\">\n ES6가 모듈 플러그인에 미치는 영향 (The Impact of ES6 on Module Plugins)</h2> <p>어떤 플러그인은 기존 모듈에 최상위 export를 추가하거나 수정합니다. CommonJS와 다른 로더에서는 허용되지만, ES6 모듈은 불변하다고 간주되기에 이 패턴은 불가능합니다. 왜냐하면 TypeScript는 로더에 구애받지 않기에, 이 정책이 컴파일-시간에 적용되지 않지만, ES6 모듈 로더로 전환하려는 개발자는 알고 있어야 합니다.</p> <h2 id=\"모듈-호출-시그니처에-es6가-미치는-영향-the-impact-of-es6-on-module-call-signatures\" style=\"position:relative;\">모듈 호출 시그니처에 ES6가 미치는 영향 (The Impact of ES6 on Module Call Signatures)</h2> <p>Express와 같은 많은 유명한 라이브러리들은 import 될 때 호출 가능한 함수를 노출합니다. 예를 들어, 일반적인 Express 사용법은 다음과 같습니다:</p> <pre data-language=\"ts\">import exp = require(\"express\");\nvar app = exp();</pre> <p>ES6 모듈 로더에서, 최상위-레벨 객체(여기에서는 <code>exp</code>로 import)는 프로퍼티만 가질 수 있습니다; 최상위-레벨 모듈 객체는 <em>절대</em> 호출할 수 없습니다. 가장 일반적인 해결책은 호출 가능/생성 가능 객체를 <code>default</code> export로 정의하는 것입니다; 어떤 모듈 로더 shims은 자동으로 이 상황을 감지하고 최상위-레벨 객체를 <code>default</code> export로 바꿉니다. 만약 <code>tsconfig.json</code> 파일에 <a href=\"https://www.typescriptlang.org/tsconfig/#esModuleInterop\"><code>\"esModuleInterop\": true</code></a> 라고 되어 있으면, Typescript가 위의 사항을 자동으로 처리합니다.</p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2012-2023 Microsoft<br>Licensed under the Apache License, Version 2.0.<br>\n    <a href=\"https://www.typescriptlang.org/ko/docs/handbook/declaration-files/library-structures.html\" class=\"_attribution-link\">https://www.typescriptlang.org/ko/docs/handbook/declaration-files/library-structures.html</a>\n  </p>\n</div>\n","2/mapped-types":"<h1>Mapped Types</h1>\n<p>중복을 피하기 위해서 다른 타입을 바탕으로 새로운 타입을 생성할 수 있습니다.</p> <p>매핑된 타입은 이전에 선언하지 않았던 프로퍼티의 타입을 선언할 수 있는 인덱스 시그니처 문법로 구성됩니다.</p> <pre data-language=\"ts\">type OnlyBoolsAndHorses = {\n  [key: string]: boolean | Horse;\n};\n \nconst conforms: OnlyBoolsAndHorses = {\n  del: true,\n  rodney: false,\n};</pre> <p>매핑된 타입은 <code>PropertyKey</code>(<a href=\"https://www.typescriptlang.org/docs/handbook/2/indexed-access-types.html\"><code>keyof</code>을 통해서</a> 자주 생성되는)의 조합을 사용하여 키를 통해 타입을 반복적으로 생성하는 제너릭 타입입니다.</p> <pre data-language=\"ts\">type OptionsFlags&lt;Type&gt; = {\n  [Property in keyof Type]: boolean;\n};</pre> <p>다음 예제에서, <code>OptionsFlags</code>는 <code>Type</code> 타입의 모든 프로퍼티를 가져와서 해당 값을 불린으로 변경합니다.</p> <pre data-language=\"ts\">type FeatureFlags = {\n  darkMode: () =&gt; void;\n  newUserProfile: () =&gt; void;\n};\n \ntype FeatureOptions = OptionsFlags&lt;FeatureFlags&gt;;</pre> <h3 id=\"mapping-modifiers\" style=\"position:relative;\">Mapping Modifiers</h3> <p>매핑중에는 추가할 수 있는 수정자로 <code>readonly</code>와 <code>?</code> 있습니다. 각각 가변성과 선택성에 영향을 미칩니다.</p> <p><code>-</code> 또는 <code>+</code>를 접두사로 붙여서 이런 수정자를 추가하거나 제거할 수 있습니다. 접두사를 추가하지 않으면 <code>+</code>로 간주합니다.</p> <pre data-language=\"ts\">// 타입의 프로퍼티에서 'readonly' 속성을 제거합니다\ntype CreateMutable&lt;Type&gt; = {\n  -readonly [Property in keyof Type]: Type[Property];\n};\n \ntype LockedAccount = {\n  readonly id: string;\n  readonly name: string;\n};\n \ntype UnlockedAccount = CreateMutable&lt;LockedAccount&gt;;</pre> <pre data-language=\"ts\">// 타입의 프로퍼티에서 'optional' 속성을 제거합니다\ntype Concrete&lt;Type&gt; = {\n  [Property in keyof Type]-?: Type[Property];\n};\n \ntype MaybeUser = {\n  id: string;\n  name?: string;\n  age?: number;\n};\n \ntype User = Concrete&lt;MaybeUser&gt;;</pre> <h2 id=\"key-remapping-via-as\" style=\"position:relative;\">Key Remapping via <code>as</code>\n</h2> <p>TypeScript 4.1 이상에서는 매핑된 타입에 <code>as</code> 절을 사용해서 매핑된 타입의 키를 다시 매핑할 수 있습니다.</p> <pre data-language=\"ts\">type MappedTypeWithNewProperties&lt;Type&gt; = {\n    [Properties in keyof Type as NewKeyType]: Type[Properties]\n}</pre> <p><a href=\"https://www.typescriptlang.org/docs/handbook/2/template-literal-types.html\">템플릿 리터럴 타입</a>과 같은 기능을 활용해서 이전 프로퍼티에서 새로운 프로퍼티 이름을 만들 수 있습니다.</p> <pre data-language=\"ts\">type Getters&lt;Type&gt; = {\n    [Property in keyof Type as `get${Capitalize&lt;string &amp; Property&gt;}`]: () =&gt; Type[Property]\n};\n \ninterface Person {\n    name: string;\n    age: number;\n    location: string;\n}\n \ntype LazyPerson = Getters&lt;Person&gt;;</pre> <p>조건부 타입을 통해 <code>never</code>를 생성해서 키를 필터링할 수 있습니다.</p> <pre data-language=\"ts\">// 'kind' 프로퍼티를 제거합니다\ntype RemoveKindField&lt;Type&gt; = {\n    [Property in keyof Type as Exclude&lt;Property, \"kind\"&gt;]: Type[Property]\n};\n \ninterface Circle {\n    kind: \"circle\";\n    radius: number;\n}\n \ntype KindlessCircle = RemoveKindField&lt;Circle&gt;;</pre> <p><code>string | number | symbol</code> 의 조합뿐만 아니라 모든 타입의 조합을 임의로 매핑할 수 있습니다.</p> <pre data-language=\"ts\">type EventConfig&lt;Events extends { kind: string }&gt; = {\n    [E in Events as E[\"kind\"]]: (event: E) =&gt; void;\n}\n \ntype SquareEvent = { kind: \"square\", x: number, y: number };\ntype CircleEvent = { kind: \"circle\", radius: number };\n \ntype Config = EventConfig&lt;SquareEvent | CircleEvent&gt;</pre> <h3 id=\"further-exploration\" style=\"position:relative;\">Further Exploration</h3> <p>매핑된 타입은 타입 조작 섹션의 다른 기능들과 잘 동작합니다. 예를 들어 객체의 <code>pii</code> 프로퍼티가 <code>true</code>로 설정되어 있는지에 따라 <code>true</code> 혹은 <code>false</code>를 반환하는 <a href=\"https://www.typescriptlang.org/docs/handbook/2/conditional-types.html\">조건부 타입을 사용한 매핑된 타입</a>이 있습니다.</p> <pre data-language=\"ts\">type ExtractPII&lt;Type&gt; = {\n  [Property in keyof Type]: Type[Property] extends { pii: true } ? true : false;\n};\n \ntype DBFields = {\n  id: { format: \"incrementing\" };\n  name: { type: string; pii: true };\n};\n \ntype ObjectsNeedingGDPRDeletion = ExtractPII&lt;DBFields&gt;;</pre><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2012-2023 Microsoft<br>Licensed under the Apache License, Version 2.0.<br>\n    <a href=\"https://www.typescriptlang.org/ko/docs/handbook/2/mapped-types.html\" class=\"_attribution-link\">https://www.typescriptlang.org/ko/docs/handbook/2/mapped-types.html</a>\n  </p>\n</div>\n","2/basic-types":"<h1>The Basics</h1>\n<p>JavaScript의 모든 값은 저마다 다양한 동작들을 내장하고 있으며 이는 다양한 연산(Operation)을 실행하여 확인할 수 있습니다. 이는 다소 추상적으로 들릴 수 있는데, 간단한 예시로 <code>message</code>라는 이름의 변수에 대하여 실행할 수 있는 몇몇 연산들을 살펴보겠습니다.</p> <pre data-language=\"js\">// 'message'의 프로퍼티 'toLowerCase'에 접근한 뒤\n// 이를 호출합니다\nmessage.toLowerCase();\n\n// 'message'를 호출합니다\nmessage();</pre> <p>위 코드를 분석해보면, 우선 첫 번째 실행 코드 줄에서는 <code>toLowerCase</code>라는 프로퍼티에 접근한 뒤 이를 호출합니다. 두 번째 줄에서는 <code>message</code>를 직접 호출하려 하고 있습니다.</p> <p>하지만 <code>message</code>의 값이 무엇인지 모른다면 - 일반적으로 그렇습니다 - 위 코드의 실행 결과가 무엇인지 확실히 말할 수 없습니다. 각 연산의 동작은 최초에 어떤 값을 가졌는지에 따라 완전히 달라집니다.</p> <ul> <li>\n<code>message</code>가 호출 가능한가?</li> <li>\n<code>toLowerCase</code>라는 프로퍼티를 가지는가?</li> <li>만약 가진다면, <code>toLowerCase</code> 또한 호출 가능한가?</li> <li>만약 두 값이 모두 호출 가능하다면, 각각이 무엇을 반환하는가?</li> </ul> <p>이 질문들은 우리가 JavaScript로 코드를 작성할 때 흔히 고민하게 되는 것들이며, 우리는 이와 관련된 세세한 부분들을 전부 놓치지 않고 있기를 늘 바라게 됩니다.</p> <p><code>message</code>가 아래와 같이 정의되었다고 해봅시다.</p> <pre data-language=\"js\">const message = \"Hello World!\";</pre> <p>익히 짐작하셨겠지만 여기서 <code>message.toLowerCase()</code>를 실행하면, 우리는 동일한 문자열이 소문자로만 이루어져 있는 값을 얻을 것입니다.</p> <p>그렇다면 앞서 본 코드의 두 번째 라인은 어떨까요? JavaScript가 익숙하시다면, 예외와 함께 실행이 되지 않을 것을 아실 겁니다.</p> <pre data-language=\"txt\">TypeError: message is not a function</pre> <p>이와 같은 실수를 미리 방지할 수 있다면 참 좋을 것 같습니다.</p> <p>JavaScript 런타임은 코드가 실행될 때 자신이 무엇을 해야 할지 결정하기 위하여 값의 <em>타입</em>, 즉 해당 값이 어떤 동작과 능력을 가지고 있는지를 확인합니다. 이것이 바로 <code>TypeError</code>가 암시하는 바입니다. 위 예시에서는 문자열인 <code>\"Hello World\"</code>가 함수로서 호출될 수 없다고 말하고 있는 것이죠.</p> <p>일부 값들, 이를테면 <code>string</code>과 <code>number</code>과 같은 원시 타입의 값의 경우 <code>typeof</code> 연산자를 사용하면 각 값들의 타입을 실행 시점에 알 수 있습니다. 하지만 그 밖의 값들, 이를테면 함수값의 경우, 앞서 언급된 방식과 같이 해당 값의 타입을 실행 시점의 메커니즘은 존재하지 않습니다. 예를 들어, 아래와 같은 함수를 살펴보겠습니다.</p> <pre data-language=\"js\">function fn(x) {\n  return x.flip();\n}</pre> <p>위 코드를 보면, 인자로 전달된 객체가 호출 가능한 프로퍼티인 <code>flip</code>을 가져야만 위 함수가 잘 작동할 것이라는 것을 우리는 코드를 읽음으로써 <em>알 수 있습니다.</em> 하지만 JavaScript는 우리가 알고 있는 이러한 정보를 코드가 실행되는 동안 알지 못합니다. 순수 JavaScript에서 <code>fn</code>가 특정 값과 어떤 동작을 수행하는지 알 수 있는 유일한 방법은 호출하고 무슨 일이 벌어지는지 보는 것입니다. 이와 같은 동작은 코드 실행 전에 예측을 어렵게 만듭니다. 다시 말해 코드가 어떤 동작 결과를 보일지 코드를 작성하는 동안에는 알기 어렵습니다.</p> <p>이런 측면에서 볼 때, <em>타입</em>이란 어떤 값이 <code>fn</code>으로 전달될 수 있고, 어떤 값은 실행에 실패할 것임을 설명하는 개념입니다. JavaScript는 오직 <em>동적</em> 타입만을 제공하며, 코드를 실행해야만 어떤 일이 벌어지는지 비로소 확인할 수 있습니다.</p> <p>이에 대한 대안은 <em>정적</em> 타입 시스템을 사용하여 코드가 실행되기 <em>전에</em> 코드에 대하여 예측하는 것입니다.</p> <h2 id=\"정적-타입-검사\" style=\"position:relative;\">정적 타입 검사</h2> <p>앞서 살펴본, <code>string</code>을 함수로서 호출하고자 했을 때 얻은 <code>TypeError</code>의 이야기로 돌아가 봅시다. <em>대부분의 사람들은</em> 코드를 실행했을 때 오류를 보고 싶지 않습니다. 그것은 버그로 여겨집니다! 그리고 새로운 코드를 작성할 때 우리는 새로운 버그를 만들어내지 않도록 최선을 다합니다.</p> <p>여기서 만약 약간의 코드를 추가하고 파일을 저장한 뒤, 코드를 다시 실행했을 때 바로 오류가 확인된다면, 문제를 신속하게 격리시킬 수 있을 것입니다. 하지만 항상 그렇게 되는 것은 아닙니다. 기능을 충분히 테스트하지 않아서, 잠재적인 오류를 미처 발견하지 못할 수도 있습니다! 또는 운 좋게 오류를 발견했더라도, 결국 상당한 규모의 리팩토링을 거치고 새 코드를 추가하면서 의도치 않게 코드를 깊게 파헤치게 될 수도 있습니다.</p> <p>이상적으로는, 코드를 실행하기 <em>전에</em> 이러한 버그를 미리 발견할 수 있는 도구가 있다면 좋을 것입니다. TypeScript와 같은 정적 타입 검사기의 역할이 바로 그것입니다. <em>정적 타입 시스템</em>은 우리가 작성한 프로그램에서 사용된 값들의 형태와 동작을 설명합니다. TypeScript와 같은 타입 검사기는 이 정보를 활용하여 프로그램이 제대로 작동하지 않을 때 우리에게 알려줍니다.</p> <pre data-language=\"ts\">const message = \"hello!\";\n \nmessage();</pre> <p>위의 마지막 예시를 TypeScript로 실행하면, 코드가 실행되기에 앞서 우선 오류 메시지를 확인하게 됩니다.</p> <h2 id=\"예외가-아닌-실행-실패\" style=\"position:relative;\">예외가 아닌 실행 실패</h2> <p>지금까지 런타임 오류에 대하여 다루었습니다. 이는 JavaScript 런타임이 무언가 이상하다고 우리에게 직접 말해주는 경우에 해당합니다. 이러한 오류는 예기치 못한 문제가 발생했을 때 JavaScript가 어떻게 대응해야 하는지 <a href=\"https://tc39.github.io/ecma262/\">ECMAScript 명세</a>에서 명시적인 절차를 제공하기 때문에 발생하는 것입니다.</p> <p>예를 들어, 명세에 따르면 호출 가능하지 않은 것에 대하여 호출을 시도할 경우 오류가 발생합니다. 이는 “당연한 동작”처럼 들릴 수 있겠으나, 누군가는 객체에 존재하지 않는 프로퍼티에 접근을 시도했을 때에도 역시 오류를 던져야 한다고 생각할 수 있습니다. 하지만 그 대신 JavaScript는 전혀 다르게 반응하며 <code>undefined</code>를 반환합니다.</p> <pre data-language=\"js\">const user = {\n  name: \"Daniel\",\n  age: 26,\n};\n\nuser.location; // undefined 를 반환</pre> <p>궁극적으로, 정적 타입 시스템은 어떤 코드가 오류를 발생시키지 않는 “유효한” JavaScript 코드일지라도, 정적 타입 시스템 내에서 오류로 간주되는 경우라면 이를 알려주어야 합니다. TypeScript에서는, 아래의 코드는 <code>location</code>이 정의되지 않았다는 오류를 발생시킵니다.</p> <pre data-language=\"ts\">const user = {\n  name: \"Daniel\",\n  age: 26,\n};\n \nuser.location;</pre> <p>비록 때로는 이로 인하여 표현의 유연성을 희생해야 하겠지만, 이렇게 함으로서 명시적인 버그는 아니지만 버그로 타당히 간주되는 경우를 잡아내는 데에 그 목적이 있습니다. 그리고 TypeScript는 이러한 겉으로 드러나지 않는 버그를 <em>꽤 많이</em> 잡아냅니다.</p> <p>예를 들어, 오타,</p> <pre data-language=\"ts\">const announcement = \"Hello World!\";\n \n// 바로 보자마자 오타인지 아실 수 있나요?\nannouncement.toLocaleLowercase();\nannouncement.toLocalLowerCase();\n \n// 아마 아래와 같이 적으려 했던 것이겠죠...\nannouncement.toLocaleLowerCase();</pre> <p>호출되지 않은 함수,</p> <pre data-language=\"ts\">function flipCoin() {\n  // 본래 의도는 Math.random()\n  return Math.random &lt; 0.5;\n}</pre> <p>또는 기본적인 논리 오류 등이 있습니다.</p> <pre data-language=\"ts\">const value = Math.random() &lt; 0.5 ? \"a\" : \"b\";\nif (value !== \"a\") {\n  // ...\n} else if (value === \"b\") {\n  // 이런, 이 블록은 실행되지 않겠군요\n}</pre> <h2 id=\"프로그래밍-도구로서의-타입\" style=\"position:relative;\">프로그래밍 도구로서의 타입</h2> <p>TypeScript는 우리가 코드 상에서 실수를 저질렀을 때 버그를 잡아줍니다. 그거 좋죠, 그런데 TypeScript는 <em>여기서 더 나아가서</em> 우리가 실수를 저지르는 바로 그 순간 이를 막아줍니다.</p> <p>타입 검사기는 우리가 변수 또는 다른 프로퍼티 상의 올바른 프로퍼티에 접근하고 있는지 여부를 검사할 수 있도록 관련 정보들을 가지고 있습니다. 이 정보를 활용하면 타입 검사기는 우리가 사용할 수 있는 프로퍼티를 <em>제안</em>할 수 있게 됩니다.</p> <p>즉, TypeScript는 코드 수정에 활용될 수 있고, 우리가 코드를 입력할 때 오류 메시지를 제공하거나 코드 완성 기능을 제공할 수 있습니다. 이는 TypeScript에서 도구(Tooling)를 논할 때에 흔히 언급되는 내용입니다.</p>  <pre data-language=\"ts\">import express from \"express\";\nconst app = express();\n \napp.get(\"/\", function (req, res) {\n  res.sen\n});\n \napp.listen(3000);</pre> <p>TypeScript는 프로그래밍 도구를 중요하게 생각하며, 여기에는 코드 완성 및 오류 메시지 기능 이외에도 다양한 것이 포함됩니다. TypeScript를 지원하는 코드 편집기는 오류를 자동으로 고쳐주는 “Quick Fixes”, 코드를 간편하게 재조직하는 리팩토링, 변수의 정의로 빠르게 이동하는 유용한 네비게이션, 주어진 변수에 대한 모든 참조 검색 등의 기능들을 제공합니다. 이 모든 기능들은 타입 검사기를 기반으로 하며 완전히 크로스 플랫폼으로 동작하므로, <a href=\"https://github.com/Microsoft/TypeScript/wiki/TypeScript-Editor-Support\">여러분이 주로 사용하는 코드 편집기가 TypeScript를 지원</a>할 확률이 높습니다.</p> <h2 id=\"tsc-typescript-컴파일러\" style=\"position:relative;\">\n<code>tsc</code>, TypeScript 컴파일러</h2> <p>지금까지 계속 타입 검사에 대하여 이야기했지만, 아직 타입 <em>검사기</em>를 사용하지 않았습니다. 우리의 새로운 친구 <code>tsc</code>, TypeScript 컴파일러와 첫인사를 나누도록 합시다. 우선, npm을 사용하여 설치하도록 하겠습니다.</p> <pre data-language=\"shell\">npm install -g typescript</pre> <blockquote> <p>위 코드를 실행하면 TypeScript 컴파일러 <code>tsc</code>가 전역 설치됩니다. <code>tsc</code>를 로컬 <code>node_modules</code> 패키지로부터 실행하고자 한다면 <code>npx</code> 또는 유사한 도구를 사용하면 됩니다.</p> </blockquote> <p>이제 빈 폴더로 이동하여 첫번째 TypeScript 프로그램인 <code>hello.ts</code>를 작성해보도록 하겠습니다.</p> <pre data-language=\"ts\">// 세상을 맞이하세요.\nconsole.log(\"Hello world!\");</pre> <p>코드 상에 아무런 밑줄도 그어지지 않았음에 유의하세요. 이 “hello world” 프로그램은 JavaScript로 작성하는 “hello world” 프로그램과 동일한 모습을 가집니다. 그리고 이제 <code>typescript</code> 패키지와 함께 설치된 <code>tsc</code> 명령어를 실행하여 타입 검사를 수행합니다.</p> <pre data-language=\"shell\">tsc hello.ts</pre> <p>짜잔!</p> <p>잠깐, 정확히 <em>무엇</em>이 “짜잔”하고 나왔다는 것이죠? <code>tsc</code>를 실행했지만 아무 일도 일어나지 않았습니다! 뭐, 타입 오류가 없었으니, 아무것도 보고될 것이 없고 그래서 콘솔에도 아무런 출력이 나타나지 않았습니다.</p> <p>하지만 다시 확인해보면, 우리는 그 대신 <em>파일</em> 출력을 얻었습니다. 현재 디렉토리를 보면, <code>hello.ts</code> 파일 옆에 <code>hello.js</code> 파일이 있는 것을 볼 수 있습니다. 이것이 <code>tsc</code>가 우리의 <code>hello.ts</code> 파일을 JavaScript 파일로 <em>컴파일</em> 또는 <em>변형</em>한 결과물입니다. 그리고 그 내용을 확인해보면, TypeScript가 <code>.ts</code> 파일을 처리한 뒤 뱉어낸 내용을 확인할 수 있습니다.</p> <pre data-language=\"js\">// 세상을 맞이하세요.\nconsole.log(\"Hello world!\");</pre> <p>위 경우, TypeScript가 변형해야 할 내용은 극히 적었고, 따라서 우리가 처음에 작성한 것과 동일한 결과물이 나왔습니다. 컴파일러는 사람이 작성한 듯이 깔끔하고 읽을 수 있는 코드를 만들어내고자 시도합니다. 물론 그것이 항상 쉬운 것은 아니지만, TypeScript는 일관성 있게 들여 쓰기를 수행하고, 여러 줄에 걸쳐 코드가 작성되는 것을 감안하고, 코드 주변에 작성된 주석도 잘 배치해둡니다.</p> <p>만약 타입 검사 오류가 <em>주어지면</em> 어떨까요? <code>hello.ts</code>를 다시 작성해보겠습니다.</p> <pre data-language=\"ts\">// 아래는 실무 수준에서 범용적으로 쓰이는 환영 함수입니다\nfunction greet(person, date) {\n  console.log(`Hello ${person}, today is ${date}!`);\n}\n \ngreet(\"Brendan\");</pre> <p>여기서 <code>tsc hello.ts</code>를 다시 실행하면, 커맨드 라인 상에서 오류를 얻게 된다는 점에 유의하세요!</p> <pre data-language=\"txt\">Expected 2 arguments, but got 1.</pre> <p>TypeScript는 <code>greet</code> 함수에 인자를 전달하는 것을 깜빡했다고 말해주고 있으며, 실제로 그렇습니다. 지금까지 우리는 오직 표준적인 JavaScript만을 작성했을 뿐인데, 여전히 타입 검사를 통하여 코드 상의 문제를 발견해낼 수 있었습니다. 고마워, TypeScript!</p> <h3 id=\"오류-발생시키기\" style=\"position:relative;\">오류 발생시키기</h3> <p>앞서 살펴 본 예시에서 눈치 채셨는지 모르겠지만, <code>hello.js</code> 파일의 내용이 또 한 번 수정되었습니다. 파일을 열어보면, 입력으로 사용된 코드 파일과 실질적으로 동일하다는 것을 알 수 있습니다. 우리 코드를 보고 <code>tsc</code>가 오류를 발생시켰다는 점을 감안하면 다소 놀랍게 느껴질 수도 있지만, 이는 TypeScript의 핵심 가치 중 하나에 기반한 동작입니다. 그것은 바로, 대부분의 경우 <em>당신이</em> TypeScript보다 더 잘 알고 있을 것이라는 생각입니다.</p> <p>앞에서도 말씀드렸듯이 코드에 대한 타입 검사는 프로그램이 실행할 수 있는 동작을 제한합니다. 따라서 타입 검사가 허용 또는 제한하는 동작의 범위에는 어느 정도 절충과 타협이 존재합니다. 대부분의 경우 문제가 발생하지 않지만, 타입 검사가 방해가 되는 시나리오 또한 존재합니다. 예를 들어, JavaScript로 작성된 코드를 TypeScript로 마이그레이션하는 과정에서 타입 검사 오류가 발생하는 경우를 떠올려보세요. 결국에는 타입 검사를 통과하도록 코드를 수정해나가겠지만, 사실 원본 JavaScript 코드는 이미 제대로 잘 작동하고 있는 상태였습니다! TypeScript로 변환하는 작업 때문에 코드 실행이 중단되어야 할 이유가 있을까요?</p> <p>그래서 TypeScript는 당신을 방해하지 않습니다. 물론, 시간이 흐름에 따라 좀 더 실수에 방어적으로 대응하고, TypeScript가 보다 엄격하게 동작하기를 원할 수도 있습니다. 이 경우 <code>--noEmitOnError</code> 컴파일러 옵션을 사용하면 됩니다. <code>hello.ts</code> 파일을 수정한 뒤 위 플래그 옵션을 사용하여 <code>tsc</code>를 실행해보세요.</p> <pre data-language=\"shell\">tsc --noEmitOnError hello.ts</pre> <p><code>hello.js</code>가 하나도 수정되지 않는다는 것을 확인할 수 있습니다.</p> <h2 id=\"명시적-타입\" style=\"position:relative;\">명시적 타입</h2> <p>지금까지는 아직 TypeScript에게 <code>person</code> 또는 <code>date</code>가 무엇인지 알려주지 않았습니다. 코드를 수정하여 TypeScript가 <code>person</code>이 <code>string</code>이고 <code>date</code>가 <code>Date</code> 객체이어야 한다는 것을 알려주도록 하죠. 또한 <code>date</code>의 <code>toDateString()</code> 메서드를 사용하겠습니다.</p> <pre data-language=\"ts\">function greet(person: string, date: Date) {\n  console.log(`Hello ${person}, today is ${date.toDateString()}!`);\n}</pre> <p>방금 우리는 <code>person</code>과 <code>date</code>에 대하여 <em>타입 표기</em>를 수행하여 <code>greet</code>가 호출될 때 함께 사용될 수 있는 값들의 타입을 설명했습니다. 해당 시그니처는 ”<code>greet</code>는 <code>string</code> 타입의 <code>person</code>과 <code>Date</code> 타입의 <code>date</code>을 가진다”고 해석할 수 있습니다.</p> <p>이것이 있다면, TypeScript는 우리가 해당 함수를 올바르지 못하게 사용했을 경우 이를 알려줄 수 있게 됩니다. 예를 들어…</p> <pre data-language=\"ts\">function greet(person: string, date: Date) {\n  console.log(`Hello ${person}, today is ${date.toDateString()}!`);\n}\n \ngreet(\"Maddison\", Date());</pre> <p>어? TypeScript가 두번째 인자에 대하여 오류를 보고했는데요, 왜 그랬을까요?</p> <p>아마도 놀랍게도, JavaScript에서 <code>Date()</code>를 호출하면 <code>string</code>을 반환합니다. 반면, <code>new Date()</code>를 사용하여 <code>Date</code> 타입을 생성해야 비로소 처음 기대했던 결과를 반환받을 수 있게 됩니다.</p> <p>어쨌든, 이 오류는 아주 빠르게 고칠 수 있습니다.</p> <pre data-language=\"ts\">function greet(person: string, date: Date) {\n  console.log(`Hello ${person}, today is ${date.toDateString()}!`);\n}\n \ngreet(\"Maddison\", new Date());</pre> <p>명시적인 타입 표기를 항상 작성할 필요는 없다는 것을 꼭 기억해두세요. 많은 경우, TypeScript는 생략된 타입 정보를 <em>추론할 수</em> (또는 “알아낼 수”) 있습니다.</p> <pre data-language=\"ts\">let msg = \"hello there!\";</pre> <p><code>msg</code>가 <code>string</code> 타입을 가진다는 사실을 TypeScript에게 알려주지 않았더라도 TypeScript는 이를 알아낼 수 있습니다. 이는 기본 기능이며, 타입 시스템이 알아서 올바른 타입을 어떻게든 잘 알아낼 수 있다면 타입 표기를 굳이 적지 않는 것이 가장 좋습니다.</p> <blockquote> <p>참고: 바로 위 코드의 말풍선은 에디터에서 해당 코드를 작성했을 때, 해당 변수에 마우스 호버시 화면에 나타나는 내용입니다.</p> </blockquote> <h2 id=\"지워진-타입\" style=\"position:relative;\">지워진 타입</h2> <p>앞서 작성한 함수 <code>greet</code>을 <code>tsc</code>로 컴파일하여 JavaScript 출력을 얻었을 때 어떤 일이 일어나는지 보도록 하겠습니다.</p> <pre data-language=\"ts\">\"use strict\";\nfunction greet(person, date) {\n    console.log(\"Hello \".concat(person, \", today is \").concat(date.toDateString(), \"!\"));\n}\ngreet(\"Maddison\", new Date());\n </pre> <p>여기서 두 가지를 알 수 있습니다.</p> <ol> <li>\n<code>person</code>과 <code>date</code> 인자는 더 이상 타입 표기를 가지지 않습니다.</li> <li>“템플릿 문자열” - 백틱(<code>`</code> 문자)을 사용하여 작성된 문장 - 은 연결 연산자(<code>+</code>)로 이루어진 일반 문자열로 변환되었습니다.</li> </ol> <p>두번째 항목에 대하여서는 이후 자세히 다루도록 하고 우선 첫번째 항목에 초점을 두도록 하겠습니다. 타입 표기는 JavaScript(또는 엄밀히 말하여 ECMAScript)의 일부가 아니므로, TypeScript를 수정 없이 그대로 실행할 수 있는 브라우저나 런타임은 현재 존재하지 않습니다. 이것이 TypeScript를 사용하고자 할 때 다른 무엇보다도 컴파일러가 필요한 이유입니다. TypeScript 전용 코드를 제거하거나 변환하여 실행할 수 있도록 만들 방법이 필요합니다. 대부분의 TypeScript 전용 코드는 제거되며, 마찬가지로 타입 표기 또한 완전히 지워집니다.</p> <blockquote> <p><strong>기억하세요</strong>: 타입 표기는 프로그램의 런타임 동작을 전혀 수정하지 않습니다.</p> </blockquote> <h2 id=\"다운레벨링\" style=\"position:relative;\">다운레벨링</h2> <p>앞서 언급된 또 다른 차이점은, 바로 템플릿 문자열이 아래의 내용에서,</p> <pre data-language=\"js\">`Hello ${person}, today is ${date.toDateString()}!`;</pre> <p>아래의 내용으로 다시 작성되었다는 점입니다.</p> <pre data-language=\"js\">\"Hello \" + person + \", today is \" + date.toDateString() + \"!\";</pre> <p>왜 이러한 일이 생겼을까요?</p> <p>템플릿 문자열은 ECMAScript 2015(a.k.a. ECMAScript 6, ES2015, ES6, 등. <em>더 묻지 마세요</em>)라고 불리는 버전의 ECMAScript에서 등장한 기능입니다. TypeScript는 새 버전의 ECMAScript의 코드를 ECMAScript 3 또는 ECMAScript 5와 같은 보다 예전 버전의 것들로 다시 작성해 줍니다. 새로운 또는 “상위” 버전의 ECMAScript를 예전의 또는 “하위” 버전의 것으로 바꾸는 과정을 <em>다운레벨링</em>이라 부르기도 합니다.</p> <p>TypeScript는 ES3라는 아주 구버전의 ECMAScript를 타겟으로 동작하는 것이 기본 동작입니다. <code>--target</code> 플래그를 설정하면 보다 최근 버전을 타겟으로 변환을 수행할 수도 있습니다. <code>--target es2015</code>를 실행하면 TypeScript가 ECMAScript 2015를 타겟으로 동작할 수 있으며, 이는 ECMAScript 2015가 지원되는 런타임이기만 하면 해당 코드가 실행될 수 있도록 변환된다는 의미입니다. 따라서 <code>tsc --target es2015 input.ts</code>를 실행하면 아래와 같은 출력을 얻게 됩니다.</p> <pre data-language=\"js\">function greet(person, date) {\n  console.log(`Hello ${person}, today is ${date.toDateString()}!`);\n}\ngreet(\"Maddison\", new Date());</pre> <blockquote> <p>타겟 버전의 기본값은 ES3이지만, 현존하는 대다수의 브라우저들은 ES2015를 지원하고 있습니다. 따라서 특정 구버전 브라우저에 대한 호환성 유지가 주요 이슈가 아니라면, 대부분의 경우 안심하고 ES2015 또는 그 이상을 컴파일러 타겟으로 지정할 수 있습니다.</p> </blockquote> <h2 id=\"엄격도\" style=\"position:relative;\">엄격도</h2> <p>TypeScript의 타입 검사기를 사용하는 목적은 사용자마다 다양합니다. 누군가는 프로그램 일부만 타입 검사를 수행하는 느슨한 수준을 유지하면서도, 유용한 프로그래밍 도구로서의 기능은 온전히 활용하고 싶을 수 있습니다. 이는 TypeScript를 사용할 때 기본으로 제공하고자 하는 경험입니다. 타입 검사는 선택 사항이며, 타입 추론은 가장 관대한 기준으로 이루어지고, 잠재적인 <code>null</code>/<code>undefined</code> 값에 대한 검사는 이루어지지 않습니다. 이러한 기본 경험은 개발 경험을 방해하지 않는 방향으로 이루어집니다. 앞서 언급하였던, 오류 발생 시 <code>tsc</code>가 오류를 처리하는 방식과 유사합니다. 기존의 JavaScript에서 마이그레이션을 하는 입장이라면, 이는 첫발을 디디기 위한 적당한 수준이라고 볼 수 있습니다.</p> <p>이와 반대로, 대다수의 사용자들은 TypeScript가 최대한으로 타입 검사를 수행해주기를 선호합니다. 이것이 TypeScript에서 엄격도 설정을 제공하는 이유이기도 합니다. 이러한 엄격도 설정을 활용하면 정적 타입 검사기를 마치 (코드 검사가 이루어졌는지 여부만을 단순히 따지는) 스위치 수준의 장치에서 마치 다이얼에 가까운 장치로 만들 수 있습니다. 다이얼을 더 멀리 돌릴수록, TypeScript는 더 많은 것을 검사해줄 겁니다. 그러면 할 일이 조금 더 생기겠지만, 길게 봤을 때 분명 그만한 가치가 있으며, 보다 철저한 검사와 정밀한 도구 기능을 사용할 수 있게 됩니다. 가능하다면, 새로 작성하는 코드에서는 항상 엄격도를 활성화해야 합니다.</p> <p>TypeScript에는 켜고 끌 수 있는 타입 검사 엄격도 플래그가 몇 가지 존재하며, 앞으로 사용되는 모든 예시 코드는 별도 설명이 없다면 모든 플래그를 활성화한 상태로 작성됩니다. CLI에서 <code>--strict</code> 플래그를 설정하거나 <a href=\"../tsconfig-json\"><code>tsconfig.json</code></a>에 <code>\"strict\": true</code>를 추가하면 모든 플래그를 동시에 활성화하게 되지만, 각각의 플래그를 개별적으로 끌 수도 있습니다. 반드시 알아야 하는 두 가지 가장 주요한 옵션은 <code>noImplicitAny</code>와 <code>strictNullChecks</code>입니다.</p> <h3 id=\"noimplicitany\" style=\"position:relative;\"><code>noImplicitAny</code></h3> <p>몇몇 경우에서 TypeScript는 값의 타입을 추론하지 않고 가장 관대한 타입인 <code>any</code>로 간주한다는 사실을 기억하시기 바랍니다. 이는 최악의 경우는 아닙니다. 어쨌든, 타입을 <code>any</code>로 간주하는 것은 일반적인 JavaScript에서는 당연한 일이기도 합니다.</p> <p>하지만, <code>any</code>를 사용하면 애초에 TypeScript를 사용하는 이유가 무색해지는 경우가 많습니다. 프로그램에서 타입을 더 구체적으로 사용할수록, 더 많은 유효성 검사와 도구 기능을 사용할 수 있으며, 이는 곧 코드 상에서 보다 적은 버그를 만나게 된다는 의미입니다. <code>noImplicitAny</code> 플래그를 활성화하면 타입이 <code>any</code>로 암묵적으로 추론되는 변수에 대하여 오류를 발생시킵니다.</p> <h3 id=\"strictnullchecks\" style=\"position:relative;\"><code>strictNullChecks</code></h3> <p><code>null</code>과 <code>undefined</code>와 같은 값은 다른 타입의 값에 할당할 수 있는 것이 기본 동작입니다. 이는 코드 작성을 쉽게 만들어주지만, <code>null</code>과 <code>undefined</code>의 처리를 잊는 것은 세상의 셀 수 없이 많은 버그들의 원인입니다. 혹자는 이를 <a href=\"https://www.youtube.com/watch?v=ybrQvs4x0Ps\">백만 불 짜리 실수</a>라고 일컫기도 합니다! <code>strictNullChecks</code> 플래그는 <code>null</code>과 <code>undefined</code>를 보다 명시적으로 처리하며, <code>null</code> 및 <code>undefined</code> 처리를 <em>잊었는지</em> 여부를 걱정하는 데에서 우리를 <em>해방시켜</em> 줍니다.</p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2012-2023 Microsoft<br>Licensed under the Apache License, Version 2.0.<br>\n    <a href=\"https://www.typescriptlang.org/ko/docs/handbook/2/basic-types.html\" class=\"_attribution-link\">https://www.typescriptlang.org/ko/docs/handbook/2/basic-types.html</a>\n  </p>\n</div>\n","decorators":"<h1>Decorators</h1>\n<h2 id=\"소개-introduction\" style=\"position:relative;\">소개 (Introduction)</h2> <blockquote class=\"bg-reading\"> <p>Further Reading:<br><a href=\"https://saul-mirone.github.io/a-complete-guide-to-typescript-decorator/\">A Complete Guide to TypeScript Decorators</a></p> </blockquote> <p>TypeScript 및 ES6에 클래스가 도입됨에 따라, 클래스 및 클래스 멤버에 어노테이션을 달거나 수정하기 위해 추가 기능이 필요한 특정 시나리오가 있습니다. 데코레이터는 클래스 선언과 멤버에 어노테이션과 메타-프로그래밍 구문을 추가할 수 있는 방법을 제공합니다. 데코레이터는 JavaScript에 대한 <a href=\"https://github.com/tc39/proposal-decorators\">2단계 제안</a>이며 TypeScript의 실험적 기능으로 이용 가능합니다.</p> <blockquote> <p>참고 데코레이터는 향후 릴리스에서 변경될 수 있는 실험적인 기능입니다.</p> </blockquote> <p>데코레이터에 대한 실험적 지원을 활성화하려면 명령줄 또는 <code>tsconfig.json</code>에서 <code>experimentDecorators</code> 컴파일러 옵션을 활성화해야합니다:</p> <p><strong>명령줄 (Command Line)</strong>:</p> <pre data-language=\"shell\">tsc --target ES5 --experimentalDecorators</pre> <p><strong>tsconfig.json</strong>:</p> <pre tsconfig=\"true\" data-language=\"typescript\">{\n  \"compilerOptions\": {\n    \"target\": \"ES5\",\n    \"experimentalDecorators\": true\n  }\n}</pre> <h1 id=\"데코레이터-decorators\" style=\"position:relative;\">데코레이터 (Decorators)</h1> <p><em>데코레이터</em>는 <a href=\"#%ED%81%B4%EB%9E%98%EC%8A%A4-%EB%8D%B0%EC%BD%94%EB%A0%88%EC%9D%B4%ED%84%B0-class-decorators\">클래스 선언</a>, <a href=\"#%EB%A9%94%EC%84%9C%EB%93%9C-%EB%8D%B0%EC%BD%94%EB%A0%88%EC%9D%B4%ED%84%B0-method-decorators\">메서드</a>, <a href=\"#%EC%A0%91%EA%B7%BC%EC%9E%90-%EB%8D%B0%EC%BD%94%EB%A0%88%EC%9D%B4%ED%84%B0-accessor-decorators\">접근자</a>, <a href=\"#%ED%94%84%EB%A1%9C%ED%8D%BC%ED%8B%B0-%EB%8D%B0%EC%BD%94%EB%A0%88%EC%9D%B4%ED%84%B0-property-decorators\">프로퍼티</a> 또는 <a href=\"#%EB%A7%A4%EA%B0%9C%EB%B3%80%EC%88%98-%EB%8D%B0%EC%BD%94%EB%A0%88%EC%9D%B4%ED%84%B0-parameter-decorators\">매개 변수</a>에 첨부할 수 있는 특수한 종류의 선언입니다. 데코레이터는 <code>@expression</code> 형식을 사용합니다. 여기서 <code>expression</code>은 데코레이팅 된 선언에 대한 정보와 함께 런타임에 호출되는 함수여야 합니다.</p> <p>예를 들어, 데코레이터 <code>@sealed</code>를 사용하면 다음과 같이 <code>sealed</code> 함수를 작성할 수 있습니다.</p> <pre data-language=\"ts\">function sealed(target) {\n    // 'target' 변수와 함께 무언가를 수행합니다.\n}</pre> <h2 id=\"데코레이터-팩토리-decorator-factories\" style=\"position:relative;\">데코레이터 팩토리 (Decorator Factories)</h2> <p>데코레이터가 선언에 적용되는 방식을 원하는 대로 바꾸고 싶다면 데코레이터 팩토리를 작성할 수 있습니다. <em>데코레이터 팩토리</em>는 단순히 데코레이터가 런타임에 호출할 표현식을 반환하는 함수입니다.</p> <p>다음과 같은 방식으로 데코레이터 팩토리를 작성할 수 있습니다.</p> <pre data-language=\"ts\">function color(value: string) { // 데코레이터 팩토리\n    return function (target) { // 데코레이터\n        // 'target'과 'value' 변수를 가지고 무언가를 수행합니다.\n  };\n}</pre> <h2 id=\"데코레이터-합성-decorator-composition\" style=\"position:relative;\">데코레이터 합성 (Decorator Composition)</h2> <p>다음 예제와 같이 선언에 여러 데코레이터를 적용할 수 있습니다.</p> <ul> <li>단일 행일 경우:</li> </ul> <pre data-language=\"ts\">@f @g x</pre> <ul> <li>여러 행일 경우:</li> </ul> <pre data-language=\"ts\">@f\n@g\nx</pre> <p>여러 데코레이터가 단일 선언에 적용되는 경우는 <a href=\"http://en.wikipedia.org/wiki/Function_composition\">수학의 합성 함수</a>와 유사합니다. 이 모델에서 함수 <em>f</em>와 <em>g</em>을 합성할 때 (<em>f</em>∘<em>g</em>)(<em>x</em>)의 합성 결과는 <em>f</em>(<em>g</em>(<em>x</em>))와 같습니다.</p> <p>따라서 TypeScript에서 단일 선언에서 여러 데코레이터를 사용할 때 다음 단계가 수행됩니다.</p> <ol> <li>각 데코레이터의 표현은 위에서 아래로 평가됩니다.</li> <li>그런 다음 결과는 아래에서 위로 함수로 호출됩니다.</li> </ol> <p><a href=\"#%EB%8D%B0%EC%BD%94%EB%A0%88%EC%9D%B4%ED%84%B0-%ED%8C%A9%ED%86%A0%EB%A6%AC-decorator-factories\">데코레이터 팩토리</a>를 사용하는 경우 다음 예제를 통해 이 수행 순서를 관찰 할 수 있습니다.</p>  <pre data-language=\"ts\">function first() {\n  console.log(\"first(): factory evaluated\");\n  return function (target: any, propertyKey: string, descriptor: PropertyDescriptor) {\n    console.log(\"first(): called\");\n  };\n}\n \nfunction second() {\n  console.log(\"second(): factory evaluated\");\n  return function (target: any, propertyKey: string, descriptor: PropertyDescriptor) {\n    console.log(\"second(): called\");\n  };\n}\n \nclass ExampleClass {\n  @first()\n  @second()\n  method() {}\n}</pre> <p>이는 결과를 콘솔에 출력합니다.</p> <pre data-language=\"shell\">first(): factory evaluated\nsecond(): factory evaluated\nsecond(): called\nfirst(): called</pre> <h2 id=\"데코레이터-평가-decorator-evaluation\" style=\"position:relative;\">데코레이터 평가 (Decorator Evaluation)</h2> <p>클래스에서 다양한 선언에 데코레이터를 적용하는 방법은 다음과 같이 잘 정의되어 있습니다.</p> <ol> <li>\n<em>메서드</em>, <em>접근자</em> 또는 <em>프로퍼티 데코레이터</em>가 다음에 오는 <em>매개 변수 데코레이터</em>는 각 인스턴스 멤버에 적용됩니다.</li> <li>\n<em>메서드</em>, <em>접근자</em> 또는 <em>프로퍼티 데코레이터</em>가 다음에 오는 <em>매개 변수 데코레이터</em>는 각 정적 멤버에 적용됩니다.</li> <li>\n<em>매개 변수 데코레이터</em>는 생성자에 적용됩니다.</li> <li>\n<em>클래스 데코레이터</em>는 클래스에 적용됩니다.</li> </ol> <h2 id=\"클래스-데코레이터-class-decorators\" style=\"position:relative;\">클래스 데코레이터 (Class Decorators)</h2> <p><strong>클래스 데코레이터</strong>는 클래스 선언 직전에 선언됩니다. 클래스 데코레이터는 클래스 생성자에 적용되며 클래스 정의를 관찰, 수정 또는 교체하는 데 사용할 수 있습니다. 클래스 데코레이터는 선언 파일이나 다른 주변 컨텍스트 (예: <code>선언</code> 클래스)에서 사용할 수 없습니다.</p> <p>클래스 데코레이터의 표현식은 데코레이팅된 클래스의 생성자를 유일한 인수로 런타임에 함수로 호출됩니다.</p> <p>클래스 데코레이터가 값을 반환하면 클래스가 선언을 제공하는 생성자 함수로 바꿉니다.</p> <blockquote> <p>참고 새 생성자 함수를 반환하도록 선택한 경우 원래 프로토타입을 유지 관리해야 합니다. 런타임에 데코레이터를 적용하는 로직은 이 기능을 <strong>대신해주지 않습니다.</strong></p> </blockquote> <p>다음은 <code>BugReport</code> 클래스에 적용된 클래스 데코레이터 (<code>@sealed</code>)의 예입니다.</p> <pre data-language=\"ts\">@sealed\nclass BugReport {\n  type = \"report\";\n  title: string;\n \n  constructor(t: string) {\n    this.title = t;\n  }\n}</pre> <p>다음 함수 선언을 사용하여 <code>@sealed</code> 데코레이터를 정의할 수 있습니다.</p> <pre data-language=\"ts\">function sealed(constructor: Function) {\n  Object.seal(constructor);\n  Object.seal(constructor.prototype);\n}</pre> <p><code>@sealed</code>가 실행되면 생성자와 프로토 타입을 모두 감쌉니다.</p> <p>생성자를 재정의하는 방법에 대한 예제는 다음과 같습니다.</p>  <pre data-language=\"ts\">function reportableClassDecorator&lt;T extends { new (...args: any[]): {} }&gt;(constructor: T) {\n  return class extends constructor {\n    reportingURL = \"http://www...\";\n  };\n}\n \n@reportableClassDecorator\nclass BugReport {\n  type = \"report\";\n  title: string;\n \n  constructor(t: string) {\n    this.title = t;\n  }\n}\n \nconst bug = new BugReport(\"Needs dark mode\");\nconsole.log(bug.title); // Prints \"Needs dark mode\"\nconsole.log(bug.type); // Prints \"report\"\n \n// Note that the decorator *does not* change the TypeScript type\n// and so the new property `reportingURL` is not known\n// to the type system:\nbug.reportingURL;</pre> <h2 id=\"메서드-데코레이터-method-decorators\" style=\"position:relative;\">메서드 데코레이터 (Method Decorators)</h2> <p><em>메서드 데코레이터</em>는 메서드 선언 직전에 선언됩니다. 데코레이터는 메서드의 <em>프로퍼티 설명자(Property Descriptor)</em> 에 적용되며 메서드 정의를 관찰, 수정 또는 대체하는 데 사용할 수 있습니다. 메서드 데코레이터는 선언 파일, 오버로드 또는 기타 주변 컨텍스트(예: <code>선언</code> 클래스)에서 사용할 수 없습니다.</p> <p>메서드 데코레이터의 표현식은 런타임에 다음 세 개의 인수와 함께 함수로 호출됩니다:</p> <ol> <li>정적 멤버에 대한 클래스의 생성자 함수 또는 인스턴스 멤버에 대한 클래스의 프로토타입입니다.</li> <li>멤버의 이름</li> <li>멤버의 <em>프로퍼티 설명자</em>\n</li> </ol> <blockquote> <p>참고 스크립트 대상이 ‘ES5’보다 낮은 경우 <em>프로퍼티 설명자</em> 는 ‘undefined’이 됩니다.</p> </blockquote> <p>메서드 데코레이터가 값을 반환하면, 메서드의 <em>프로퍼티 설명자</em> 로 사용됩니다.</p> <blockquote> <p>참고 스크립트 대상이 ‘ES5’보다 낮은 경우 반환 값은 무시됩니다.</p> </blockquote> <p>다음은 <code>Greeter</code> 클래스의 메서드에 적용된 메서드 데코레이터 (<code>@enumerable</code>)의 예입니다:</p>  <pre data-language=\"ts\">class Greeter {\n  greeting: string;\n  constructor(message: string) {\n    this.greeting = message;\n  }\n \n  @enumerable(false)\n  greet() {\n    return \"Hello, \" + this.greeting;\n  }\n}</pre> <p>다음 함수 선언을 사용하여 <code>@enumerable</code> 데코레이터를 정의할 수 있습니다.</p>  <pre data-language=\"ts\">function enumerable(value: boolean) {\n  return function (target: any, propertyKey: string, descriptor: PropertyDescriptor) {\n    descriptor.enumerable = value;\n  };\n}</pre> <p><code>@enumerable(false)</code>데코레이터는 <a href=\"#%EB%8D%B0%EC%BD%94%EB%A0%88%EC%9D%B4%ED%84%B0-%ED%8C%A9%ED%86%A0%EB%A6%AC-DecoratorFactories\">데코레이터 팩토리</a>입니다. <code>@enumerable(false)</code> 데코레이터가 호출되면 프로퍼티 설명자의 <code>enumerable</code> 프로퍼티를 수정합니다.</p> <h2 id=\"접근자-데코레이터-accessor-decorators\" style=\"position:relative;\">접근자 데코레이터 (Accessor Decorators)</h2> <p><em>접근자 데코레이터</em>는 접근자 선언 바로 전에 선언됩니다. 접근자 데코레이터는 접근자의 <em>프로퍼티 설명자</em>에 적용되며 접근자의 정의를 관찰, 수정 또는 교체하는 데 사용할 수 있습니다. 접근자 데코레이터는 선언 파일이나 다른 주변 컨텍스트(예: <code>선언</code> 클래스)에서 사용할 수 없습니다.</p> <blockquote> <p>참고 TypeScript는 단일 멤버에 대해 <code>get</code> 및 <code>set</code> 접근자를 데코레이팅 할 수 없습니다. 대신 멤버의 모든 데코레이터를 문서 순서대로 지정된 첫 번째 접근자에 적용해야 합니다. 왜냐하면, 데코레이터는 각각의 선언이 아닌 <code>get</code>과 <code>set</code> 접근자를 결합한 <em>프로퍼티 설명자</em>에 적용되기 때문입니다.</p> </blockquote> <p>접근자 데코레이터의 표현 식은 런타임에 다음 세 가지 인수와 함께 함수로 호출됩니다:</p> <ol> <li>정적 멤버에 대한 클래스의 생성자 함수 또는 인스턴스 멤버에 대한 클래스의 프로토타입</li> <li>멤버의 이름</li> <li>멤버의 <em>프로퍼티 설명자</em>\n</li> </ol> <blockquote> <p>참고 스크립트 대상이 ‘ES5’보다 낮은 경우 <em>프로퍼티 설명자</em>는 <code>undefined</code>가 됩니다.</p> </blockquote> <p>접근자 데코레이터가 값을 반환하면 멤버의 <em>프로퍼티 설명자</em>로 사용됩니다.</p> <blockquote> <p>참고 스크립트 대상이 ‘ES5’보다 낮은 경우 반환 값은 무시됩니다.</p> </blockquote> <p>다음은 <code>Point</code> 클래스의 멤버에 적용되는 접근자 데코레이터 (<code>@configurable</code>)의 예입니다:</p> <pre data-language=\"ts\">class Point {\n  private _x: number;\n  private _y: number;\n  constructor(x: number, y: number) {\n    this._x = x;\n    this._y = y;\n  }\n \n  @configurable(false)\n  get x() {\n    return this._x;\n  }\n \n  @configurable(false)\n  get y() {\n    return this._y;\n  }\n}</pre> <p>다음 함수 선언을 사용하여 <code>@configurable</code> 데코레이터를 정의할 수 있습니다:</p>  <pre data-language=\"ts\">function configurable(value: boolean) {\n  return function (target: any, propertyKey: string, descriptor: PropertyDescriptor) {\n    descriptor.configurable = value;\n  };\n}</pre> <h2 id=\"프로퍼티-데코레이터-property-decorators\" style=\"position:relative;\">프로퍼티 데코레이터 (Property Decorators)</h2> <p><em>프로퍼티 데코레이터</em>는 프로퍼티 선언 바로 전에 선언됩니다. 프로퍼티 데코레이터는 선언 파일이나 다른 주변 컨텍스트(예: <code>선언</code> 클래스)에서 사용할 수 없습니다.</p> <p>프로퍼티 데코레이터의 표현 식은 런타임에 다음 두 개의 인수와 함께 함수로 호출됩니다:</p> <ol> <li>정적 멤버에 대한 클래스의 생성자 함수 또는 인스턴스 멤버에 대한 클래스의 프로토타입</li> <li>멤버의 이름</li> </ol> <blockquote> <p>참고 TypeScript에서 <code>프로퍼티 데코레이터</code>가 초기화되는 방식으로 인해 <em>프로퍼티 설명자</em>가 프로퍼티 데코레이터에 대한 인수로 제공되지 않습니다. 현재 프로토타입의 멤버를 정의할 때 인스턴스 프로퍼티를 설명하는 메커니즘이 없고 프로퍼티의 이니셜라이저를 관찰하거나 수정할 수 있는 방법이 없기 때문입니다. 반환 값도 무시됩니다. 따라서 프로퍼티 데코레이터는 특정 이름의 프로퍼티가 클래스에 선언되었음을 관찰하는 데만 사용할 수 있습니다.</p> </blockquote> <p>이 정보를 사용하여 다음 예와 같이 프로퍼티에 대한 메타데이터를 기록할 수 있습니다:</p> <pre data-language=\"ts\">class Greeter {\n  @format(\"Hello, %s\")\n  greeting: string;\n\n  constructor(message: string) {\n    this.greeting = message;\n  }\n\n  greet() {\n    let formatString = getFormat(this, \"greeting\");\n    return formatString.replace(\"%s\", this.greeting);\n  }\n}</pre> <p>다음 함수 선언을 사용하여 <code>@format</code> 데코레이터와 <code>getFormat</code> 함수를 정의 할 수 있습니다:</p> <pre data-language=\"ts\">import \"reflect-metadata\";\n\nconst formatMetadataKey = Symbol(\"format\");\n\nfunction format(formatString: string) {\n  return Reflect.metadata(formatMetadataKey, formatString);\n}\n\nfunction getFormat(target: any, propertyKey: string) {\n  return Reflect.getMetadata(formatMetadataKey, target, propertyKey);\n}</pre> <p><code>@format(\"Hello, %s\")</code> 데코레이터는 <a href=\"#%EB%8D%B0%EC%BD%94%EB%A0%88%EC%9D%B4%ED%84%B0-%ED%8C%A9%ED%86%A0%EB%A6%AC-Decorator-Factories\">데코레이터 팩토리</a>입니다. <code>@format(\"Hello, %s\")</code>가 호출되면 <code>reflect-metadata</code> 라이브러리의 <code>Reflect.metadata</code> 함수를 사용하여 프로퍼티에 대한 메타데이터 항목을 추가합니다. <code>getFormat</code>이 호출되면 형식의 메타데이터 값을 읽습니다.</p> <blockquote> <p>참고 이 예제에는 <code>reflect-metadata</code> 라이브러리가 필요합니다. <code>reflect-metadata</code> 라이브러리에 대한 자세한 내용은 <a href=\"#%EB%A9%94%ED%83%80%EB%8D%B0%EC%9D%B4%ED%84%B0-metadata\">메타데이터</a>를 참조하십시오.</p> </blockquote> <h2 id=\"매개변수-데코레이터-parameter-decorators\" style=\"position:relative;\">매개변수 데코레이터 (Parameter Decorators)</h2> <p><em>매개변수 데코레이터</em>는 매개 변수 선언 직전에 선언됩니다. 매개변수 데코레이터는 클래스 생성자 또는 메서드 선언의 함수에 적용됩니다. 매개변수 데코레이터는 선언 파일, 오버로드 또는 다른 주변 컨텍스트(예: <code>선언</code> 클래스)에서 사용할 수 없습니다.</p> <p>매개 변수 데코레이터의 표현식은 런타임시 다음 세 개의 인수와 함께 함수로 호출됩니다:</p> <ol> <li>정적 멤버에 대한 클래스의 생성자 함수 또는 인스턴스 멤버에 대한 클래스의 프로토타입</li> <li>멤버의 이름</li> <li>함수의 매개 변수 목록에 있는 매개 변수의 서수 색인(ordinal index)</li> </ol> <blockquote> <p>참고 매개변수 데코레이터는 매개변수가 메서드에서 선언되었을 때에만 관찰하는 데에 사용할 수 있습니다.</p> </blockquote> <p>메개변수 데코레이터의 반환 값은 무시됩니다.</p> <p>다음은 <code>BugReport</code> 클래스 멤버의 매개 변수에 적용되는 매개 변수 데코레이터 (<code>@required</code>)의 예입니다:</p>  <pre data-language=\"ts\">class BugReport {\n  type = \"report\";\n  title: string;\n \n  constructor(t: string) {\n    this.title = t;\n  }\n \n  @validate\n  print(@required verbose: boolean) {\n    if (verbose) {\n      return this.title;\n    } else {\n      return `type: ${this.type}\\ntitle: ${this.title}`;\n    }\n  }\n}</pre> <p>다음 함수 선언을 사용하여 <code>@required</code> 및 <code>@validate</code> 데코레이터를 정의할 수 있습니다.</p>  <pre data-language=\"ts\">import \"reflect-metadata\";\nconst requiredMetadataKey = Symbol(\"required\");\n \nfunction required(target: Object, propertyKey: string | symbol, parameterIndex: number) {\n  let existingRequiredParameters: number[] = Reflect.getOwnMetadata(requiredMetadataKey, target, propertyKey) || [];\n  existingRequiredParameters.push(parameterIndex);\n  Reflect.defineMetadata( requiredMetadataKey, existingRequiredParameters, target, propertyKey);\n}\n \nfunction validate(target: any, propertyName: string, descriptor: TypedPropertyDescriptor&lt;Function&gt;) {\n  let method = descriptor.value!;\n \n  descriptor.value = function () {\n    let requiredParameters: number[] = Reflect.getOwnMetadata(requiredMetadataKey, target, propertyName);\n    if (requiredParameters) {\n      for (let parameterIndex of requiredParameters) {\n        if (parameterIndex &gt;= arguments.length || arguments[parameterIndex] === undefined) {\n          throw new Error(\"Missing required argument.\");\n        }\n      }\n    }\n    return method.apply(this, arguments);\n  };\n}</pre> <p><code>@required</code> 데코레이터는 필요에 따라 매개변수를 표시하는 메타데이터 항목을 추가합니다. 그런 다음 <code>@validate</code> 데코레이터는 원래 메서드를 호출하기 전에 인수 유효성 검증하는 함수로 기존의 <code>greet</code> 메서드를 감쌉니다.</p> <blockquote> <p>참고 이 예제에는 <code>reflect-metadata</code> 라이브러리가 필요합니다. <code>reflect-metadata</code> 라이브러리에 대한 자세한 내용은 [메타데이터] (#메타데이터-metadata)를 참조하십시오.</p> </blockquote> <h2 id=\"메타데이터-metadata\" style=\"position:relative;\">메타데이터 (Metadata)</h2> <p>일부 예제는 <a href=\"https://github.com/rbuckton/ReflectDecorators\">실험적 메타데이터 API</a>에 대한 폴리필(polyfill)을 추가하는 <code>reflect-metadata</code> 라이브러리를 사용합니다. 이 라이브러리는 아직 ECMAScript (JavaScript) 표준의 일부가 아닙니다. 그러나 데코레이터가 공식적으로 ECMAScript 표준의 일부로 채택되면 이러한 확장을 채택하게 될 것입니다.</p> <p>npm을 통해 설치할 수 있습니다.</p> <pre data-language=\"shell\">npm i reflect-metadata --save</pre> <p>TypeScript에는 데코레이터가 있는 선언에 대해 특정 타입의 메타 데이터를 내보내는 실험적인 지원을 포함합니다. 이 실험적인 지원을 가능하게 하려면, 명령행 또는<code>tsconfig.json</code>에서 <code>emitDecoratorMetadata</code> 컴파일러 옵션을 설정해야 합니다.</p> <p><strong>명령줄</strong>:</p> <pre data-language=\"shell\">tsc --target ES5 --experimentalDecorators --emitDecoratorMetadata</pre> <p><strong>tsconfig.json</strong>:</p> <pre tsconfig=\"true\" data-language=\"typescript\">{\n  \"compilerOptions\": {\n    \"target\": \"ES5\",\n    \"experimentalDecorators\": true,\n    \"emitDecoratorMetadata\": true\n  }\n}</pre> <p>활성화되면 <code>reflect-metadata</code>라이브러리를 가져오기만 하면 추가 디자인-타임 타입 정보가 런타임에 사용 가능합니다.</p> <p>다음 예제에서 이를 확인할 수 있습니다.</p>  <pre data-language=\"ts\">import \"reflect-metadata\";\n \nclass Point {\n  constructor(public x: number, public y: number) {}\n}\n \nclass Line {\n  private _start: Point;\n  private _end: Point;\n \n  @validate\n  set start(value: Point) {\n    this._start = value;\n  }\n \n  get start() {\n    return this._start;\n  }\n \n  @validate\n  set end(value: Point) {\n    this._end = value;\n  }\n \n  get end() {\n    return this._end;\n  }\n}\n \nfunction validate&lt;T&gt;(target: any, propertyKey: string, descriptor: TypedPropertyDescriptor&lt;T&gt;) {\n  let set = descriptor.set!;\n  \n  descriptor.set = function (value: T) {\n    let type = Reflect.getMetadata(\"design:type\", target, propertyKey);\n \n    if (!(value instanceof type)) {\n      throw new TypeError(`Invalid type, got ${typeof value} not ${type.name}.`);\n    }\n \n    set.call(this, value);\n  };\n}\n \nconst line = new Line()\nline.start = new Point(0, 0)\n \n// @ts-ignore\n// line.end = {}\n \n// Fails at runtime with:\n// &gt; Invalid type, got object not Point\n </pre> <p>TypeScript 컴파일러는 <code>@Reflect.metadata</code> 데코레이터를 사용하여 디자인-타임 타입 정보를 주입합니다. 다음 TypeScript와 동일하다고 생각할 수 있습니다.</p> <pre data-language=\"ts\">class Line {\n  private _start: Point;\n  private _end: Point;\n\n  @validate\n  @Reflect.metadata(\"design:type\", Point)\n  set start(value: Point) {\n    this._start = value;\n  }\n  get start() {\n    return this._start;\n  }\n\n  @validate\n  @Reflect.metadata(\"design:type\", Point)\n  set end(value: Point) {\n    this._end = value;\n  }\n  get end() {\n    return this._end;\n  }\n}</pre> <blockquote> <p>참고 데코레이터 메타 데이터는 실험적인 기능으로 향후 릴리스에서 주요 변경 사항이 있을 수 있습니다.</p> </blockquote><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2012-2023 Microsoft<br>Licensed under the Apache License, Version 2.0.<br>\n    <a href=\"https://www.typescriptlang.org/ko/docs/handbook/decorators.html\" class=\"_attribution-link\">https://www.typescriptlang.org/ko/docs/handbook/decorators.html</a>\n  </p>\n</div>\n","variable-declarations":"<h1>Variable Declaration</h1>\n<p><code>let</code>과 <code>const</code>는 JavaScript에서 비교적 새로운 두 가지 유형의 변수 선언입니다. <a href=\"basic-types.md#let%EC%97%90-%EA%B4%80%ED%95%98%EC%97%AC\">앞에서 언급했듯이</a>, <code>let</code>은 <code>var</code>와 어느 정도 유사하지만, 사용자가 JavaScript에서 자주 마주치는 결함을 피할 수 있게 해줍니다. <code>const</code>는 <code>let</code>의 기능이 강화된 것으로 변수에 재할당을 방지합니다.</p> <p>TypeScript는 JavaScript의 상위 집합이므로, 당연히 <code>let</code>과 <code>const</code>를 지원합니다. 여기서는 새로운 선언 방식들과 왜 그 방식들이 <code>var</code>보다 선호되는지를 더 자세히 설명합니다.</p> <p>JavaScript를 아무렇게나 사용하고 있었다면, 다음 섹션이 기억을 새로 고치도록 도와줄 것입니다. JavaScript에서 <code>var</code> 선언의 단점들에 대해 모두 알고 있다면 쉽게 넘어갈 수 있습니다.</p> <h1 id=\"var-선언-var-declarations\" style=\"position:relative;\">\n<code>var</code> 선언 (<code>var</code> declarations)</h1> <p>기존 JavaScript에서는 변수 선언을 할 때 <code>var</code> 키워드를 사용했습니다.</p> <pre data-language=\"ts\">var a = 10;</pre> <p>알다시피, <code>a</code>라는 변수를 <code>10</code>이라는 값으로 선언했습니다.</p> <p>또한, 변수를 함수 내부에 선언할 수도 있습니다.</p> <pre data-language=\"ts\">function f() {\n    var message = \"Hello, world!\";\n\n    return message;\n}</pre> <p>그리고, 같은 변수를 다른 함수 안에서 접근할 수도 있습니다.</p> <pre data-language=\"ts\">function f() {\n    var a = 10;\n    return function g() {\n        var b = a + 1;\n        return b;\n    }\n}\n\nvar g = f();\ng(); // '11'을 반환</pre> <p>위 예제에서, <code>g</code>는 <code>f</code> 안에 선언된 <code>a</code>를 잡아 둡니다. 언제든 <code>g</code>가 호출될 때, <code>a</code>의 값은 <code>f</code> 안의 <code>a</code> 값을 가리킵니다. <code>f</code>가 실행되면서 <code>g</code>가 한번 호출된 후에도, <code>a</code>에 접근해 수정할 수 있습니다.</p> <pre data-language=\"ts\">function f() {\n    var a = 1;\n\n    a = 2;\n    var b = g();\n    a = 3;\n\n    return b;\n\n    function g() {\n        return a;\n    }\n}\n\nf(); // '2' 반환</pre> <h2 id=\"스코프-규칙-scoping-rules\" style=\"position:relative;\">스코프 규칙 (Scoping rules)</h2> <p><code>var</code> 선언은 다른 언어와 다른 이상한 스코프 규칙들을 가지고 있습니다. 아래 예제를 살펴보겠습니다:</p> <pre data-language=\"ts\">function f(shouldInitialize: boolean) {\n    if (shouldInitialize) {\n        var x = 10;\n    }\n\n    return x;\n}\n\nf(true);  // '10' 반환\nf(false); // 'undefined' 반환</pre> <p>이 예제에서, 어떤 분들은 머뭇거릴 수도 있습니다. 변수 <code>x</code>는 <em><code>if</code> 블록 안에 선언되어 있지만</em>, 블록의 바깥에서도 이 변수에 접근할 수 있습니다. 이 이유는 <code>var</code>선언은 이를 감싸고 있는 블록과 관계없이 이를 감싸고 있는 함수, 모듈, 네임스페이스, 전역 스코프에서 접근할 수 있기 때문입니다. 어떤 이는 이를 <em><code>var</code>-스코프</em> 혹은 <em>함수 스코프</em>라고 부릅니다. 매개 변수 또한 함수 스코프입니다.</p> <p>이런 스코프 규칙은 몇 가지 실수를 유발할 수 있습니다. 더욱 문제를 심각하게 하는 것은 변수를 여러 번 선언하는 것이 에러가 아니라는 것입니다:</p> <pre data-language=\"ts\">function sumMatrix(matrix: number[][]) {\n    var sum = 0;\n    for (var i = 0; i &lt; matrix.length; i++) {\n        var currentRow = matrix[i];\n        for (var i = 0; i &lt; currentRow.length; i++) {\n            sum += currentRow[i];\n        }\n    }\n\n    return sum;\n}</pre> <p>아마 쉽게 찾을 수 있겠지만, <code>i</code>가 같은 함수 스코프의 변수를 참조하고 있기 때문에 <code>for</code>-loop 안에서 실수로 변수 <code>i</code>를 덮어쓸 수도 있습니다 경험 많은 개발자는 바로 알아차리겠지만, 비슷한 종류의 버그는 코드 리뷰를 거치며 좌절의 원인이 되기도 합니다.</p> <h2 id=\"변수-캡쳐링의-단점-variable-capturing-quirks\" style=\"position:relative;\">변수 캡쳐링의 단점 (Variable capturing quirks)</h2> <p>다음 코드의 출력 결과를 예상해 보세요:</p> <pre data-language=\"ts\">for (var i = 0; i &lt; 10; i++) {\n    setTimeout(function() { console.log(i); }, 100 * i);\n}</pre> <p>익숙하지 않은 분들을 위해 말씀드리자면, <code>setTimeout</code>은 특정 밀리 초 후에 함수를 실행합니다.(다른 작업의 실행이 멈추는 것을 기다리며)</p> <p>준비됐나요? 살펴보겠습니다:</p> <pre data-language=\"text\">10\n10\n10\n10\n10\n10\n10\n10\n10\n10</pre> <p>많은 JavaScript 개발자들은 이런 동작에 익숙한 편이지만, 만약 놀랐더라도 당신 혼자만 놀란 것은 아닙니다. 많은 사람들이 출력 결과가 다음과 같을 거라고 생각합니다.</p> <pre data-language=\"text\">0\n1\n2\n3\n4\n5\n6\n7\n8\n9</pre> <p>앞서 변수 캡쳐링에 대해 언급했던 부분을 기억하나요? <code>setTimout</code>에 전달하는 모든 함수 표현식은 사실 같은 스코프에서 같은 <code>i</code>를 참조합니다.</p> <p>잠시, 이게 무슨 뜻인지 생각해 보세요. <code>setTimeout</code>은 함수를 몇 밀리 초 후에 실행 시키겠지만. <em>항상</em><code>for</code>루프가 실행을 멈추고 난 뒤에 실행됩니다. <code>for</code> 루프가 실행을 중지했을 때, <code>i</code>의 값은 <code>10</code>입니다. 따라서 매번 주어진 함수가 호출될 때마다 <code>10</code>을 출력할 것입니다.</p> <p>일반적으로 이를 동작하게 하는 방법은 즉시 실행 함수(IIFE - an Immediately Invoked Function Expression)를 사용해 매 반복마다 <code>i</code>를 잡아두는 것입니다:</p> <pre data-language=\"ts\">for (var i = 0; i &lt; 10; i++) {\n    // 현재 값으로 함수를 호출시켜\n    // 현재 상태의 'i'를 잡아둔다.\n    (function(i) {\n        setTimeout(function() { console.log(i); }, 100 * i);\n    })(i);\n}</pre> <p>이런 이상해 보이는 패턴이 사실 일반적인 패턴입니다. 매개변수에 <code>i</code>가 <code>for</code> 루프의 <code>i</code>를 감춰 버립니다. 하지만 이름을 같게 했기 때문에 루프의 실행 부를 크게 수정할 필요가 없습니다.</p> <h1 id=\"let-선언-let-declarations\" style=\"position:relative;\">\n<code>let</code> 선언 (<code>let</code> declarations)</h1> <p>이제, <code>var</code>에 몇 가지 문제점에 대해 알게 되었는데, 이런 이유 때문에 <code>let</code>을 도입하게 되었습니다. 사용되는 키워드를 빼고는 <code>let</code> 문은 <code>var</code>와 동일한 방법으로 작성됩니다.</p> <pre data-language=\"ts\">let hello = \"Hello!\";</pre> <p>주요한 차이점은 구문 보단 의미에 있는데, 이제 이 내용을 살펴볼 것입니다.</p> <h2 id=\"블록-스코프-block-scoping\" style=\"position:relative;\">블록 스코프 (Block-scoping)</h2> <p>변수가 <code>let</code>을 이용해 선언되었을 때, 이는 <em>렉시컬 스코핑(lexical-scoping)</em> 혹은 <em>블록 스코핑(block-scoping)</em> 이라 불리는 것을 사용합니다. <code>var</code>로 선언된 변수가 이를 포함한 함수까지 흘러나오는 것과 달리, 블록-스코프 변수들은 이를 가장 가깝게 감싸고 있는 블록 혹은 <code>for</code>-루프 밖에서 접근할 수 없습니다.</p> <pre data-language=\"ts\">function f(input: boolean) {\n    let a = 100;\n\n    if (input) {\n        // 'a'를 참조할 수 있습니다.\n        let b = a + 1;\n        return b;\n    }\n\n    // 오류: 'b'는 여기서 존재하지 않습니다.\n    return b;\n}</pre> <p>여기, 두 지역 변수 <code>a</code>와 <code>b</code>가 있습니다. <code>a</code>의 스코프는 <code>f</code>의 블록으로 한정되지만, <code>b</code>는 이를 감싸고 있는 <code>if</code>문의 블록까지로 한정됩니다.</p> <p><code>catch</code> 문에 선언된 변수 또한 비슷한 스코프 규칙을 가집니다.</p> <pre data-language=\"ts\">try {\n    throw \"oh no!\";\n}\ncatch (e) {\n    console.log(\"Oh well.\");\n}\n\n// 오류: 'e'는 여기서 존재하지 않습니다.\nconsole.log(e);</pre> <p>또 다른 블록-스코프 변수의 특징은 변수들이 선언되기 전에 읽거나, 쓰는 것이 불가능하다는 것입니다. 이 변수들은 스코프에 걸쳐 “존재”하지만, 선언되는 부분 전까지 모든 부분들이 <em>temploral dead zone</em>입니다. 이것은 <code>let</code>문 이전에 변수들에 접근할 수 없다는 정교한 방식이며, 다행히 TypeScript가 알려줍니다.</p> <pre data-language=\"ts\">a++; // `a`가 선언되기 전에 잘못된 사용.\nlet a;</pre> <p>주의할 점은 여전히 선언되기 전에 블록-스코프 변수를 <em>잡아둘</em> 수 있다는 것입니다. 선언되기 전에 함수를 실행하는 것이 안된 다는 것만 알아두면 됩니다. ES2015를 대상으로한, 최신 런타임은 오류를 던질 것입니다; 하지만 현재 TypeScript에서는 허용되며, 오류를 보고하지 않습니다.</p> <pre data-language=\"ts\">function foo() {\n    // 'a' 캡처는 성공\n    return a;\n}\n\n// `a`가 선언되기 전에 `foo` 를 호출\n// 런타임에 오류를 던질 것 입니다.\nfoo();\n\nlet a;</pre> <p>temporal dead zone에 더 자세한 설명은 <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/let#Temporal_dead_zone_and_errors_with_let\">Mozilla Developer Network</a>를 살펴보세요.</p> <h2 id=\"재선언과-쉐도잉-re-declarations-and-shadowing\" style=\"position:relative;\">재선언과 쉐도잉 (Re-declarations and Shadowing)</h2> <p><code>var</code>로 선언하면 얼마나 변수를 많이 선언하는지는 중요하지 않다고 했습니다. 단 하나만 생성됩니다.</p> <pre data-language=\"ts\">function f(x) {\n    var x;\n    var x;\n\n    if (true) {\n        var x;\n    }\n}</pre> <p>위 예제를 보면 모든 <code>x</code>의 선언은 사실 같은 <code>x</code>를 가르치며, 이는 유효합니다. 이건 종종 버그의 원인이 됩니다. 고맙게도, <code>let</code>선언은 이것을 허용하지 않습니다.</p> <pre data-language=\"ts\">let x = 10;\nlet x = 20; // 오류: 'x'를 같은 스코프에 선언할 수 없습니다.</pre> <p>TypeScript가 문제를 알려주기 때문에, 변수를 반드시 블록 범위로 지정할 필요는 없습니다.</p> <pre data-language=\"ts\">function f(x) {\n    let x = 100; // 오류: 매개 변수 선언을 방해합니다.\n}\n\nfunction g() {\n    let x = 100;\n    var x = 100; // 오류: `x`를 중복해서 선언할 수 없습니다.\n}</pre> <p>블록-스코프 변수가 함수-스코프 변수로 선언될 수 없다는 것은 아닙니다. 블록 스코프 변수는 단지 별개의 다른 블록에 선언되어야 합니다.</p> <pre data-language=\"ts\">function f(condition, x) {\n    if (condition) {\n        let x = 100;\n        return x;\n    }\n\n    return x;\n}\n\nf(false, 0); // '0' 반환\nf(true, 0);  // '100' 반환</pre> <p>더 중첩된 스코프에서 바깥 스코프의 변수 이름을 사용하는 것을 <em>shadowing</em>이라고 합니다. <em>shadowing</em>은 양날의 검이라고 할 수 있는데, 이는 실수로 방생되어 특정 버그를 일으키거나, 혹은 특정 버그를 막기 위해 쓰이기 때문입니다. 예를 들어, 위에서 사용했던 <code>sumMatrix</code> 함수를 <code>let</code> 을 이용해서 작성했다고 생각해 봅시다.</p> <pre data-language=\"ts\">function sumMatrix(matrix: number[][]) {\n    let sum = 0;\n    for (let i = 0; i &lt; matrix.length; i++) {\n        var currentRow = matrix[i];\n        for (let i = 0; i &lt; currentRow.length; i++) {\n            sum += currentRow[i];\n        }\n    }\n\n    return sum;\n}</pre> <p>이 루프는 합을 올바르게 계산할 것입니다. 왜냐하면 안쪽 루프의 <code>i</code> 가 바깥 루프의 <code>i</code>를 가리기 때문입니다.</p> <p><em>보통</em> 더 명확한 코드 작성을 위해 shadowing 사용을 피합니다. 하지만 shadowing의 이점을 활용할 수 있는 적합한 상황이 있으므로, 최선의 판단을 내려야 합니다.</p> <h2 id=\"블록-스코프-변수-캡쳐링-block-scoped-variable-capturing\" style=\"position:relative;\">블록 스코프 변수 캡쳐링 (Block-scoped variable capturing)</h2> <p><code>var</code> 선언에 변수 캡쳐링을 하는 것을 처음 보았을 때, 변수가 한번 캡쳐되면 어떻게 동작하는지 간단히 살펴보았습니다. 이를 더 잘 이해해 보면, 스코프가 각각 실행될 때마다 변수의 “환경”을 만듭니다. 변수의 환경과 캡쳐된 변수들은 심지어 스코프가 포함한 모든 것이 실행을 종료한 후에도 존재합니다.</p> <pre data-language=\"ts\">function theCityThatAlwaysSleeps() {\n    let getCity;\n\n    if (true) {\n        let city = \"Seattle\";\n        getCity = function() {\n            return city;\n        }\n    }\n\n    return getCity();\n}</pre> <p><code>city</code>를 해당 환경 안에 캡쳐했기 때문에, <code>if</code> 블록의 실행이 완료되었음에도 여전히 <code>city</code>에 접근할 수 있습니다.</p> <p>앞의 <code>setTimeout</code> 예제에서, <code>for</code> 루프가 매번 반복될 때마다 변수를 캡쳐하기 위해서 IIFE를 사용했던 것을 떠올려 봅시다. 실제론, 캡처된 변수를 위해 새로운 변수 환경을 만드는 것이었습니다. 이는 약간의 고통스러운 일이지만, 다행히, 타입스크립트 에서는 그렇게 할필요가 없습니다.</p> <p><code>let</code> 선언은 루프의 일부로 선언될 때 동작이 크게 다릅니다. 이 선언은 루프 자체에 새로운 환경을 만드는 대신, <code>반복마다</code> 새로운 환경을 만들어 냅니다. 어쨋든 이건 IIFE를 통해 하고 있었던 동작이므로, 이전 <code>setTimeout</code>예제를 <code>let</code>선언만 사용해서 바꿀수 있습니다.</p> <pre data-language=\"ts\">for (let i = 0; i &lt; 10 ; i++) {\n    setTimeout(function() { console.log(i); }, 100 * i);\n}</pre> <p>그리고 예상 했던 대로, 다음과 같은 결과가 출력됩니다.</p> <pre data-language=\"text\">0\n1\n2\n3\n4\n5\n6\n7\n8\n9</pre> <h1 id=\"const-선언-const-declarations\" style=\"position:relative;\">\n<code>const</code> 선언 (<code>const</code> declarations)</h1> <p><code>const</code> 선언은 변수를 선언하는 또 다른 방법입니다.</p> <pre data-language=\"ts\">const numLivesForCat = 9;</pre> <p>이 방법은 <code>let</code> 선언과 비슷하지만 그 이름에서 말해주듯이, 일단 바인딩 되면 값을 변경할 수 없습니다. 다른 말로 <code>const</code>는 <code>let</code>과 같은 스코프 규칙을 가지고 있지만, 재할당 할 수 없습니다.</p> <p>이를 <code>const</code>가 참조하는 값이 <em>불변</em>이라고 혼동하면 안 됩니다.</p> <pre data-language=\"ts\">const numLivesForCat = 9;\nconst kitty = {\n    name: \"Aurora\",\n    numLives: numLivesForCat,\n}\n\n// 오류\nkitty = {\n    name: \"Danielle\",\n    numLives: numLivesForCat\n};\n\n// 모두 \"성공\"\nkitty.name = \"Rory\";\nkitty.name = \"Kitty\";\nkitty.name = \"Cat\";\nkitty.numLives--;</pre> <p>위와 같은 상황을 피하기 위해 특별한 조치를 취하지 않는 한, <code>const</code> 변수의 내부 상태는 여전히 수정 가능합니다. 다행히, TypeScript를 사용하면 객체의 멤버가 <code>읽기 전용(readonly)</code>이라고 지정할 수 있습니다. <a href=\"interfaces.md\">Interfaces 챕터</a>에 자세히 설명되어 있습니다.</p> <h1 id=\"let-vs-const\" style=\"position:relative;\">\n<code>let</code> vs. <code>const</code>\n</h1> <p>유사한 스코프의 의미를 가지는 두 가지 유형의 변수 선언이 있기 때문에, 어느 것을 사용하는지는 스스로 선택해야 합니다. 광범위한 질문처럼, 답은 ‘때에 따라 다르다’입니다.</p> <p><a href=\"https://en.wikipedia.org/wiki/Principle_of_least_privilege\">최소 권한의 원칙</a>을 적용하면, 수정하려는 선언 이외에 모든 선언은 <code>const</code>를 사용해야 합니다. 그 이유는, 만약 변수가 수정될 필요가 없다면 같은 코드베이스에서 작업하는 다른 사람들이 자동으로 객체를 수정할 수 없어야 하고, 그들이 정말 변수에 재할당할 필요가 있는지 고려할 필요가 있습니다. <code>const</code>를 사용하는 것은 데이터의 흐름을 추론할 때 코드를 더 예측하기 쉽게 해줍니다.</p> <p>최선의 판단을 하고 해당되는 경우, 팀원들과 문제에 대해 상의하세요.</p> <p>이 핸드북은 대부분 <code>let</code> 선언을 사용합니다.</p> <h1 id=\"구조-분해-destructuring\" style=\"position:relative;\">구조 분해 (Destructuring)</h1> <p>TypeScript가 가진 또 다른 ECMAScript 2015 특징은 구조 분해입니다. 자세한 내용은, <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment\">Mozilla Developer Network의 글</a>을 참고 하세요. 이번 섹션에서는 간단하게 개요를 살펴보겠습니다.</p> <h2 id=\"배열-구조-분해-array-destructuring\" style=\"position:relative;\">배열 구조 분해 (Array destructuring)</h2> <p>구조 분해의 가장 단순한 형태는 배열 구조 분해 할당입니다:</p> <pre data-language=\"ts\">let input = [1, 2];\nlet [first, second] = input;\nconsole.log(first); // 1 출력\nconsole.log(second); // 2 출력</pre> <p>이는 <code>first</code>, <code>second</code>라는 이름의 새로운 두 변수를 생성합니다. 이는 인덱싱을 사용하는 것과 동일하지만 더 편리합니다:</p> <pre data-language=\"ts\">first = input[0];\nsecond = input[1];</pre> <p>구조 분해 할당은 이미 선언된 변수에도 동작합니다:</p> <pre data-language=\"ts\">// 변수를 스왑\n[first, second] = [second, first];</pre> <p>그리고, 함수의 매개변수에도 동작합니다:</p> <pre data-language=\"ts\">function f([first, second]: [number, number]) {\n    console.log(first);\n    console.log(second);\n}\nf([1, 2]);</pre> <p>나머지 요소들에 대해 <code>...</code> 구문을 사용하여 변수를 생성할 수 있습니다:</p> <pre data-language=\"ts\">let [first, ...rest] = [1, 2, 3, 4];\nconsole.log(first); // 1 출력\nconsole.log(rest); // [ 2, 3, 4 ] 출력</pre> <p>물론 JavaScript이기 때문에, 필요하지 않은 뒤따라 오는 요소들을 무시할 수 있습니다:</p> <pre data-language=\"ts\">let [first] = [1, 2, 3, 4];\nconsole.log(first); // 1 출력</pre> <p>또는 그 밖에 요소들을 무시할 수 있습니다:</p> <pre data-language=\"ts\">let [, second, , fourth] = [1, 2, 3, 4];\nconsole.log(second); // 2 출력\nconsole.log(fourth); // 4 출력</pre> <h2 id=\"튜플-구조-분해-tuple-destructuring\" style=\"position:relative;\">튜플 구조 분해 (Tuple destructuring)</h2> <p>튜플은 배열처럼 구조 분해됩니다; 구조 분해된 변수는 튜플 요소와 일치하는 타입을 얻게 됩니다:</p> <pre data-language=\"ts\">let tuple: [number, string, boolean] = [7, \"hello\", true];\n\nlet [a, b, c] = tuple; // a: number, b: string, c: boolean</pre> <p>튜플의 범위를 넘어선 구조 분해는 오류입니다:</p> <pre data-language=\"ts\">let [a, b, c, d] = tuple; // 오류, 인덱스 3에 요소가 없습니다.</pre> <p>배열과 마찬가지로, 더 짧은 튜플을 얻기 위해 <code>...</code>로 튜플의 나머지를 구조 분해할 수 있습니다.</p> <pre data-language=\"ts\">let [a, ...bc] = tuple; // bc: [string, boolean]\nlet [a, b, c, ...d] = tuple; // d: [], 비어있는 튜플</pre> <p>또는 뒤따라 오는 요소나 다른 요소를 무시할 수 있습니다:</p> <pre data-language=\"ts\">let [a] = tuple; // a: number\nlet [, b] = tuple; // b: string</pre> <h2 id=\"객체-구조-분해-object-destructuring\" style=\"position:relative;\">객체 구조 분해 (Object destructuring)</h2> <p>또한 객체를 구조 분해할 수 있습니다:</p> <pre data-language=\"ts\">let o = {\n    a: \"foo\",\n    b: 12,\n    c: \"bar\"\n};\nlet { a, b } = o;</pre> <p>이는 <code>o.a</code>, <code>o.b</code>로 부터 새로운 변수 <code>a</code>와 <code>b</code>를 생성합니다. 필요 없다면 <code>c</code>를 건너 뛸 수 있다는 걸 알아두세요.</p> <p>배열 구조 분해처럼, 선언 없이 할당할 수 있습니다.:</p> <pre data-language=\"ts\">({ a, b } = { a: \"baz\", b: 101 });</pre> <p>이 구문을 괄호로 감싸고 있다는 것을 주의해 주세요. JavaScript는 보통 <code>{</code>를 블록의 시작으로 파싱 합니다.</p> <p>객체 안에 나머지 요소들을 <code>...</code> 구문을 사용하여 변수로 생성할 수 있습니다:</p> <pre data-language=\"ts\">let { a, ...passthrough } = o;\nlet total = passthrough.b + passthrough.c.length;\n</pre> <h3 id=\"프로퍼티-이름-바꾸기-property-renaming\" style=\"position:relative;\">프로퍼티 이름 바꾸기 (Property renaming)</h3> <p>프로퍼티들에 다른 이름을 붙히는 것도 가능합니다.</p> <pre data-language=\"ts\">let { a: newName1, b: newName2 } = o;</pre> <p>여기서 구문이 혼란스러워지기 시작합니다. <code>a: newName1</code> 을 ”<code>a</code>를 <code>newName1</code> 로” 와 같이 읽을 수 있습니다. 여태 써왔던 것 처럼 방향은 왼쪽에서 오른쪽입니다:</p> <pre data-language=\"ts\">let newName1 = o.a;\nlet newName2 = o.b;</pre> <p>혼란스럽게도 여기서 콜론은 타입을 나타내지 않습니다. 타입을 지정하는 경우, 전체 구조 분해 뒤에 작성해야 합니다:</p> <pre data-language=\"ts\">let { a, b }: { a: string, b: number } = o;</pre> <h3 id=\"기본-값-default-values\" style=\"position:relative;\">기본 값 (Default values)</h3> <p>기본 값은 프로퍼티가 정의되지 않았을 때 기본값을 사용하도록 하는 것입니다:</p> <pre data-language=\"ts\">function keepWholeObject(wholeObject: { a: string, b?: number }) {\n    let { a, b = 1001 } = wholeObject;\n}</pre> <p>예제에서 <code>b?</code>는 <code>b</code>가 선택적이라는 것을 의미합니다. 따라서 이는 <code>undefined</code> 일 수도 있습니다. <code>keepWholeObject</code>는 이제 <code>b</code>가 undefined 이더라도 <code>a</code>, <code>b</code> 프로퍼티와 함께 <code>wholeObject</code>라는 변수를 가집니다.</p> <h2 id=\"함수-선언-function-declarations\" style=\"position:relative;\">함수 선언 (Function declarations)</h2> <p>구조 분해는 함수 선언에서도 동작합니다. 이것은 간단한 경우에는 직관적입니다:</p> <pre data-language=\"ts\">type C = { a: string, b?: number }\nfunction f({ a, b }: C): void {\n    // ...\n}</pre> <p>그러나 매개 변수에는 기본값을 명시하는 것이 더 일반적이며, 구조 분해와 함께 기본값을 제대로 사용하는 것은 까다로울 수 있습니다. 가장 먼저, 구조 분해 패턴을 기본값 앞에 넣어야 한다는 것을 기억해야 합니다.</p> <pre data-language=\"ts\">function f({ a=\"\", b=0 } = {}): void {\n    // ...\n}\nf();</pre> <blockquote> <p>위 코드는 타입 추론의 예제이며 이후 핸드북에서 설명합니다.</p> </blockquote> <p>그런 다음, 선택적 프로퍼티를 위해 기본 초기화 대신 구조 분해될 프로퍼티에 기본 값을 주어야 한다는 걸 기억해야 합니다. <code>C</code> 가 <code>b</code>를 선택적으로 정의했다는 것을 기억하세요:</p> <pre data-language=\"ts\">function f({ a, b = 0 } = { a: \"\" }): void {\n    // ...\n}\nf({ a: \"yes\" }); // 성공, 기본값으로 b = 0 입니다.\nf(); // 성공, 기본 값은 { a: \"\" } 이고 b = 0 입니다.\nf({}); // 오류, 매개 변수가 주어지면 `a`가 필요합니다.</pre> <p>구조 분해를 주의해서 사용하세요. 앞에 예제에서 알 수 있듯이, 가장 간단한 구조 분해 표현식 이외의 것들은 혼란스럽습니다. 심지어 이름 변경, 기본값, 타입 표시가 없더라도 깊게 중첩된 구조 분해는 <em>정말</em> 이해하기가 힘듭니다. 구조 분해 표현식을 작고 간단하게 유지하세요. 당신은 언제나 구조 분해가 만드는 과제를 당신 손으로 만들 수 있습니다.</p> <h2 id=\"전개-spread\" style=\"position:relative;\">전개 (Spread)</h2> <p>전개 연산자는 구조 분해와 반대입니다. 이는 배열을 다른 배열 안에, 혹은 객체를 다른 객체 안에 전개하도록 해줍니다. 예를 보겠습니다:</p> <pre data-language=\"ts\">let first = [1, 2];\nlet second = [3, 4];\nlet bothPlus = [0, ...first, ...second, 5];</pre> <p>이는 bothPlus에 <code>[0, 1, 2, 3, 4, 5]</code>라는 값을 줍니다. 전개는 <code>first</code>와 <code>second</code>의 얕은 복사를 만듭니다. 이들은 전개에 의해 변하지 않습니다.</p> <p>또한 객체를 전개할 수 있습니다:</p> <pre data-language=\"ts\">let defaults = { food: \"spicy\", price: \"$$\", ambiance: \"noisy\" };\nlet search = { ...defaults, food: \"rich\" };</pre> <p>여기서 <code>search</code>는 <code>{ food: \"rich\", price: \"$$\", ambiance: \"noisy\" }</code>입니다. 객체 전개는 배열 전개보다 훨씬 복잡합니다. 배열 전개처럼 왼쪽에서-오른쪽으로 진행되지만 그 결과는 여전히 객체입니다. 이는 전개 객체 안에서 나중에 오는 프로퍼티가 이전에 오는 프로퍼티를 덮어쓰는 것을 의미합니다. 그래서 만약에 우리가 이전 예제를 마지막에 전개하도록 수정하면:</p> <pre data-language=\"ts\">let defaults = { food: \"spicy\", price: \"$$\", ambiance: \"noisy\" };\nlet search = { food: \"rich\", ...defaults };</pre> <p><code>defaults</code>안에 <code>food</code> 프로퍼티는 <code>food: \"rich\"</code>를 덮어쓰는데, 이 경우 우리가 의도한 것은 아닙니다.</p> <p>객체 전개는 또한 몇몇의 놀라운 제한점이 잇습니다. 첫째로, 이는 오직 객체 <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Enumerability_and_ownership_of_properties\">본인의 열거 가능한 프로퍼티</a>만 해당한다는 것입니다. 기본적으로, 이는 객체의 인스턴스를 전개하면 메서드를 잃게 된다는 것을 뜻합니다:</p> <pre data-language=\"ts\">class C {\n  p = 12;\n  m() {\n  }\n}\nlet c = new C();\nlet clone = { ...c };\nclone.p; // 성공\nclone.m(); // 오류!</pre> <p>두 번째로, TypeScript 컴파일러는 제네릭 함수에서 타입 매개변수를 전개하는 것을 허용하지 않습니다. 이 기능은 이후 버전에서 예상되는 기능입니다.</p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2012-2023 Microsoft<br>Licensed under the Apache License, Version 2.0.<br>\n    <a href=\"https://www.typescriptlang.org/ko/docs/handbook/variable-declarations.html\" class=\"_attribution-link\">https://www.typescriptlang.org/ko/docs/handbook/variable-declarations.html</a>\n  </p>\n</div>\n","2/functions":"<h1>More on Functions</h1>\n<p>지역 함수이건, 다른 모듈에서 불러온 함수이건, 어떤 클래스의 메서드이건, 함수는 어느 어플리케이션에서도 기초적인 구성 요소의 역할을 합니다. 함수는 값입니다. 그리고 다른 값처럼, TypeScript에서는 함수들이 호출될 수 있는 방법을 서술하는 방법이 많이 있습니다. 함수를 설명하는 타입들을 작성하는 방법들을 알아봅시다.</p> <h2 id=\"함수-타입-표현식\" style=\"position:relative;\">함수 타입 표현식</h2> <p>함수를 설명하는 가장 간단한 방법은 <em>함수 타입 표현식</em> 입니다. 이 타입은 화살표 함수와 문법적으로 유사합니다.</p> <pre data-language=\"ts\">function greeter(fn: (a: string) =&gt; void) {\n  fn(\"Hello, World\");\n}\n \nfunction printToConsole(s: string) {\n  console.log(s);\n}\n \ngreeter(printToConsole);</pre> <p><code>(a: string) =&gt; void</code> 라는 문법은 “문자열 타입 <code>a</code>를 하나의 매개변수로 가지고 반환값이 없는 함수”를 의미합니다. 함수 선언처럼, 매개변수의 타입이 지정되지 않으면, 암묵적으로 <code>any</code>가 됩니다.</p> <blockquote> <p>매개변수 이름이 <strong>필수</strong> 라는것을 명심하십시오. 함수 타입 <code>(string) =&gt; void</code>는 ”<code>any</code> 타입을 가진 <code>string</code>이라는 이름의 매개변수를 가진 함수를 뜻합니다!</p> </blockquote> <p>물론 타입 별칭을 사용해서 함수의 타입에 이름을 붙일 수 있습니다.</p> <pre data-language=\"ts\">type GreetFunction = (a: string) =&gt; void;\nfunction greeter(fn: GreetFunction) {\n  // ...\n}</pre> <h2 id=\"호출-시그니처\" style=\"position:relative;\">호출 시그니처</h2> <p>JavaScript에서, 함수들은 호출이 가능할 뿐만 아니라, 프로퍼티도 가질 수 있습니다. 하지만, 함수 타입 표현식 문법은 프로퍼티를 정의하는 것을 허락하지 않습니다. 만약 우리가 호출 가능하면서 프로퍼티를 가진 무언가를 설명하려고 하면, 객체 타입에 <em>호출 시그니처</em> 를 사용하여 표현할 수 있습니다.</p> <pre data-language=\"ts\">type DescribableFunction = {\n  description: string;\n  (someArg: number): boolean;\n};\nfunction doSomething(fn: DescribableFunction) {\n  console.log(fn.description + \" returned \" + fn(6));\n}</pre> <p>이 문법은 함수 타입 표현식과 다릅니다. 매개변수 타입과 반환값의 타입 사이에 <code>=&gt;</code>가 아닌 <code>:</code>를 사용해야 합니다.</p> <h2 id=\"구성-시그니처\" style=\"position:relative;\">구성 시그니처</h2> <p>JavaScript 함수는 <code>new</code>연산자를 통해서도 호출 될 수 있습니다. TypeScript는 이런 것들이 주로 새로운 객체를 생성하는데 사용되기 때문에 <em>생성자</em> 로 간주합니다. 여러분은 호출 시그니처 앞에 <code>new</code> 키워드를 붙임으로서, <em>구성 시그니처</em>를 작성할 수 있습니다.</p> <pre data-language=\"ts\">type SomeConstructor = {\n  new (s: string): SomeObject;\n};\nfunction fn(ctor: SomeConstructor) {\n  return new ctor(\"hello\");\n}</pre> <p>JavaScript의 <code>Date</code> 객체와 같은 몇몇 객체는 <code>new</code>가 있든 없든 호출될 수 있습니다. 여러분은 호출 시그니처와 구성 시그니처를 임의로 같은 타입에서 결합시킬 수 있습니다.</p> <pre data-language=\"ts\">interface CallOrConstruct {\n  new (s: string): Date;\n  (n?: number): number;\n}</pre> <h2 id=\"제네릭-함수\" style=\"position:relative;\">제네릭 함수</h2> <p>입력 값이 출력 값의 타입과 관련이 있거나, 두 입력값의 타입이 서로 관련이 있는 형태의 함수를 작성하는 것은 흔히 일어나는 일입니다. 잠시 배열의 첫 번째 원소를 반환하는 함수를 생각해 봅시다.</p> <pre data-language=\"ts\">function firstElement(arr: any[]) {\n  return arr[0];\n}</pre> <p>함수는 제 역할을 하지만, 아쉽게도 반환 타입이 <code>any</code> 입니다. 함수가 배열 원소의 타입을 반환한다면 더 나을 것 같습니다.</p> <p>TypeScript에서, <em>제네릭</em> 문법이 두 값 사이의 상관관계를 표현하기 위해서 사용됩니다. 우리는 함수 시그니처에서 <em>타입 매개변수</em>를 선언함으로서 그런 표현을 할 수 있습니다.</p> <pre data-language=\"ts\">function firstElement&lt;Type&gt;(arr: Type[]): Type | undefined {\n  return arr[0];\n}</pre> <p>타입 매개변수 <code>Type</code>을 이 함수에 선언하고, 필요한 두 곳에 사용함으로써 우리는 함수의 입력 값(배열)과 출력(반환 값) 사이에 연결고리를 만들었습니다. 이제 우리가 이 함수를 호출할 때, 더 명확한 타입을 얻을 수 있습니다.</p> <pre data-language=\"ts\">// s는 \"string\" 타입\nconst s = firstElement([\"a\", \"b\", \"c\"]);\n// n은 \"number\" 타입\nconst n = firstElement([1, 2, 3]);\n// u는 \"undefined\" 타입\nconst u = firstElement([]);</pre> <h3 id=\"추론inference\" style=\"position:relative;\">추론(Inference)</h3> <p>이 예제에서 우리는 <code>Type</code>을 특정하지 않았음에 주목하세요. 여기서 타입은 <em>추론되었습니다</em> 즉 TypeScript에 의해서 자동적으로 선택된 것입니다.</p> <p>우리는 여러 개의 타입 매개변수도 사용할 수 있습니다. 예를 들어서, <code>map</code>의 스탠드얼론 버전은 아래와 같을 것 입니다.</p> <pre data-language=\"ts\">function map&lt;Input, Output&gt;(arr: Input[], func: (arg: Input) =&gt; Output): Output[] {\n  return arr.map(func);\n}\n \n// 매개변수 'n'의 타입은 'string' 입니다.\n// 'parsed'는 number[] 타입을 하고 있습니다.\nconst parsed = map([\"1\", \"2\", \"3\"], (n) =&gt; parseInt(n));</pre> <p>이 예제에서 TypeScript는 <code>Input</code> 타입과(입력으로 주어진 <code>string</code> 배열로부터) <code>Output</code>타입을 함수 표현식의 반환 값(<code>number</code>)를 통해서 추론할 수 있는 점을 눈여겨보십시오.</p> <h3 id=\"타입-제한-조건\" style=\"position:relative;\">타입 제한 조건</h3> <p>우리는 <em>모든</em> 타입에 대해서 동작하는 제네릭 함수들을 작성하였습니다. 가끔, 우리는 두 값을 연관시키기 원하지만 특정한 값들의 부분집합에 한해서만 동작하기를 원할 때가 있습니다. 이러한 경우에 우리는 <em>타입 제한 조건</em>을 사용하여, 타입 매개변수가 받아들일 수 있는 타입들을 제한할 수 있습니다.</p> <p>두 값 중에 더 긴 것을 반환하는 함수를 작성해 봅시다. 이 작업을 위해, number인 <code>length</code> 프로퍼티가 필요합니다. <code>extends</code>절을 이용해서 타입 매개변수를 그 타입으로 <em>제한</em> 할 수 있습니다.</p> <pre data-language=\"ts\">function longest&lt;Type extends { length: number }&gt;(a: Type, b: Type) {\n  if (a.length &gt;= b.length) {\n    return a;\n  } else {\n    return b;\n  }\n}\n \n// longerArray 의 타입은 'number[]' 입니다'\nconst longerArray = longest([1, 2], [1, 2, 3]);\n// longerString 의 타입은 'alice' | 'bob' 입니다.\nconst longerString = longest(\"alice\", \"bob\");\n// 에러! Number에는 'length' 프로퍼티가 없습니다.\nconst notOK = longest(10, 100);</pre> <p>이 예시에서는 몇 가지 흥미로운 점에 주목해야 합니다. 우리는 TypeScript가 <code>longest</code>의 반환 타입을 <em>추론</em> 하도록 허용했습니다. 반환 타입 추론은 제네릭 함수에서도 작동합니다.</p> <p>우리가 <code>Type</code>을 <code>{ length: number }</code>로 제한했기에, 우리는 <code>a</code>와 <code>b</code> 매개변수에 대해서 <code>.length</code> 프로퍼티에 접근할 수 있었습니다. 타입 제한이 없다면, 이러한 값들이 length 프로퍼티를 가지지 않는 다른 타입일 수 있기 때문에, 그 프로퍼티에 접근 할 수 없었을 것입니다.</p> <p><code>longerArray</code>와 <code>longerString</code>의 타입은 인수를 기반으로 추론되었습니다. 제네릭은 두 개 이상의 값을 같은 타입으로 연관 짓는 것이라는 사실을 기억해야 합니다!</p> <p>결국 우리가 원하는 대로 <code>longest(10,100)</code>은 <code>number</code>타입이 <code>.length</code> 프로퍼티를 가지고 있지 않았기 때문에 호출이 거부된 것을 볼 수 있습니다.</p> <h3 id=\"제한된-값으로-작업하기\" style=\"position:relative;\">제한된 값으로 작업하기</h3> <p>다음은 제네릭 타입 제약 조건을 사용할 때, 흔히 범할 수 있는 실수입니다.</p> <pre data-language=\"ts\">function minimumLength&lt;Type extends { length: number }&gt;(\n  obj: Type,\n  minimum: number\n): Type {\n  if (obj.length &gt;= minimum) {\n    return obj;\n  } else {\n    return { length: minimum };\n  }\n}</pre> <p>이 함수는 문제가 없는 것처럼 보입니다. <code>Type</code>은 <code>{ length: number }</code>로 제한되어 있고, 함수는 <code>Type</code>이나 저 제약조건을 만족하는 값을 반환합니다. 문제는 이 함수가 제약사항을 만족하는 <em>어떤</em> 객체가 아닌, 입력된 <em>어떤</em> 객체를 반환한다는 점입니다. 만약 이 코드가 유효하다면, 여러분들은 확실히 동작하지 않을 아래의 코드를 작성할 수 있을 것입니다.</p> <pre data-language=\"ts\">// 'arr' gets value { length: 6 }\nconst arr = minimumLength([1, 2, 3], 6);\n// 여기서 배열은 'slice' 메서드를 가지고 있지만\n// 반환된 객체는 그렇지 않기에 에러가 발생합니다!\nconsole.log(arr.slice(0));</pre> <h3 id=\"타입-인수를-명시하기\" style=\"position:relative;\">타입 인수를 명시하기</h3> <p>TypeScript는 제네릭 호출에서 의도된 타입을 대체로 추론해 내지만, 항상 그렇지는 않습니다. 예를 들어서, 여러분들이 두 배열을 결합하는 함수를 하나 작성했다고 합시다.</p> <pre data-language=\"ts\">function combine&lt;Type&gt;(arr1: Type[], arr2: Type[]): Type[] {\n  return arr1.concat(arr2);\n}</pre> <p>일반적으로 짝이 맞지 않는 배열과 함께 해당 함수를 부르는 것은 잘못된 것일 것입니다.</p> <pre data-language=\"ts\">const arr = combine([1, 2, 3], [\"hello\"]);</pre> <p>만약 여러분이 이런 것을 의도하셨다면, 여러분은 수동으로 <code>Type</code>을 명시해야 합니다.</p> <pre data-language=\"ts\">const arr = combine&lt;string | number&gt;([1, 2, 3], [\"hello\"]);</pre> <h3 id=\"좋은-제네릭-함수를-작성하기-위한-가이드라인\" style=\"position:relative;\">좋은 제네릭 함수를 작성하기 위한 가이드라인</h3> <p>제네릭 함수를 작성하는 것은 재미있고, 타입 매개 변수를 사용하는 것이 쉬울 수 있습니다. 너무 많은 타입 매개변수나 제한 조건을 꼭 필요하지 않은 곳에 사용하는 것은 추론을 잘하지 못하게 해서 여러분의 함수 호출자를 불만스럽게 만들 수 있습니다.</p> <h4 id=\"타입-매개변수를-누르기\" style=\"position:relative;\">타입 매개변수를 누르기</h4> <p>여기 비슷해 보이는 두 함수를 쓰는 방법이 있습니다.</p> <pre data-language=\"ts\">function firstElement1&lt;Type&gt;(arr: Type[]) {\n  return arr[0];\n}\n \nfunction firstElement2&lt;Type extends any[]&gt;(arr: Type) {\n  return arr[0];\n}\n \n// a: number (good)\nconst a = firstElement1([1, 2, 3]);\n// b: any (bad)\nconst b = firstElement2([1, 2, 3]);</pre> <p>처음 보기에는 동일하게 보일 수 있습니다만, <code>firstElement1</code>이 이 함수를 작성하는데 더 좋은 방법입니다. 이 함수의 추론된 반환 타입은 <code>Type</code> 입니다만, <code>firstElement2</code>의 추론된 반환 타입은 TypeScript가 호출 중에 타입을 해석하기 위해서 “기다리기” 보다 호출 시점에 <code>arr[0]</code> 표현식을 타입 제한 조건을 이용해서 해석하기 때문에 <code>any</code>가 됩니다.</p> <blockquote> <p><strong>규칙</strong>: 가능하다면, 타입 매개변수를 제약하기보다는 타입 매개변수 그 자체를 사용하십시오.</p> </blockquote> <h4 id=\"더-적은-타입-매개변수를-사용하기\" style=\"position:relative;\">더 적은 타입 매개변수를 사용하기</h4> <p>다음은 유사한 함수의 또 다른 쌍입니다.</p> <pre data-language=\"ts\">function filter1&lt;Type&gt;(arr: Type[], func: (arg: Type) =&gt; boolean): Type[] {\n  return arr.filter(func);\n}\n \nfunction filter2&lt;Type, Func extends (arg: Type) =&gt; boolean&gt;(\n  arr: Type[],\n  func: Func\n): Type[] {\n  return arr.filter(func);\n}</pre> <p>우리는 <em>두 값을 연관시키지 않는</em> 타입 매개변수 <code>Func</code>를 만들었습니다. 이는 타입 인수를 원하는 호출자가 아무 이유 없이 추가 타입 인수를 제공해야 하기 때문에, 상당히 좋지 않습니다. <code>Func</code>는 함수를 더 읽고 이해하기 어렵게 만들 뿐이지, 아무것도 하지 않습니다!</p> <blockquote> <p><strong>규칙</strong>: 항상 가능하다면 타입 매개변수를 최소로 사용하십시오</p> </blockquote> <h4 id=\"타입-매개변수는-두-번-나타나야-합니다\" style=\"position:relative;\">타입 매개변수는 두 번 나타나야 합니다.</h4> <p>가끔 우리는 함수가 제네릭이 필요 없을 수 있다는 사실을 간과합니다.</p> <pre data-language=\"ts\">function greet&lt;Str extends string&gt;(s: Str) {\n  console.log(\"Hello, \" + s);\n}\n \ngreet(\"world\");</pre> <p>우리는 간단한 버전을 쉽게 작성할 수 있었을 것입니다.</p> <pre data-language=\"ts\">function greet(s: string) {\n  console.log(\"Hello, \" + s);\n}</pre> <p>타입 매개변수는 <em>여러 값의 타입을 연관</em>시키는 용도로 사용함을 기억해 주십시오. 만약 타입 매개변수가 함수 시그니처에서 한 번만 사용되었다면, 어떤 것도 연관시키지 않고 있는 것입니다.</p> <blockquote> <p><strong>규칙</strong>: 만약 타입 매개변수가 한 곳에서만 나온다면, 정말로 필요한 건지 다시 생각해 보십시오.</p> </blockquote> <h2 id=\"선택적-매개변수\" style=\"position:relative;\">선택적 매개변수</h2> <p>JavaScript에서 쓰이는 함수는 종종 가변적인 수의 인자들을 사용합니다. 예를 들어서 <code>number</code>의 <code>toFixed</code> 메서드는 선택적으로 자릿수를 사용합니다.</p> <pre data-language=\"ts\">function f(n: number) {\n  console.log(n.toFixed()); // 0 arguments\n  console.log(n.toFixed(3)); // 1 argument\n}</pre> <p>TypeScript에서 우리는 매개변수를 <code>?</code>로 표시함으로 <em>선택적</em>으로 만들 수 있습니다.</p> <pre data-language=\"ts\">function f(x?: number) {\n  // ...\n}\nf(); // OK\nf(10); // OK</pre> <p>매개변수의 타입이 <code>number</code>로 지정되었지만, JavaScript에서 명시되지 않은 매개변수는 <code>undefined</code>가 되기 때문에, <code>x</code> 매개변수는 실질적으로 <code>number | undefined</code> 타입이 될 것입니다.</p> <p>여러분은 매개변수 <em>기본값</em>또한 제공할 수 있습니다.</p> <pre data-language=\"ts\">function f(x = 10) {\n  // ...\n}</pre> <p>이제 <code>f</code>의 본문 내에서 모든 <code>undefined</code> 인수가 <code>10</code>으로 대체되기 때문에 <code>x</code>의 타입은 <code>number</code>가 될 것입니다. 매개변수가 선택적일 때, 호출자는 <code>undefined</code>를 넘김으로써, “누락된” 인수를 흉내 낼 수 있습니다.</p> <pre data-language=\"ts\">declare function f(x?: number): void;\n// cut\n// All OK\nf();\nf(10);\nf(undefined);</pre> <h3 id=\"콜백-함수에서의-선택적-매개변수\" style=\"position:relative;\">콜백 함수에서의 선택적 매개변수</h3> <p>선택적 매개변수 및 함수 타입 표현식에 대해 알게 되면, 콜백을 호출하는 함수를 작성할 때 아래와 같은 실수를 범하기 쉽습니다.</p> <pre data-language=\"ts\">function myForEach(arr: any[], callback: (arg: any, index?: number) =&gt; void) {\n  for (let i = 0; i &lt; arr.length; i++) {\n    callback(arr[i], i);\n  }\n}</pre> <p>사람들이 <code>index?</code>를 선택적 매개변수로 사용하기 위해 작성할 때 보통 의도하는 것은 두 호출 모두 유효하기를 바라는 것입니다.</p> <pre data-language=\"ts\">myForEach([1, 2, 3], (a) =&gt; console.log(a));\nmyForEach([1, 2, 3], (a, i) =&gt; console.log(a, i));</pre> <p><em>실제로</em> 이것이 의미하는 바는 <em><code>callback</code>이 하나의 인수로 호출될 수 있음</em> 입니다. 다시 말해, 이전의 함수 정의는 구현이 다음과 같을 수도 있다고 하는 것과 같습니다.</p> <pre data-language=\"ts\">function myForEach(arr: any[], callback: (arg: any, index?: number) =&gt; void) {\n  for (let i = 0; i &lt; arr.length; i++) {\n    // 오늘은 index를 제공하고 싶지 않아\n    callback(arr[i]);\n  }\n}</pre> <p>결국, TypeScript는 이러한 의미를 강제하여 실제로 일어나지 않을 에러를 발생시킵니다.</p>  <pre data-language=\"ts\">myForEach([1, 2, 3], (a, i) =&gt; {\n  console.log(i.toFixed());\n});</pre> <p>JavaScript에서, 매개변수로 지정된 것보다 많은 인수를 전달하여 호출되면, 남은 인수들은 단순히 무시됩니다. TypeScript도 같은 방식으로 동작합니다. (같은 타입을 가진) 매개변수가 더 적은 함수는 더 많은 매개변수가 있는 함수를 대체할 수 있습니다.</p> <blockquote> <p>콜백에 대한 함수 타입을 작성할 때, 해당 인수 없이 <em>호출할</em> 의도가 없는 한, <em>절대로</em> 선택적 매개변수를 사용하지 마십시오.</p> </blockquote> <h2 id=\"함수-오버로드\" style=\"position:relative;\">함수 오버로드</h2> <p>몇몇 JavaScript 함수는 다양한 인수의 개수, 타입을 통해서 호출될 수 있습니다. 예를 들어서, 여러분은 <code>Date</code>를 생성하고, 타임스탬프 하나(인자 한 개)를 받을 수도 있고, 월/일/연도 형식(인자 3개)를 받는 함수를 만들 수 있을 것입니다.</p> <p>TypeScript에서는, 우리는 다른 방법으로 호출될 수 있는 함수를 <em>오버로드 시그니처</em>를 작성함으로 묘사할 수 있습니다. 그러기 위해서, 함수 시그니처 몇 개(보통 2개 이상)을 적은 다음, 함수 본문을 작성하면 됩니다.</p> <pre data-language=\"ts\">function makeDate(timestamp: number): Date;\nfunction makeDate(m: number, d: number, y: number): Date;\nfunction makeDate(mOrTimestamp: number, d?: number, y?: number): Date {\n  if (d !== undefined &amp;&amp; y !== undefined) {\n    return new Date(y, mOrTimestamp, d);\n  } else {\n    return new Date(mOrTimestamp);\n  }\n}\nconst d1 = makeDate(12345678);\nconst d2 = makeDate(5, 5, 5);\nconst d3 = makeDate(1, 3);</pre> <p>이 예시에서, 우리는 두 개의 오버로드를 작성하였습니다. 하나는 한 개의 인수를 받고, 다른 하나는 인수 세 개를 받습니다. 처음에 쓴 이 두 시그니처들을 <em>오버로드 시그니처</em> 라고 합니다.</p> <p>그리고, 우리는 호환 가능한 시그니처와 함께 함수 구현을 작성하였습니다. 함수는 <em>구현</em> 시그니처를 가지고 있습니다만, 이 시그니처는 직접 호출될 수 없습니다. 우리가 필수적인 매개변수 뒤에 두 개의 선택적 매개변수를 작성하였지만, 우리는 두 개의 매개변수 만으로는 이 함수를 호출할 수 없습니다!</p> <h3 id=\"오버로드-시그니처와-구현-시그니처\" style=\"position:relative;\">오버로드 시그니처와 구현 시그니처</h3> <p>이것은 일반적인 혼동의 원인입니다. 사람들은 종종 아래처럼 코드를 작성하고, 왜 에러가 있는지 이해하지 못하는 경우가 있습니다.</p> <pre data-language=\"ts\">function fn(x: string): void;\nfunction fn() {\n  // ...\n}\n// 0개의 인자로 호출하기를 예상했음\nfn();</pre> <p>다시 한번 강조하지만, 함수 본문을 작성하기 위해 사용된 시그니처는 외부에서 “보이지 않습니다”.</p> <blockquote> <p><em>구현</em>의 시그니처는 외부에서 보이지 않습니다. 오버로드된 함수를 작성할 때, 여러분들은 <em>두 개 이상</em>의 시그니처를 함수 구현 위에 작성해야 합니다.</p> </blockquote> <p>또한 구현 시그니처는 오버로드된 시그니처와 <em>호환되어야</em> 합니다. 예를 들어, 아래의 함수들은 구현 시그니처가 오버로드들과 올바르게 일치하지 않기 때문에 오류가 있습니다.</p> <pre data-language=\"ts\">function fn(x: boolean): void;\n// 인수 타입이 옳지 않습니다.\nfunction fn(x: string): void;\nfunction fn(x: boolean) {}</pre> <pre data-language=\"ts\">function fn(x: string): string;\n// 반환 타입이 옳지 않습니다.\nfunction fn(x: number): boolean;\nfunction fn(x: string | number) {\n  return \"oops\";\n}</pre> <h3 id=\"좋은-오버로드-작성하기\" style=\"position:relative;\">좋은 오버로드 작성하기</h3> <p>제네릭처럼, 함수 오버로드를 작성할 때 따라야 할 몇몇 가이드라인이 있습니다. 다음의 규칙을 따르는 것은 여러분의 함수들을 부르기 쉽고, 이해하기 쉽고, 구현하기 쉽게 만들어 줄 것입니다.</p> <p>문자열 혹은 배열의 길이를 반환하는 함수를 생각해 봅시다.</p> <pre data-language=\"ts\">function len(s: string): number;\nfunction len(arr: any[]): number;\nfunction len(x: any) {\n  return x.length;\n}</pre> <p>이 함수는 괜찮습니다. 우리는 이 함수를 문자열이나 배열을 통해서 호출할 수 있습니다. 하지만, TypeScript는 하나의 오버로드를 통해서만 함수를 해석하기에, 우리는 이 함수를 문자열 <em>또는</em> 배열이 될 수 있는 값을 통해서 호출할 수 없습니다.</p> <pre data-language=\"ts\">len(\"\"); // OK\nlen([0]); // OK\nlen(Math.random() &gt; 0.5 ? \"hello\" : [0]);</pre> <p>두 오버로드 모두 같은 인수 개수와, 같은 반환 타입을 가지기 때문에, 우리는 오버로드 되지 않은 함수의 형태로 다음과 같이 작성할 수 있습니다.</p> <pre data-language=\"ts\">function len(x: any[] | string) {\n  return x.length;\n}</pre> <p>훨씬 낫습니다! 호출자는 이 함수를 두 가지 값 중 하나를 이용하여 호출할 수 있으며, 추가적으로 정확한 구현 시그니처를 찾을 필요도 없어졌습니다.</p> <blockquote> <p>가능하다면 오버로드 대신 유니온 타입을 사용하십시오</p> </blockquote> <h3 id=\"함수-내에서-this-선언하기\" style=\"position:relative;\">함수 내에서 <code>this</code> 선언하기</h3> <p>TypeScript는 함수 안에서의 <code>this</code>가 무엇이 되어야 할지, 아래의 예시처럼 코드 흐름 분석을 통해서 추론합니다.</p> <pre data-language=\"ts\">const user = {\n  id: 123,\n \n  admin: false,\n  becomeAdmin: function () {\n    this.admin = true;\n  },\n};</pre> <p>TypeScript는 함수 <code>user.becomeAdmin</code>이 외부 객체 <code>user</code>에 상응하는 <code>this</code>를 가지고 있다고 이해합니다. 보통 이걸로 충분할 수 있습니다만, 여러분들은 <code>this</code>객체가 표현하는 것에 대해서 더 많은 통제가 필요한 경우가 많을 겁니다. JavaScript 명세에서는 <code>this</code>라는 이름의 매개변수를 가질 수 없다고 나와 있기에, TypeScript는 해당 문법 공간을 함수 본문에서 <code>this</code>의 타입을 정의하는 데 사용하도록 허락해 줍니다.</p> <pre data-language=\"ts\">interface DB {\n  filterUsers(filter: (this: User) =&gt; boolean): User[];\n}\n \nconst db = getDB();\nconst admins = db.filterUsers(function (this: User) {\n  return this.admin;\n});</pre> <p>이 패턴은 일반적으로 다른 객체가 함수를 호출할 때 제어하는 콜백 스타일 API에서 흔히 사용됩니다. 이런 효과를 얻기 위해서는 화살표 함수가 아닌 <code>function</code> 키워드를 사용해야 합니다.</p> <pre data-language=\"ts\">interface DB {\n  filterUsers(filter: (this: User) =&gt; boolean): User[];\n}\n \nconst db = getDB();\nconst admins = db.filterUsers(() =&gt; this.admin);</pre> <h2 id=\"알아야-할-다른-타입\" style=\"position:relative;\">알아야 할 다른 타입</h2> <p>함수 타입에 대해서 작업을 할 때, 자주 나타나는 몇 가지 추가 타입들이 더 있습니다. 모든 타입처럼, 이 타입들을 어디서나 사용하실 수 있습니다만, 이 타입들은 특별히 함수라는 맥락에 관련이 깊습니다.</p> <h3 id=\"void\" style=\"position:relative;\"><code>void</code></h3> <p><code>void</code>는 값을 반환하지 않는 함수의 반환 값을 의미합니다. 함수에 <code>return</code>문이 없거나, 명시적으로 값을 반환하지 않을 때, 추론되는 타입입니다.</p> <pre data-language=\"ts\">// 추론된 반환 타입은 void 입니다.\nfunction noop() {\n  return;\n}</pre> <p>JavaScript에서는, 아무것도 반환하지 않는 함수는 암묵적으로 <code>undefined</code> 값을 반환합니다. 하지만 TypeScript에서 <code>void</code>와 <code>undefined</code>는 같은 것으로 간주되지 않습니다. 이 장의 끝에서 다 자세한 내용들을 다루도록 하겠습니다.</p> <blockquote> <p><code>void</code>는 <code>undefined</code>과 같지 않습니다.</p> </blockquote> <h3 id=\"object\" style=\"position:relative;\"><code>object</code></h3> <p>특별한 타입 <code>object</code>는 원시 값(<code>string</code>, <code>number</code>, <code>bigint</code>, <code>boolean</code>, <code>symbol</code>, <code>null</code>, <code>undefined</code>)이 아닌 모든 값을 지칭합니다. 이것은 <em>빈 객체 타입</em> <code>{ }</code>와는 다르고, 전역 타입 <code>Object</code>와도 다릅니다. 아마도 여러분은 <code>Object</code>를 사용할 일이 없을 것입니다.</p> <blockquote> <p><code>object</code>는 <code>Object</code>가 아닙니다.. <strong>항상</strong> <code>object</code>를 사용하십시오!</p> </blockquote> <p>JavaScript에서 함수 값은 객체입니다. 프로퍼티가 있고, 프로토타입 체인에 <code>Object.prototype</code>가 있고, <code>instanceof Object</code>이면서, <code>Object.keys</code>를 호출할 수 있고, 기타 등등이 있습니다. 이러한 이유로, TypeScript에서 함수 타입은 <code>object</code>로 간주됩니다.</p> <h3 id=\"unknown\" style=\"position:relative;\"><code>unknown</code></h3> <p><code>unknown</code> 타입은 <em>모든 값</em>을 나타냅니다. <code>any</code> 타입과 유사합니다만, <code>unknown</code> 타입에 어떤 것을 대입하는 것이 유효하지 않기 때문에 더 안전합니다.</p> <pre data-language=\"ts\">function f1(a: any) {\n  a.b(); // OK\n}\nfunction f2(a: unknown) {\n  a.b();\n}</pre> <p>이는 <code>any</code> 형태의 값을 함수 본문에 사용하지 않고도, 아무 값이나 받는 함수를 표현할 수 있기 때문에, 함수 타입을 설명하는 데에 유용하게 쓰입니다.</p> <p>반대로, 여러분들은 unknown 타입의 값을 반환하는 함수를 표현할 수 있습니다.</p> <pre data-language=\"ts\">function safeParse(s: string): unknown {\n  return JSON.parse(s);\n}\n \n// 'obj'를 사용할 때 조심해야 합니다!\nconst obj = safeParse(someRandomString);</pre> <h3 id=\"never\" style=\"position:relative;\"><code>never</code></h3> <p>어떤 함수는 <em>결코(never)</em> 값을 반환하지 않습니다</p> <pre data-language=\"ts\">function fail(msg: string): never {\n  throw new Error(msg);\n}</pre> <p><code>never</code> 타입은 결코 관측될 수 없는 값을 의미합니다. 반환 타입에서는, 해당 함수가 예외를 발생시키거나, 프로그램 실행을 종료함을 의미합니다.</p> <p><code>never</code>은 TypeScript가 유니온에 아무것도 남아있지 않다고 판단했을 때 또한 나타납니다.</p> <pre data-language=\"ts\">function fn(x: string | number) {\n  if (typeof x === \"string\") {\n    // do something\n  } else if (typeof x === \"number\") {\n    // do something else\n  } else {\n    x; // 'never' 타입이 됨!\n  }\n}</pre> <h3 id=\"function\" style=\"position:relative;\"><code>Function</code></h3> <p>전역 타입 <code>Function</code>은 <code>bind</code>, <code>call</code>, <code>apply</code> 그리고 JavaScript 함수 값에 있는 다른 프로퍼티를 설명하는 데에 사용됩니다. 또한 여기에는 <code>Function</code>타입의 값은 언제나 호출될 수 있다는 값을 가지며, 이러한 호출은 <code>any</code>를 반환합니다.</p> <pre data-language=\"ts\">function doSomething(f: Function) {\n  return f(1, 2, 3);\n}</pre> <p>이는 <em>타입되지 않은 함수 호출</em> 이며, 안전하지 않은 <code>any</code> 타입을 반환하기에 일반적으로 피하는 것이 가장 좋습니다.</p> <p>만약 여러분이 임의의 함수를 허용해야 하지만, 호출할 생각이 없다면 <code>() =&gt; void</code> 타입이 일반적으로 더 안전합니다.</p> <h2 id=\"나머지-매개변수와-인수\" style=\"position:relative;\">나머지 매개변수와 인수</h2> <blockquote class=\"bg-reading\"> <p>배경지식 읽기:<br> <a href=\"https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Functions/rest_parameters\">나머지 매개변수(Rest Parameter)</a><br> <a href=\"https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Operators/Spread_syntax\">전개 구문(Spread Syntax)</a><br> </p> </blockquote> <h3 id=\"나머지-매개변수rest-parameter\" style=\"position:relative;\">나머지 매개변수(Rest Parameter)</h3> <p>선택적 매개변수와 오버로드를 사용하여 다양한 정해진 인수들을 받아들일 수 있지만, 우리는 <em>정해지지 않은</em> 수의 인수를 받아들이는 함수를 <em>나머지 매개변수</em>를 이용하여 정의할 수 있습니다.</p> <p>나머지 매개변수는 다른 모든 매개변수 뒤에 나타나며, <code>...</code> 구문을 사용합니다.</p> <pre data-language=\"ts\">function multiply(n: number, ...m: number[]) {\n  return m.map((x) =&gt; n * x);\n}\n// 'a' gets value [10, 20, 30, 40]\nconst a = multiply(10, 1, 2, 3, 4);</pre> <p>TypeScript에서는, 이러한 매개변수에 대한 타입 표기는 암묵적으로 <code>any</code>가 아닌 <code>any[]</code>를 사용하며, 타입 표현식은 <code>Array&lt;T&gt;</code> 또는 <code>T[]</code> 또는 튜플 타입(나중에 배울 것입니다)으로 표현해야 합니다.</p> <h3 id=\"나머지-인수rest-argument\" style=\"position:relative;\">나머지 인수(Rest Argument)</h3> <p>반대로 우리는 전개 구문을 사용하여 배열에서 제공되는 인수의 개수를 <em>제공</em>할 수 있습니다. 예를 들어, 배열의 <code>push</code> 메서드는 인수를 몇 개든 받을 수 있습니다.</p> <pre data-language=\"ts\">const arr1 = [1, 2, 3];\nconst arr2 = [4, 5, 6];\narr1.push(...arr2);</pre> <p>일반적으로 TypeScript는 배열이 불변하다고 간주하지 않습니다. 이로 인해 다음과 같은 놀라운 동작이 발생할 수 있습니다.</p> <pre data-language=\"ts\">// 추론된 타입은 0개 이상의 숫자를 가지는 배열인 number[]\n// 명시적으로 2개의 숫자를 가지는 배열로 간주되지 않습니다\nconst args = [8, 5];\nconst angle = Math.atan2(...args);</pre> <p>이러한 상황의 최선의 해결책은 코드에 따라서 다르지만, 일반적으로 <code>const</code> 콘텍스트가 가장 간단한 해결책입니다.</p> <pre data-language=\"ts\">// 길이가 2인 튜플로 추론됨\nconst args = [8, 5] as const;\n// OK\nconst angle = Math.atan2(...args);</pre> <p>나머지 인수를 사용하는 것은 오래된 런타임을 대상으로 할 때, <a href=\"https://www.typescriptlang.org/tsconfig#downlevelIteration\"><code>downlevelIteration</code></a>을 필요로 할 수 있습니다.</p>  <h2 id=\"매개변수-구조-분해parameter-destructing\" style=\"position:relative;\">매개변수 구조 분해(Parameter Destructing)</h2> <blockquote class=\"bg-reading\"> <p>배경지식 읽기:<br> <a href=\"https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment\">구조분해 할당</a><br> </p> </blockquote> <p>매개변수 분해를 사용하여 인수로 제공된 객체를 함수 본문에서 하나 이상의 지역 변수로 편리하게 언팩 할 수 있습니다. JavaScript에서는 아래의 형태처럼 생겼습니다.</p> <pre data-language=\"js\">function sum({ a, b, c }) {\n  console.log(a + b + c);\n}\nsum({ a: 10, b: 3, c: 9 });</pre> <p>객체를 위한 타입 표기는 분해 구문 뒤에 위치하게 됩니다.</p> <pre data-language=\"ts\">function sum({ a, b, c }: { a: number; b: number; c: number }) {\n  console.log(a + b + c);\n}</pre> <p>약간 장황하게 느껴질 수 있지만, 여기에서도 이름 붙은 타입을 사용할 수 있습니다.</p> <pre data-language=\"ts\">// 이전 예제와 동일\ntype ABC = { a: number; b: number; c: number };\nfunction sum({ a, b, c }: ABC) {\n  console.log(a + b + c);\n}</pre> <h2 id=\"함수의-할당가능성\" style=\"position:relative;\">함수의 할당가능성</h2> <h3 id=\"void-반환-타입\" style=\"position:relative;\">\n<code>void</code> 반환 타입</h3> <p>함수의 <code>void</code> 반환 타입은 몇몇 일반적이지는 않지만 예측할 수 있는 동작을 발생시킬 수 있습니다.</p> <p><code>void</code> 반환 타입으로의 문맥적 타이핑은 함수를 아무것도 반환하지 <strong>않도록</strong> 강제하지 <strong>않습니다</strong>.이를 설명하는 또 다른 방법은, <code>void</code> 반환 타입을 가지는 문맥적 함수 타입(<code>type vf = () =&gt; void</code>)가 구현되었을 때, <em>아무값</em>이나 반환될 수 있지만, 무시됩니다.</p> <p>그러므로 후술할 타입 <code>() =&gt; void</code>의 구현들은 모두 유효합니다.</p> <pre data-language=\"ts\">type voidFunc = () =&gt; void;\n \nconst f1: voidFunc = () =&gt; {\n  return true;\n};\n \nconst f2: voidFunc = () =&gt; true;\n \nconst f3: voidFunc = function () {\n  return true;\n};</pre> <p>그리고 이러한 함수의 반환값이 다른 변수에 할당될 때, 이들은 여전히 <code>void</code>타입을 유지할 것입니다.</p> <pre data-language=\"ts\">const v1 = f1();\n \nconst v2 = f2();\n \nconst v3 = f3();</pre> <p>이러한 동작이 존재하기에, <code>Array.prototype.push</code>가 number를 반환하고, <code>Array.prototype.forEach</code> 메서드가 <code>void</code> 반환 타입을 가지는 함수를 예상함에도 다음 코드는 유효할 수 있습니다.</p> <pre data-language=\"ts\">const src = [1, 2, 3];\nconst dst = [0];\n \nsrc.forEach((el) =&gt; dst.push(el));</pre> <p>유의해야 할 한 가지 다른 경우가 있습니다. 리터럴 함수 정의가 <code>void</code> 반환 값을 가지고 있다면, 그 함수는 어떠한 것도 반환해서는 <strong>안됩니다</strong>.</p> <pre data-language=\"ts\">function f2(): void {\n  // @ts-expect-error\n  return true;\n}\n \nconst f3 = function (): void {\n  // @ts-expect-error\n  return true;\n};</pre> <p><code>void</code>에 대한 더 많은 내용은 다음 문서 항목을 참조해 주십시오.</p> <ul> <li><a href=\"https://www.typescriptlang.org/docs/handbook/basic-types.html#void\">v1 handbook</a></li> <li><a href=\"https://www.typescriptlang.org/docs/handbook/2/functions.html#void\">v2 handbook</a></li> <li><a href=\"https://github.com/Microsoft/TypeScript/wiki/FAQ#why-are-functions-returning-non-void-assignable-to-function-returning-void\">FAQ - “Why are functions returning non-void assignable to function returning void?”</a></li> </ul><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2012-2023 Microsoft<br>Licensed under the Apache License, Version 2.0.<br>\n    <a href=\"https://www.typescriptlang.org/ko/docs/handbook/2/functions.html\" class=\"_attribution-link\">https://www.typescriptlang.org/ko/docs/handbook/2/functions.html</a>\n  </p>\n</div>\n","gulp":"<h1>Gulp</h1>\n<p>이 퀵 스타트 가이드는 <a href=\"http://gulpjs.com\">gulp</a>로 TypeScript를 빌드한 다음 <a href=\"http://browserify.org\">Browserify</a>, <a href=\"http://lisperator.net/uglifyjs\">uglify</a> 또는 <a href=\"https://github.com/substack/watchify\">Watchify</a>를 gulp 파이프 라인에 추가하는 방법을 알려줍니다. 또한 <a href=\"https://github.com/babel/babelify\">Babelify</a>를 사용하여 <a href=\"https://babeljs.io\">Babel</a> 기능을 추가하는 방법을 알려줍니다.</p> <p><a href=\"https://www.npmjs.com\">npm</a>과 <a href=\"https://nodejs.org\">Node.js</a>는 이미 사용하고 있다고 가정합니다.</p> <h1 id=\"작은-프로젝트-minimal-project\" style=\"position:relative;\">작은 프로젝트 (Minimal project)</h1> <p>새로운 디렉터리로 시작합시다. 당장은 <code>proj</code>라고 이름을 붙이겠지만 원하는 대로 변경할 수 있습니다.</p> <pre data-language=\"shell\">mkdir proj\ncd proj</pre> <p>시작하기 위해, 다음과 같이 프로젝트를 구조화해야 합니다:</p> <pre data-language=\"text\">proj/\n   ├─ src/\n   └─ dist/</pre> <p>TypeScript 파일은 <code>src</code> 폴더에서 시작하여 TypeScript 컴파일러를 통해 실행되고 <code>dist</code>에서 끝납니다.</p> <p>이것을 골격으로 합니다:</p> <pre data-language=\"shell\">mkdir src\nmkdir dist</pre> <h2 id=\"프로젝트-초기화-initialize-the-project\" style=\"position:relative;\">프로젝트 초기화 (Initialize the project)</h2> <p>이제 이 폴더를 npm 패키지로 바꿀 것입니다.</p> <pre data-language=\"shell\">npm init</pre> <p>일련의 알림을 받게 될 것입니다.<br> entry point를 제외하고는 기본값을 사용할 수 있습니다. entry point로 <code>./dist/main.js</code>를 사용합니다. <code>package.json</code> 파일로 돌아가서 언제든 변경할 수 있습니다.</p> <h2 id=\"의존성-설치-install-our-dependencies\" style=\"position:relative;\">의존성 설치 (Install our dependencies)</h2> <p>이제는 <code>npm install</code>을 사용하여 패키지를 설치할 수 있습니다.<br> 먼저 <code>gulp-cli</code>를 전역으로 설치하십시오 (Unix 시스템을 사용하는 경우 <code>npm install</code> 명령 앞에 <code>sudo</code>를 붙여야 할 수도 있습니다).</p> <pre data-language=\"shell\">npm install -g gulp-cli</pre> <p>그런 다음 프로젝트의 개발 의존성에 <code>typescript</code>, <code>gulp</code> 및 <code>gulp-typescript</code>를 설치하십시오.<br> <a href=\"https://www.npmjs.com/package/gulp-typescript\">Gulp-typescript</a>는 TypeScript의 gulp 플러그인입니다.</p> <pre data-language=\"shell\">npm install --save-dev typescript gulp gulp-typescript</pre> <h2 id=\"간단한-예제-작성-write-a-simple-example\" style=\"position:relative;\">간단한 예제 작성 (Write a simple example)</h2> <p>Hello World 프로그램을 작성해 보겠습니다. <code>src</code>에 <code>main.ts</code> 파일을 만듭니다 :</p> <pre data-language=\"ts\">function hello(compiler: string) {\n    console.log(`Hello from ${compiler}`);\n}\nhello(\"TypeScript\");</pre> <p><code>proj</code>이라는 프로젝트 루트에 <code>tsconfig.json</code> 파일을 생성합니다:</p> <pre data-language=\"json\">{\n    \"files\": [\n        \"src/main.ts\"\n    ],\n    \"compilerOptions\": {\n        \"noImplicitAny\": true,\n        \"target\": \"es5\"\n    }\n}</pre> <h2 id=\"gulpfilejs-생성-create-a-gulpfilejs\" style=\"position:relative;\">\n<code>gulpfile.js</code> 생성 (Create a <code>gulpfile.js</code>)</h2> <p>프로젝트 루트에 <code>gulpfile.js</code> 파일을 만듭니다:</p> <pre data-language=\"js\">var gulp = require(\"gulp\");\nvar ts = require(\"gulp-typescript\");\nvar tsProject = ts.createProject(\"tsconfig.json\");\n\ngulp.task(\"default\", function () {\n    return tsProject.src()\n        .pipe(tsProject())\n        .js.pipe(gulp.dest(\"dist\"));\n});</pre> <h2 id=\"결과-앱-테스트-test-the-resulting-app\" style=\"position:relative;\">결과 앱 테스트 (Test the resulting app)</h2> <pre data-language=\"shell\">gulp\nnode dist/main.js</pre> <p>프로그램은 “Hello from TypeScript!”를 출력해야 합니다.</p> <h1 id=\"코드에-모듈-추가-add-modules-to-the-code\" style=\"position:relative;\">코드에 모듈 추가 (Add modules to the code)</h1> <p>Browserify를 시작하기 전에 코드를 만들고 믹스에 모듈을 추가해 보겠습니다.<br> 이것은 실제 앱에서 사용하기 쉬운 구조입니다.</p> <p><code>src/greet.ts</code> 파일을 만듭니다 :</p> <pre data-language=\"ts\">export function sayHello(name: string) {\n    return `Hello from ${name}`;\n}</pre> <p>이제 <code>src/main.ts</code>의 <code>sayHello</code>를 <code>greet.ts</code>에서 import 하도록 변경합니다:</p> <pre data-language=\"ts\">import { sayHello } from \"./greet\";\n\nconsole.log(sayHello(\"TypeScript\"));</pre> <p>마지막으로 <code>src/greet.ts</code>를 <code>tsconfig.json</code>에 추가하십시오:</p> <pre data-language=\"json\">{\n    \"files\": [\n        \"src/main.ts\",\n        \"src/greet.ts\"\n    ],\n    \"compilerOptions\": {\n        \"noImplicitAny\": true,\n        \"target\": \"es5\"\n    }\n}</pre> <p><code>gulp</code>을 실행하고 Node에서 테스트하여 모듈이 작동하는지 확인하십시오:</p> <pre data-language=\"shell\">gulp\nnode dist/main.js</pre> <p>ES2015 모듈 구문을 사용했지만 TypeScript는 Node가 사용하는 CommonJS 모듈을 방출했습니다.<br> 이 튜토리얼에서는 CommonJS를 계속 사용하겠지만 options 객체에 <code>module</code>을 설정하여 이를 변경할 수 있습니다.</p> <h1 id=\"browserify\" style=\"position:relative;\">Browserify</h1> <p>이제 이 프로젝트를 Node에서 브라우저로 이동하겠습니다.<br> 이를 위해 모든 모듈을 하나의 JavaScript 파일로 번들링 하고자 합니다.<br> 다행히도 정확히 Browserify가 하는 일입니다.<br> 더 좋은 것은 노드에서 사용하는 CommonJS 모듈 시스템을 TypeScript에서 사용할 수 있다는 것입니다.<br> 즉 TypeScript와 Node 설정이 기본적으로 변경되지 않은 브라우저로 전송되는 것을 의미합니다.</p> <p>먼저 browserify, <a href=\"https://www.npmjs.com/package/tsify\">tsify</a> 및 vinyl-source-stream을 설치하십시오.<br> tsify는 gulp-typescript처럼 TypeScript 컴파일러에 접근할 수 있는 Browserify 플러그인입니다.<br> vinyl-source-stream을 사용하면 Browserify의 파일 출력을 gulp에서 <a href=\"https://github.com/gulpjs/vinyl\">vinyl</a>으로 인식하는 형식으로 다시 변환할 수 있습니다.</p> <pre data-language=\"shell\">npm install --save-dev browserify tsify vinyl-source-stream</pre> <h2 id=\"페이지-만들기-create-a-page\" style=\"position:relative;\">페이지 만들기 (Create a page)</h2> <p><code>src</code>에 <code>index.html</code> 파일을 생성합니다 :</p> <pre data-language=\"html\">&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n    &lt;head&gt;\n        &lt;meta charset=\"UTF-8\" /&gt;\n        &lt;title&gt;Hello World!&lt;/title&gt;\n    &lt;/head&gt;\n    &lt;body&gt;\n        &lt;p id=\"greeting\"&gt;Loading ...&lt;/p&gt;\n        &lt;script src=\"bundle.js\"&gt;&lt;/script&gt;\n    &lt;/body&gt;\n&lt;/html&gt;</pre> <p>이제 페이지를 업데이트하기 위해 <code>main.ts</code>를 변경합니다:</p> <pre data-language=\"ts\">import { sayHello } from \"./greet\";\n\nfunction showHello(divName: string, name: string) {\n    const elt = document.getElementById(divName);\n    elt.innerText = sayHello(name);\n}\n\nshowHello(\"greeting\", \"TypeScript\");</pre> <p><code>showHello</code> 호출은 <code>sayHello</code>를 호출하여 paragraph 텍스트를 변경합니다.<br> 이제 gulpfile을 다음과 같이 변경하십시오 :</p> <pre data-language=\"js\">var gulp = require('gulp');\nvar browserify = require('browserify');\nvar source = require('vinyl-source-stream');\nvar tsify = require('tsify');\nvar paths = {\n    pages: ['src/*.html']\n};\n\ngulp.task('copy-html', function () {\n    return gulp.src(paths.pages)\n        .pipe(gulp.dest('dist'));\n});\n\ngulp.task('default', gulp.series(gulp.parallel('copy-html'), function () {\n    return browserify({\n        basedir: '.',\n        debug: true,\n        entries: ['src/main.ts'],\n        cache: {},\n        packageCache: {}\n    })\n    .plugin(tsify)\n    .bundle()\n    .pipe(source('bundle.js'))\n    .pipe(gulp.dest('dist'));\n}));</pre> <p><code>copy-html</code> 태스크를 추가하고 <code>default</code>의 의존성으로 추가합니다.<br> <code>default</code>가 실행될 때마다 <code>copy-html</code>이 먼저 실행되어야 한다는 것을 의미합니다.<br> 또한 <code>default</code>를 gulp-typescript 대신 tsify 플러그인으로 Browserify를 호출하도록 변경했습니다.<br> 편리하게도 둘 모두 TypeScript 컴파일러에 동일한 options 객체를 전달할 수 있습니다.</p> <p><code>bundle</code>을 호출한 후 <code>source</code>(vinil-source-stream에 대한 별칭)를 사용하여 출력 번들 <code>bundle.js</code>의 이름을 지정합니다.</p> <p>gulp를 실행하고 브라우저에서 <code>dist/index.html</code>을 열어 페이지를 확인하세요.<br> 페이지에 “Hello from TypeScript”가 표시되어야 합니다.</p> <p>Browserify에 <code>debug : true</code>를 지정한 것에 주목하십시오.<br> 이로 인해 tsify는 번들된 JavaScript 파일 안에 소스 맵을 내보냅니다.<br> 소스 맵을 사용하면 번들로 제공된 JavaScript 대신 브라우저에서 원본 TypeScript 코드를 디버깅할 수 있습니다.<br> 브라우저의 디버거를 열고 <code>main.ts</code> 안에 브레이크 포인트을 넣으면 소스 맵이 작동하는지 테스트할 수 있습니다.<br> 페이지를 새로 고침 하면 브레이크 포인트가 페이지를 일시 중지하고 <code>greet.ts</code>를 디버깅 할 수 있어야 합니다.</p> <h1 id=\"watchify-babel-and-uglify\" style=\"position:relative;\">Watchify, Babel, and Uglify</h1> <p>이제 코드를 Browserify에 묶어서 tsify 했으므로 browserify 플러그인을 사용하여 빌드에 다양한 기능을 추가할 수 있습니다.</p> <ul> <li> <p>Watchify가 gulp를 계속 실행하며 파일을 저장할 때마다 점차적으로 컴파일합니다.<br> 이를 통해 브라우저에서 편집-저장-새로고침 사이클을 계속 진행할 수 있습니다.</p> </li> <li> <p>Babel은 ES2015 이상을 ES5 및 ES3으로 변환하는 매우 유연한 컴파일러입니다.<br> 따라서 TypeScript에서 지원하지 않는 광범위한 맞춤형 변환을 추가할 수 있습니다.</p> </li> <li> <p>Uglify는 다운로드 시간을 줄이도록 코드를 압축합니다.</p> </li> </ul> <h2 id=\"watchify\" style=\"position:relative;\">Watchify</h2> <p>Watchify로 백그라운드 컴파일을 시작하겠습니다 :</p> <pre data-language=\"shell\">npm install --save-dev watchify fancy-log</pre> <p>이제 gulpfile을 다음과 같이 변경하십시오 :</p> <pre data-language=\"js\">var gulp = require('gulp');\nvar browserify = require('browserify');\nvar source = require('vinyl-source-stream');\nvar watchify = require('watchify');\nvar tsify = require('tsify');\nvar fancy_log = require('fancy-log');\nvar paths = {\n    pages: ['src/*.html']\n};\n\nvar watchedBrowserify = watchify(browserify({\n    basedir: '.',\n    debug: true,\n    entries: ['src/main.ts'],\n    cache: {},\n    packageCache: {}\n}).plugin(tsify));\n\ngulp.task('copy-html', function () {\n    return gulp.src(paths.pages)\n        .pipe(gulp.dest('dist'));\n});\n\nfunction bundle() {\n    return watchedBrowserify\n        .bundle()\n        .on('error', fancy_log)\n        .pipe(source('bundle.js'))\n        .pipe(gulp.dest('dist'));\n}\n\ngulp.task('default', gulp.series(gulp.parallel('copy-html'), bundle));\nwatchedBrowserify.on('update', bundle);\nwatchedBrowserify.on('log', fancy_log);</pre> <p>여기에는 기본적으로 세 가지 변경 사항이 있지만 코드를 약간 리팩토링해야합니다.</p> <ol> <li>\n<code>watchify</code>에 대한 호출에서 <code>browserify</code> 인스턴스를 감싸고 그 결과를 유지했습니다.</li> <li>\n<code>watchedBrowserify.on('update', bundle);</code>을 호출하여 Browserify 가 TypeScript 파일 중 하나가 변경될 때마다 <code>bundle</code> 함수를 실행하도록 했습니다.</li> <li>\n<code>watchedBrowserify.on('log', fancy_log);</code>을 호출하여 콘솔에 기록했습니다.</li> </ol> <p>(1)과 (2)는 <code>default</code> 작업에서 <code>browserify</code>를 호출해야 한다는 것을 의미합니다.<br> Watchify와 Gulp 모두 호출해야 하기 때문에 <code>default</code> 함수에 이름을 주어야 합니다.<br> (3)을 사용한 로깅을 추가하는 것은 선택 사항이지만 설정을 디버깅하는 데 매우 유용합니다.</p> <p>이제 Gulp를 실행하면 시작해야 하고 계속 실행됩니다.<br> <code>main.ts</code>에서 <code>showHello</code>에 대한 코드를 변경하고 저장하십시오.<br> 다음과 같은 출력이 표시되어야 합니다:</p> <pre data-language=\"shell\">proj$ gulp\n[10:34:20] Using gulpfile ~/src/proj/gulpfile.js\n[10:34:20] Starting 'copy-html'...\n[10:34:20] Finished 'copy-html' after 26 ms\n[10:34:20] Starting 'default'...\n[10:34:21] 2824 bytes written (0.13 seconds)\n[10:34:21] Finished 'default' after 1.36 s\n[10:35:22] 2261 bytes written (0.02 seconds)\n[10:35:24] 2808 bytes written (0.05 seconds)</pre> <h2 id=\"uglify\" style=\"position:relative;\">Uglify</h2> <p>먼저 Uglify를 설치하십시오.<br> Uglify의 요점은 코드를 압축하기 위한 것이므로 소스 맵을 유지하려면 vinyl-buffer와 gulp-sourcemaps도 설치해야 합니다.</p> <pre data-language=\"shell\">npm install --save-dev gulp-uglify vinyl-buffer gulp-sourcemaps</pre> <p>이제 gulpfile을 다음과 같이 변경하십시오 :</p> <pre data-language=\"js\">var gulp = require('gulp');\nvar browserify = require('browserify');\nvar source = require('vinyl-source-stream');\nvar tsify = require('tsify');\nvar uglify = require('gulp-uglify');\nvar sourcemaps = require('gulp-sourcemaps');\nvar buffer = require('vinyl-buffer');\nvar paths = {\n    pages: ['src/*.html']\n};\n\ngulp.task('copy-html', function () {\n    return gulp.src(paths.pages)\n        .pipe(gulp.dest('dist'));\n});\n\ngulp.task('default', gulp.series(gulp.parallel('copy-html'), function () {\n    return browserify({\n        basedir: '.',\n        debug: true,\n        entries: ['src/main.ts'],\n        cache: {},\n        packageCache: {}\n    })\n    .plugin(tsify)\n    .bundle()\n    .pipe(source('bundle.js'))\n    .pipe(buffer())\n    .pipe(sourcemaps.init({loadMaps: true}))\n    .pipe(uglify())\n    .pipe(sourcemaps.write('./'))\n    .pipe(gulp.dest('dist'));\n}));</pre> <p><code>uglify</code> 자체에는 하나의 호출만 있습니다 — <code>buffer</code>와 <code>sourcemaps</code>에 대한 호출은 sourcemaps이 계속 작동하는지 확인하기 위해 존재합니다.<br> 이러한 호출을 통해 이전과 같이 인라인 소스 맵을 사용하는 대신 별도의 소스 맵 파일을 사용할 수 있습니다.<br> 이제 Gulp를 실행하고 <code>bundle.js</code>가 난독화로 압축되는지 확인하십시오 :</p> <pre data-language=\"shell\">gulp\ncat dist/bundle.js</pre> <h2 id=\"babel\" style=\"position:relative;\">Babel</h2> <p>먼저 ES2015 전용 Babelify 및 Babel preset을 설치하십시오.<br> Uglify처럼 Babelify도 코드를 엉망으로 만들기 때문에 vinyl-buffer와 gulp-sourcemaps이 필요합니다.<br> 기본적으로 Babelify는 확장자가 <code>.js</code>, <code>.es</code>, <code>.es6</code> 및 <code>.jsx</code> 인 파일만 처리하므로 Babelify에 옵션으로 <code>.ts</code> 확장자를 추가해야 합니다.</p> <pre data-language=\"shell\">npm install --save-dev babelify@8 babel-core babel-preset-es2015 vinyl-buffer gulp-sourcemaps</pre> <p>이제 gulpfile을 다음과 같이 변경하십시오 :</p> <pre data-language=\"js\">var gulp = require('gulp');\nvar browserify = require('browserify');\nvar source = require('vinyl-source-stream');\nvar tsify = require('tsify');\nvar sourcemaps = require('gulp-sourcemaps');\nvar buffer = require('vinyl-buffer');\nvar paths = {\n    pages: ['src/*.html']\n};\n\ngulp.task('copy-html', function () {\n    return gulp.src(paths.pages)\n        .pipe(gulp.dest('dist'));\n});\n\ngulp.task('default', gulp.series(gulp.parallel('copy-html'), function () {\n    return browserify({\n        basedir: '.',\n        debug: true,\n        entries: ['src/main.ts'],\n        cache: {},\n        packageCache: {}\n    })\n    .plugin(tsify)\n    .transform('babelify', {\n        presets: ['es2015'],\n        extensions: ['.ts']\n    })\n    .bundle()\n    .pipe(source('bundle.js'))\n    .pipe(buffer())\n    .pipe(sourcemaps.init({loadMaps: true}))\n    .pipe(sourcemaps.write('./'))\n    .pipe(gulp.dest('dist'));\n}));</pre> <p>TypeScript 대상 ES2015도 필요합니다.<br> Babel은 TypeScript에서 내보내는 ES2015 코드에서 ES5를 생성합니다. <code>tsconfig.json</code>을 수정합시다:</p> <pre data-language=\"json\">{\n    \"files\": [\n        \"src/main.ts\"\n    ],\n    \"compilerOptions\": {\n        \"noImplicitAny\": true,\n        \"target\": \"es2015\"\n    }\n}</pre> <p>간단한 스크립트의 경우 Babel의 ES5 결과물은 TypeScript의 결과물과 거의 같아야 합니다.</p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2012-2023 Microsoft<br>Licensed under the Apache License, Version 2.0.<br>\n    <a href=\"https://www.typescriptlang.org/ko/docs/handbook/gulp.html\" class=\"_attribution-link\">https://www.typescriptlang.org/ko/docs/handbook/gulp.html</a>\n  </p>\n</div>\n","nightly-builds":"<h1>Nightly Builds</h1>\n<p><a href=\"https://github.com/Microsoft/TypeScript/tree/master\">TypeScript의 <code>master</code></a> 브랜치의 nightly 빌드는 태평양 표준시(PST) 자정까지 NPM에 배포됩니다.<br> 도구를 사용하여 가져오는 방법과 사용하는 방법은 다음과 같습니다.</p> <h2 id=\"npm-사용하기-using-npm\" style=\"position:relative;\">npm 사용하기 (Using npm)</h2> <pre data-language=\"shell\">npm install -g typescript@next</pre> <h2 id=\"nightly-빌드를-사용하도록-ide-업데이트-updating-your-ide-to-use-the-nightly-builds\" style=\"position:relative;\">nightly 빌드를 사용하도록 IDE 업데이트 (Updating your IDE to use the nightly builds)</h2> <p>nightly drop을 사용하도록 IDE를 업데이트할 수 있습니다.<br> 먼저 npm을 통해 패키지를 설치해야 합니다. npm 패키지를 전역으로 설치하거나 로컬에 있는 <code>node_modules</code> 폴더에 설치할 수 있습니다.</p> <p>이 섹션의 나머지 부분에서는 <code>typescript@next</code>가 이미 설치되어 있다고 가정합니다.</p> <h3 id=\"비주얼-스튜디오-코드-visual-studio-code\" style=\"position:relative;\">비주얼 스튜디오 코드 (Visual Studio Code)</h3> <p><code>.vscode/settings.json</code> 파일을 다음과 같이 업데이트하세요:</p> <pre data-language=\"json\">\"typescript.tsdk\": \"&lt;path to your folder&gt;/node_modules/typescript/lib\"</pre> <p>자세한 내용은 <a href=\"https://code.visualstudio.com/Docs/languages/typescript#_using-newer-typescript-versions\">VSCode 문서</a>를 참조하세요.</p> <h3 id=\"서브라임-텍스트-sublime-text\" style=\"position:relative;\">서브라임 텍스트 (Sublime Text)</h3> <p><code>Settings - User</code> 파일을 다음과 같이 업데이트하세요:</p> <pre data-language=\"json\">\"typescript_tsdk\": \"&lt;path to your folder&gt;/node_modules/typescript/lib\"</pre> <p>자세한 내용은 <a href=\"https://github.com/Microsoft/TypeScript-Sublime-Plugin#installation\">서브라임 텍스트를 위한 TypeScript 플러그인 설치 문서</a>를 참조하세요.</p> <h3 id=\"비주얼-스튜디오-2013-및-2015-visual-studio-2013-and-2015\" style=\"position:relative;\">비주얼 스튜디오 2013 및 2015 (Visual Studio 2013 and 2015)</h3> <blockquote> <p>주의사항: 대부분의 변경 사항에는 새로운 버전의 VS TypeScript 플러그인을 설치할 필요는 없습니다.</p> </blockquote> <p>현재 nightly 빌드에는 전체 플러그인 설정이 포함되어 있지 않지만 nightly 기반으로 설치 프로그램을 배포하기 위해 노력하고 있습니다.</p> <ol> <li> <p><a href=\"https://github.com/Microsoft/TypeScript/blob/master/scripts/VSDevMode.ps1\">VSDevMode.ps1</a> 스크립트를 다운로드하세요.</p> <blockquote> <p>또한 <a href=\"https://github.com/Microsoft/TypeScript/wiki/Dev-Mode-in-Visual-Studio#using-a-custom-language-service-file\">커스텀 언어 서비스 파일 사용</a>에 대한 위키 페이지를 참조하세요.</p> </blockquote> </li> <li> <p>PowerShell 커맨드 라인 창에서 다음을 실행합니다:</p> </li> </ol> <p>VS 2015:</p> <pre data-language=\"typescript\">VSDevMode.ps1 14 -tsScript &lt;path to your folder&gt;/node_modules/typescript/lib</pre> <p>VS 2013:</p> <pre data-language=\"typescript\">VSDevMode.ps1 12 -tsScript &lt;path to your folder&gt;/node_modules/typescript/lib</pre> <h3 id=\"intellij-idea-mac\" style=\"position:relative;\">IntelliJ IDEA (Mac)</h3> <p><code>Preferences</code> &gt; <code>Languages &amp; Frameworks</code> &gt; <code>TypeScript</code>를 선택합니다:</p> <blockquote> <p>TypeScript 버전: npm으로 설치한 경우: <code>/usr/local/lib/node_modules/typescript/lib</code></p> </blockquote> <h3 id=\"intellij-idea-windows\" style=\"position:relative;\">IntelliJ IDEA (Windows)</h3> <p><code>File</code> &gt; <code>Settings</code> &gt; <code>Languages &amp; Frameworks</code> &gt; <code>TypeScript</code>를 선택합니다:</p> <blockquote> <p>TypeScript 버전: npm으로 설치한 경우: <code>C:\\Users\\USERNAME\\AppData\\Roaming\\npm\\node_modules\\typescript\\lib</code></p> </blockquote><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2012-2023 Microsoft<br>Licensed under the Apache License, Version 2.0.<br>\n    <a href=\"https://www.typescriptlang.org/ko/docs/handbook/nightly-builds.html\" class=\"_attribution-link\">https://www.typescriptlang.org/ko/docs/handbook/nightly-builds.html</a>\n  </p>\n</div>\n","declaration-files/by-example":"<h1>Declaration Reference</h1>\n<h1 id=\"소개-introduction\" style=\"position:relative;\">소개 (Introduction)</h1> <p>이 가이드는 양질의 선언 파일을 작성하는 방법을 설명하기 위해 작성되었습니다. 이 가이드는 일부 API 문서를 해당 API 사용 예시와 함께 보여주고, 상응하는 선언을 작성하는 방법을 설명합니다.</p> <p>예제는 대체로 후반부로 갈수록 복잡해집니다.</p> <ul> <li><a href=\"#%ED%94%84%EB%A1%9C%ED%8D%BC%ED%8B%B0%EB%A5%BC-%EA%B0%96%EB%8A%94-%EA%B0%9D%EC%B2%B4-objects-with-properties\">프로퍼티를 갖는 객체 (Objects with Properties)</a></li> <li><a href=\"#%EC%98%A4%EB%B2%84%EB%A1%9C%EB%93%9C%EB%90%9C-%ED%95%A8%EC%88%98-overloaded-functions\">오버로드된 함수 (Overloaded Function)</a></li> <li><a href=\"#%EC%9E%AC%EC%82%AC%EC%9A%A9-%EA%B0%80%EB%8A%A5%ED%95%9C-%ED%83%80%EC%9E%85-%EC%9D%B8%ED%84%B0%ED%8E%98%EC%9D%B4%EC%8A%A4-reusable-types-interfaces\">재사용 가능한 타입 (인터페이스) (Reusable Types (Interfaces))</a></li> <li><a href=\"#%EC%9E%AC%EC%82%AC%EC%9A%A9-%EA%B0%80%EB%8A%A5%ED%95%9C-%ED%83%80%EC%9E%85-%ED%83%80%EC%9E%85-%EB%B3%84%EC%B9%AD-reusable-types-type-aliases\">재사용 가능한 타입 (타입 별칭) (Reusable Types (Type Aliases))</a></li> <li><a href=\"#%ED%83%80%EC%9E%85-%EA%B5%AC%EC%A1%B0%ED%99%94%ED%95%98%EA%B8%B0-organizing-types\">타입 구조화하기 (Organizing Types)</a></li> <li><a href=\"#%ED%81%B4%EB%9E%98%EC%8A%A4-classes\">클래스 (Classes)</a></li> <li><a href=\"#%EC%A0%84%EC%97%AD-%EB%B3%80%EC%88%98-global-variables\">전역 변수 (Global Variables)</a></li> <li><a href=\"#%EC%A0%84%EC%97%AD-%ED%95%A8%EC%88%98-global-functions\">전역 함수 (Global Functions)</a></li> </ul> <h1 id=\"예제-the-examples\" style=\"position:relative;\">예제 (The Examples)</h1> <h2 id=\"프로퍼티를-갖는-객체-objects-with-properties\" style=\"position:relative;\">프로퍼티를 갖는 객체 (Objects with Properties)</h2> <p><em>문서</em></p> <blockquote> <p>전역 변수 <code>myLib</code>에는 인사말을 만드는 함수 <code>makeGreeting</code>와, 지금까지 생성한 인사말의 수를 가리키는 <code>numberOfGreetings</code> 프로퍼티가 있습니다.</p> </blockquote> <p><em>코드</em></p> <pre data-language=\"ts\">let result = myLib.makeGreeting(\"hello, world\");\nconsole.log(\"The computed greeting is:\" + result);\n\nlet count = myLib.numberOfGreetings;</pre> <p><em>선언</em></p> <p>점 표기법으로 접근하는 타입이나 값을 설명하기 위해 <code>declare namespace</code>를 사용하세요.</p> <pre data-language=\"ts\">declare namespace myLib {\n    function makeGreeting(s: string): string;\n    let numberOfGreetings: number;\n}</pre> <h2 id=\"오버로드된-함수-overloaded-functions\" style=\"position:relative;\">오버로드된 함수 (Overloaded Functions)</h2> <p><em>문서</em></p> <p><code>getWidget</code> 함수는 숫자를 인자로 받아 Widget을 반환하거나, 문자열을 인자로 받아 Widget 배열을 반환합니다.</p> <p><em>코드</em></p> <pre data-language=\"ts\">let x: Widget = getWidget(43);\n\nlet arr: Widget[] = getWidget(\"all of them\");</pre> <p><em>선언</em></p> <pre data-language=\"ts\">declare function getWidget(n: number): Widget;\ndeclare function getWidget(s: string): Widget[];</pre> <h2 id=\"재사용-가능한-타입-인터페이스-reusable-types-interfaces\" style=\"position:relative;\">재사용 가능한 타입 (인터페이스) (Reusable Types (Interfaces))</h2> <p><em>문서</em></p> <blockquote> <p>greeting을 명시할 때, 반드시 <code>GreetingSettings</code> 객체를 전달해야 합니다. 이 객체는 다음의 프로퍼티를 갖고 있습니다:</p> <p>1 - greeting: 필수 문자열</p> <p>2 - duration: 선택적 시간 (밀리초)</p> <p>3 - color: 선택적 문자열, 예. ‘#ff00ff’</p> </blockquote> <p><em>코드</em></p> <pre data-language=\"ts\">greet({\n  greeting: \"hello world\",\n  duration: 4000\n});</pre> <p><em>선언</em></p> <p>프로퍼티를 갖는 타입을 정의하기 위해 <code>interface</code>를 사용하세요.</p> <pre data-language=\"ts\">interface GreetingSettings {\n  greeting: string;\n  duration?: number;\n  color?: string;\n}\n\ndeclare function greet(setting: GreetingSettings): void;</pre> <h2 id=\"재사용-가능한-타입-타입-별칭-reusable-types-type-aliases\" style=\"position:relative;\">재사용 가능한 타입 (타입 별칭) (Reusable Types (Type Aliases))</h2> <p><em>문서</em></p> <blockquote> <p>인사말이 예상되는 어느 곳에나, <code>string</code>, <code>string</code>을 반환하는 함수, 또는 <code>Greeter</code> 인스턴스를 전달할 수 있습니다.</p> </blockquote> <p><em>코드</em></p> <pre data-language=\"ts\">function getGreeting() {\n    return \"howdy\";\n}\nclass MyGreeter extends Greeter { }\n\ngreet(\"hello\");\ngreet(getGreeting);\ngreet(new MyGreeter());</pre> <p><em>선언</em></p> <p>타입에 대한 약칭으로 타입 별칭을 사용할 수 있습니다:</p> <pre data-language=\"ts\">type GreetingLike = string | (() =&gt; string) | Greeter;\n\ndeclare function greet(g: GreetingLike): void;</pre> <h2 id=\"타입-구조화하기-organizing-types\" style=\"position:relative;\">타입 구조화하기 (Organizing Types)</h2> <p><em>문서</em></p> <blockquote> <p><code>greeter</code> 객체는 파일에 로그를 작성하거나 경고 창을 띄울 수 있습니다. 로그 옵션을 <code>.log(...)</code> 내부에, 경고 창 옵션을 <code>.alert(...)</code> 내부에 전달할 수 있습니다.</p> </blockquote> <p><em>코드</em></p> <pre data-language=\"ts\">const g = new Greeter(\"Hello\");\ng.log({ verbose: true });\ng.alert({ modal: false, title: \"Current Greeting\" });</pre> <p><em>선언</em></p> <p>타입을 구조화하기 위해 네임스페이스를 사용하세요.</p> <pre data-language=\"ts\">declare namespace GreetingLib {\n    interface LogOptions {\n        verbose?: boolean;\n    }\n    interface AlertOptions {\n        modal: boolean;\n        title?: string;\n        color?: string;\n    }\n}</pre> <p>중첩된 네임스페이스를 하나의 선언으로 만들 수 있습니다:</p> <pre data-language=\"ts\">declare namespace GreetingLib.Options {\n    // Refer to via GreetingLib.Options.Log\n    interface Log {\n        verbose?: boolean;\n    }\n    interface Alert {\n        modal: boolean;\n        title?: string;\n        color?: string;\n    }\n}</pre> <h2 id=\"클래스-classes\" style=\"position:relative;\">클래스 (Classes)</h2> <p><em>문서</em></p> <blockquote> <p><code>Greeter</code> 객체를 인스턴스화해서 greeter를 생성하거나, 이 객체를 상속해서 커스텀 greeter를 생성할 수 있습니다.</p> </blockquote> <p><em>코드</em></p> <pre data-language=\"ts\">const myGreeter = new Greeter(\"hello, world\");\nmyGreeter.greeting = \"howdy\";\nmyGreeter.showGreeting();\n\nclass SpecialGreeter extends Greeter {\n    constructor() {\n        super(\"Very special greetings\");\n    }\n}</pre> <p><em>선언</em></p> <p>클래스 혹은 클래스-같은 객체를 설명하기 위해 <code>declare class</code>를 사용하세요. 클래스는 생성자 뿐만 아니라 프로퍼티와 메서드를 가질 수 있습니다.</p> <pre data-language=\"ts\">declare class Greeter {\n    constructor(greeting: string);\n\n    greeting: string;\n    showGreeting(): void;\n}</pre> <h2 id=\"전역-변수-global-variables\" style=\"position:relative;\">전역 변수 (Global Variables)</h2> <p><em>문서</em></p> <blockquote> <p>전역 변수 <code>foo</code>는 존재하는 위젯의 수를 포함합니다.</p> </blockquote> <p><em>코드</em></p> <pre data-language=\"ts\">console.log(\"Half the number of widgets is \" + (foo / 2));</pre> <p><em>선언</em></p> <p>변수를 선언하기 위해 <code>declare var</code>를 사용하세요. 만약 변수가 읽기-전용이라면, <code>declare const</code>를 사용하세요. 변수가 블록-스코프인 경우 <code>declare let</code> 또한 사용할 수 있습니다.</p> <pre data-language=\"ts\">/** 존재하는 위젯의 수 */\ndeclare var foo: number;</pre> <h2 id=\"전역-함수-global-functions\" style=\"position:relative;\">전역 함수 (Global Functions)</h2> <p><em>문서</em></p> <blockquote> <p>사용자에게 인사말을 보여주기 위해 <code>greet</code> 함수를 호출할 수 있습니다.</p> </blockquote> <p><em>코드</em></p> <pre data-language=\"ts\">greet(\"hello, world\");</pre> <p><em>선언</em></p> <p>함수를 선언하기 위해 <code>declare function</code>을 사용하세요.</p> <pre data-language=\"ts\">declare function greet(greeting: string): void;</pre><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2012-2023 Microsoft<br>Licensed under the Apache License, Version 2.0.<br>\n    <a href=\"https://www.typescriptlang.org/ko/docs/handbook/declaration-files/by-example.html\" class=\"_attribution-link\">https://www.typescriptlang.org/ko/docs/handbook/declaration-files/by-example.html</a>\n  </p>\n</div>\n","2/typeof-types":"<h1>Typeof Type Operator</h1>\n<h2 id=\"typeof-타입-연산자\" style=\"position:relative;\">\n<code>typeof</code> 타입 연산자</h2> <p>JavaScript에서는 이미 <em>표현식</em> 컨텍스트에서 사용할 수 있는 <code>typeof</code> 연산자가 있습니다.</p> <pre data-language=\"ts\">// \"string\"을 출력합니다\nconsole.log(typeof \"Hello world\");</pre> <p>TypeScript는 <em>타입</em> 컨텍스트에서 변수나 프로퍼티의 타입을 추론할 수 있는 <code>typeof</code> 연산자를 추가합니다.</p> <pre data-language=\"ts\">let s = \"hello\";\nlet n: typeof s;</pre> <p>기본 타입에 대해선 별로 유용하진 않지만, 다른 타입 연산자와 함께 <code>typeof</code>를 사용하여 많은 패턴을 편리하게 표현할 수 있습니다. 예를 들어, 미리 정의된 타입인 <code>ReturnType&lt;T&gt;</code> 부터 살펴보겠습니다. 위 타입은 <em>함수 타입</em> 을 받으면서 반환되는 타입을 제공합니다.</p> <pre data-language=\"ts\">type Predicate = (x: unknown) =&gt; boolean;\ntype K = ReturnType&lt;Predicate&gt;;</pre> <p>함수 이름에 <code>ReturnType</code>을 사용하면, 안내 오류를 확인할 수 있습니다.</p> <pre data-language=\"ts\">function f() {\n  return { x: 10, y: 3 };\n}\ntype P = ReturnType&lt;f&gt;;</pre> <p><em>값</em> 과 <em>타입</em> 은 같지 않다는 것을 명심하세요. <em>값 <code>f</code></em> 의 <em>타입</em> 을 추론하기 위해서 <code>typeof</code>를 사용합니다.</p> <pre data-language=\"ts\">function f() {\n  return { x: 10, y: 3 };\n}\ntype P = ReturnType&lt;typeof f&gt;;</pre> <h3 id=\"제한\" style=\"position:relative;\">제한</h3> <p>TypeScript는 <code>typeof</code>를 사용할 수 있는 표현식의 종류를 의도적으로 제한합니다.</p> <p>특히, 식별자(예: 변수이름) 혹은 프로퍼티에서만 <code>typeof</code>를 사용할 수 있습니다. 실행 중인 것으로 생각되는 코드 작성의 실수를 피하는데 도움을 줄 수 있지만, 그렇진 않습니다.</p> <pre data-language=\"ts\">// Meant to use = ReturnType&lt;typeof msgbox&gt;\nlet shouldContinue: typeof msgbox(\"Are you sure you want to continue?\");</pre><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2012-2023 Microsoft<br>Licensed under the Apache License, Version 2.0.<br>\n    <a href=\"https://www.typescriptlang.org/ko/docs/handbook/2/typeof-types.html\" class=\"_attribution-link\">https://www.typescriptlang.org/ko/docs/handbook/2/typeof-types.html</a>\n  </p>\n</div>\n","2/conditional-types":"<h1>Conditional Types</h1>\n<p>대부분 유용한 프로그램의 핵심은, 입력에 따라 출력이 결정되어야 한다는 것입니다. JavaScript 프로그램도 크게 다르진 않지만, 값의 타입을 쉽게 검사할 수 있다는 사실을 고려할 때, 출력에 대한 결정은 또한 입력의 타입에도 기반합니다. <em>조건부 타입</em> 은 입력과 출력 타입간의 관계를 설명하는 데 도움을 줄 수 있습니다.</p> <pre data-language=\"ts\">interface Animal {\n  live(): void;\n}\ninterface Dog extends Animal {\n  woof(): void;\n}\n \ntype Example1 = Dog extends Animal ? number : string;\n \ntype Example2 = RegExp extends Animal ? number : string;</pre> <p>조건부 타입은 JavaScript에 있는 삼항 연산자 조건문 (<code>condition ? trueExpression : falseExpression</code>) 같은 형태를 가집니다.</p> <pre data-language=\"ts\">  SomeType extends OtherType ? TrueType : FalseType;</pre> <p><code>extends</code>를 기준으로 왼쪽에 있는 타입이 오른쪽 타입에 할당할 수 있다면 첫 번째 분기(“참”값 분기)를, 그렇지 않다면 뒤의 분기(“거짓”값 분기)를 얻게 됩니다.</p> <p><code>Dog extends Animal</code> 에 따라 <code>number</code>나 <code>string</code>인지 알려주는 것 말곤, 위의 예제에서 조건부 타입은 그다지 유용해 보이지 않습니다! 하지만 제네릭과 함께 사용될 때 조건부 타입은 강력한 힘을 갖습니다.</p> <p>예를 들어, 다음 <code>createLabel</code> 함수를 살펴보겠습니다.</p> <pre data-language=\"ts\">interface IdLabel {\n  id: number /* some fields */;\n}\ninterface NameLabel {\n  name: string /* other fields */;\n}\n \nfunction createLabel(id: number): IdLabel;\nfunction createLabel(name: string): NameLabel;\nfunction createLabel(nameOrId: string | number): IdLabel | NameLabel;\nfunction createLabel(nameOrId: string | number): IdLabel | NameLabel {\n  throw \"unimplemented\";\n}</pre> <p>createLabel의 오버로드들은 입력 타입에 따른 단일 JavaScript 함수를 나타냅니다. 다음을 주목하세요.</p> <ol> <li>만약 라이브러리가 매번 API 전체에서 비슷한 종류의 함수를 만들어야 한다면 번거로워집니다.</li> <li>우린 3가지 오버로드 즉, 각 케이스별로 <em>확실한</em> 타입을 가지거나 (각각 <code>number</code>와 <code>string</code>) 그리고 일반적인 케이스(<code>string | number</code>) 가져야 합니다. <code>createLabel</code>의 새로운 타입을 다루기 위해선 오버로드의 수는 기하급수적으로 증가합니다.</li> </ol> <p>대신에 조건부 타입으로 로직을 인코딩할 수 있습니다.</p> <pre data-language=\"ts\">type NameOrId&lt;T extends number | string&gt; = T extends number\n  ? IdLabel\n  : NameLabel;</pre> <p>조건부 타입을 사용하면 단일 함수까지 오버로드 없이 단순화 시킬 수 있습니다.</p> <pre data-language=\"ts\">function createLabel&lt;T extends number | string&gt;(idOrName: T): NameOrId&lt;T&gt; {\n  throw \"unimplemented\";\n}\n \nlet a = createLabel(\"typescript\");\n \nlet b = createLabel(2.8);\n \nlet c = createLabel(Math.random() ? \"hello\" : 42);</pre> <h3 id=\"조건부-타입으로-제한하기\" style=\"position:relative;\">조건부 타입으로 제한하기</h3> <p>종종, 조건부 타입의 검사에서 새로운 정보를 얻을 수 있습니다. 타입 가드가 더 구체적인 타입으로 좁혀주듯이, 조건부 타입의 “참”값 분기는 대조하는 타입에 따라서 제네릭을 더 제한할 수 있습니다.</p> <p>다음 예를 살펴보겠습니다.</p> <pre data-language=\"ts\">type MessageOf&lt;T&gt; = T[\"message\"];</pre> <p>위 예제에서, <code>T</code>가 <code>message</code> 프로퍼티를 가지고 있는지 알 수 없기 때문에 TypeScript에서 오류가 발생합니다. <code>T</code>의 타입을 제한해서 TypeScript가 더이상 오류를 내지 않도록 만들 수 있습니다.</p> <pre data-language=\"ts\">type MessageOf&lt;T extends { message: unknown }&gt; = T[\"message\"];\n \ninterface Email {\n  message: string;\n}\n \ntype EmailMessageContents = MessageOf&lt;Email&gt;;</pre> <p>하지만 <code>MessageOf</code> 가 아무 타입이나 받을 수 있고, <code>message</code> 프로퍼티가 없으면 <code>never</code> 타입으로 결정하도록 만들 수 있을까요? 여기서 제약 조건을 외부로 옮기고, 조건부 타입을 적용하면 가능합니다.</p> <pre data-language=\"ts\">type MessageOf&lt;T&gt; = T extends { message: unknown } ? T[\"message\"] : never;\n \ninterface Email {\n  message: string;\n}\n \ninterface Dog {\n  bark(): void;\n}\n \ntype EmailMessageContents = MessageOf&lt;Email&gt;;\n \ntype DogMessageContents = MessageOf&lt;Dog&gt;;</pre> <p>“참”값 분기내에서는 TypeScript는 <code>T</code>가 <code>message</code> 프로퍼티를 가지고 <em>있을 것을</em> 알 수 있습니다.</p> <p>또 다른 예제에서 배열 타입이면 배열의 개별 요소 타입으로 평탄화 시키지만, 배열 타입이 아니면 그대로 유지하는 <code>Flatten</code> 타입을 만들 수 있습니다.</p> <pre data-language=\"ts\">type Flatten&lt;T&gt; = T extends any[] ? T[number] : T;\n \n// Extracts out the element type.\ntype Str = Flatten&lt;string[]&gt;;\n \n// Leaves the type alone.\ntype Num = Flatten&lt;number&gt;;</pre> <p><code>Flatten</code>에 배열 타입이 주어지면, <code>number</code>를 사용한 인덱스 접근을 통해 <code>string[]</code>의 요소 타입을 가져올 수 있습니다. 그렇지 않으면, 주어진 타입을 반환합니다.</p> <h3 id=\"조건부-타입-내에서-추론하기\" style=\"position:relative;\">조건부 타입 내에서 추론하기</h3> <p>위에서 제약 조건을 가진 조건부 타입을 이용해서 타입을 추출할 수 있다는 점을 살펴봤습니다. 이 부분은 조건부 타입을 더 쉽게 만드는 평범한 작업이 됩니다.</p> <p>조건부 타입은 <code>infer</code> 키워드를 사용해서 “참”값 분기에서 비교하는 타입을 추론할 수 있습니다. 예를 들어, <code>Flatten</code>에서 인덱싱된 접근 타입으로 “직접” 추출하지 않고 요소 타입을 추론할 수 있습니다.</p> <pre data-language=\"ts\">type Flatten&lt;Type&gt; = Type extends Array&lt;infer Item&gt; ? Item : Type;</pre> <p>여기 “참”값 분기에서 <code>T</code>의 요소 타입을 어떻게 제시할 필요 없이, <code>infer</code> 키워드를 새 제네릭 타입 변수 <code>Item</code>에 선언적으로 사용했습니다. 이 방식은 관심 있는 타입의 구조를 깊게 분석하지 않아도 되도록 만들어줍니다.</p> <p><code>infer</code> 키워드를 사용해서 유용한 헬퍼 타입 별칭을 사용할 수 있습니다. 예를 들어 함수 타입에서 리턴 타입을 추출하는 간단한 케이스를 살펴보겠습니다.</p> <pre data-language=\"ts\">type GetReturnType&lt;Type&gt; = Type extends (...args: never[]) =&gt; infer Return\n  ? Return\n  : never;\n \ntype Num = GetReturnType&lt;() =&gt; number&gt;;\n \ntype Str = GetReturnType&lt;(x: string) =&gt; string&gt;;\n \ntype Bools = GetReturnType&lt;(a: boolean, b: boolean) =&gt; boolean[]&gt;;</pre> <p>여러 호출 시그니처 (오버로트 함수 타입 같이)를 가진 타입을 추론할 때, <em>마지막</em> 시그니처 (아마, 모든 케이스에 허용되는)로 추론하게 됩니다. 인자 타입의 목록에 기반해서 오버로드들을 처리할 수는 없습니다.</p> <pre data-language=\"ts\">declare function stringOrNum(x: string): number;\ndeclare function stringOrNum(x: number): string;\ndeclare function stringOrNum(x: string | number): string | number;\n \ntype T1 = ReturnType&lt;typeof stringOrNum&gt;;</pre> <h2 id=\"분산적인-조건부-타입\" style=\"position:relative;\">분산적인 조건부 타입</h2> <p>제네릭 타입 위에서 조건부 타입은 유니언 타입을 만나면 <em>분산적으로</em> 동작합니다. 예를 들어 다음을 보겠습니다.</p> <pre data-language=\"ts\">type ToArray&lt;Type&gt; = Type extends any ? Type[] : never;</pre> <p><code>ToArray</code>에 유니언 타입을 넘기면 조건부 타입은 유니언의 각 멤버에 적용됩니다.</p> <pre data-language=\"ts\">type ToArray&lt;Type&gt; = Type extends any ? Type[] : never;\n \ntype StrArrOrNumArr = ToArray&lt;string | number&gt;;</pre> <p><code>StrArrOrNumArr</code>이 동작하는 방식은 다음과 같습니다.</p> <pre data-language=\"ts\">  string | number;</pre> <p>유니언의 각 멤버 타입은 효율적으로 매핑됩니다.</p> <pre data-language=\"ts\">  ToArray&lt;string&gt; | ToArray&lt;number&gt;;</pre> <p>그리고 다음과 같이 결과가 나옵니다.</p> <pre data-language=\"ts\">  string[] | number[];</pre> <p>일반적으로 분산성이 원하는 동작입니다. 이러한 동작을 방지하려면 <code>extends</code>키워드의 양 옆을 대괄호로 감싸면 됩니다.</p> <pre data-language=\"ts\">type ToArrayNonDist&lt;Type&gt; = [Type] extends [any] ? Type[] : never;\n \n// 'StrArrOrNumArr' is no longer a union.\ntype StrArrOrNumArr = ToArrayNonDist&lt;string | number&gt;;</pre><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2012-2023 Microsoft<br>Licensed under the Apache License, Version 2.0.<br>\n    <a href=\"https://www.typescriptlang.org/ko/docs/handbook/2/conditional-types.html\" class=\"_attribution-link\">https://www.typescriptlang.org/ko/docs/handbook/2/conditional-types.html</a>\n  </p>\n</div>\n","declaration-files/templates/module-function-d-ts":"<h1>Module: Function</h1>\n<p>예를 들어 다음과 같은 자바스크립트 코드를 다루는 경우를 가정합시다.</p> <pre data-language=\"ts\">import greeter from \"super-greeter\";\n\ngreeter(2);\ngreeter(\"Hello world\");</pre> <p>UMD 또는 일반 모듈을 임포팅하는 두 가지 경우 모두에 대해 대응하려면 다음을 참고합니다.</p> <pre data-language=\"ts\">// Type definitions for [~라이브러리 이름~] [~선택적 버전 숫자~]\n// Project: [~프로젝트 이름~]\n// Definitions by: [~내 이름~] &lt;[~내 URL~]&gt;\n\n/*~ 함수 모듈을 위한 모듈 템플릿 입니다.\n *~ 이름을 index.d.ts로 변경하고, 모듈과 같은 이름의 폴더 안에 배치해야 합니다.\n *~ 예를 들어, \"super-greeter\" 파일을 작성하는 경우\n *~ 이 파일은 'super-greeter/index.d.ts'가 되어야 합니다.\n */\n\n// ES6 모듈은 클래스 객체를 직접 export할 수 없습니다.\n// 이 파일은 CommonJS-스타일을 사용해서 import 해야 합니다:\n//   import x = require('[~THE MODULE~]');\n//\n// 또한, --allowSyntheticDefaultImports 나\n// --esModuleInterop 옵션을 활성화한다면,\n// default import로 import할 수 있습니다:\n//   import x from '[~THE MODULE~]';\n//\n// ES6 모듈의 제한에 대한 일반적인 해결방법을 이해하려면\n// https://www.typescriptlang.org/docs/handbook/modules.html#export--and-import--require\n// 에서 TypeScript 문서를 참고하세요.\n\n/*~ 전역 변수 'myFuncLib'을 노출하는 UMD 모듈을\n *~ 모듈 로더 환경 외부에서 로드하려면, 여기에서 전역으로 선언하세요.\n *~ 그렇지 않으면, 이 선언을 제거하세요.\n */\nexport as namespace myFuncLib;\n\n/*~ 이 선언은 함수를\n *~ 파일에서 export된 객체로 지정합니다.\n */\nexport = Greeter;\n\n/*~ 이 예제는 함수에 대한 여러 오버로드하는 방법을 보여줍니다 */\ndeclare function Greeter(name: string): Greeter.NamedReturnType;\ndeclare function Greeter(length: number): Greeter.LengthReturnType;\n\n/*~ 모듈에서 타입을 노출하고 싶다면,\n *~ 이 블록 안에 위치시키세요. 종종 함수 반환 타입의 형태를\n *~ 기술하고 싶을 수 있습니다; 그 타입은\n *~ 이 예제처럼 여기에 선언하세요.\n *~\n *~ 네임스페이스를 포함할 경우,\n *~ 모듈을 네임스페이스 객체로 잘못 import 할 수 있습니다.\n *~ --esModuleInterop 옵션을 활성화하세요:\n *~   import * as x from '[~THE MODULE~]'; // 오류! 이렇게 하지 마세요!\n */\ndeclare namespace Greeter {\n  export interface LengthReturnType {\n    width: number;\n    height: number;\n  }\n  export interface NamedReturnType {\n    firstName: string;\n    lastName: string;\n  }\n\n  /*~ 모듈이 프로퍼티를 갖고 있다면, 여기에 선언하세요. 예를 들어\n   *~ 이 선언은 이 코드가 합법적임을 의미합니다:\n   *~   import f = require('super-greeter');\n   *~   console.log(f.defaultName);\n   */\n  export const defaultName: string;\n  export let defaultLength: number;\n}</pre><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2012-2023 Microsoft<br>Licensed under the Apache License, Version 2.0.<br>\n    <a href=\"https://www.typescriptlang.org/ko/docs/handbook/declaration-files/templates/module-function-d-ts.html\" class=\"_attribution-link\">https://www.typescriptlang.org/ko/docs/handbook/declaration-files/templates/module-function-d-ts.html</a>\n  </p>\n</div>\n","typescript-tooling-in-5-minutes":"<h1>TypeScript Tooling in 5 minutes</h1>\n<p>TypeScript로 간단한 웹 애플리케이션을 만들어봅시다.</p> <h2 id=\"typescript-설치하기\" style=\"position:relative;\">TypeScript 설치하기</h2> <p>프로젝트에서 TypeScript를 사용할 수 있는 두 가지 주요 방법이 있습니다:</p> <ul> <li>npm 사용하기(Node.js 패키지 매니저)</li> <li>Visual Studio TypeScript 플러그인 설치하기</li> </ul> <p>Visual Studio 2017과 Visual Studio 2015 Update 3에는 TypeScript가 기본적으로 포함되어 있습니다. 만약 Visual Studio로 TypeScript를 설치하지 않았다면, <a href=\"https://www.typescriptlang.org/download\">여기서 다운로드하세요</a>.</p> <p>npm 사용자의 경우:</p> <pre data-language=\"shell\">&gt; npm install -g typescript</pre> <h2 id=\"첫-번째-typescript-파일-생성하기\" style=\"position:relative;\">첫 번째 TypeScript 파일 생성하기</h2> <p>에디터에서, 아래 JavaScript 코드를 <code>greeter.ts</code>에 작성하세요.</p> <pre data-language=\"ts\">function greeter(person) {\n  return \"Hello, \" + person;\n}\n \nlet user = \"Jane User\";\n \ndocument.body.textContent = greeter(user);</pre> <h2 id=\"코드-컴파일하기\" style=\"position:relative;\">코드 컴파일하기</h2> <p>우리는 <code>.ts</code> 확장자를 사용했지만, 이 코드는 JavaScript일 뿐입니다. 이 코드를 기존 JavaScript 앱에 바로 복사/붙여넣을 수 있습니다.</p> <p>명령 줄에서, TypeScript 컴파일러를 실행해보세요:</p> <pre data-language=\"shell\">tsc greeter.ts</pre> <p>방금 작성한 코드와 동일한 JavaScript 파일, <code>greeter.js</code>이 생성될 것입니다. JavaScript 앱에서 TypeScript를 사용하여 실행 중입니다!</p> <p>이제, TypeScript에서 제공하는 몇 가지 새로운 도구들을 사용해봅시다. 여기 표시된 대로 함수 인수인 ‘person’에 <code>: string</code> 타입 표기를 추가해봅시다.</p> <pre data-language=\"ts\">function greeter(person: string) {\n  return \"Hello, \" + person;\n}\n \nlet user = \"Jane User\";\n \ndocument.body.textContent = greeter(user);</pre> <h2 id=\"타입-표기\" style=\"position:relative;\">타입 표기</h2> <p>TypeScript의 타입 표기는 함수나 변수의 의도된 계약을 기록하는 간단한 방법입니다. 이 경우, greeter 함수를 단일 문자열 매개변수로 호출하도록 합니다. 대신 배열을 전달하여 greeter 함수를 호출하도록 변경해봅시다.</p> <pre data-language=\"ts\">function greeter(person: string) {\n  return \"Hello, \" + person;\n}\n \nlet user = [0, 1, 2];\n \ndocument.body.textContent = greeter(user);</pre> <p>다시 컴파일해보면, 오류가 발생한 것을 볼 수 있습니다:</p> <pre data-language=\"shell\">error TS2345: Argument of type 'number[]' is not assignable to parameter of type 'string'.</pre> <p>마찬가지로, greeter 호출에 대한 모든 인수를 제거해봅시다. TypeScript는 예상치 못한 수의 매개변수를 사용하여 이 함수를 호출했음을 알려줍니다. 두 경우 모두, TypeScript는 코드 구조와 사용자가 제공한 타입 표기를 기반으로 정적 분석을 제공할 수 있습니다.</p> <p>오류가 있었음에도, <code>greeter.js</code> 파일은 여전히 생성됩니다. 코드에 오류가 있어도 TypeScript를 사용할 수 있습니다. 그러나 이 경우, TypeScript는 코드가 예상대로 실행되지 않을 것이라고 경고합니다.</p> <h2 id=\"인터페이스\" style=\"position:relative;\">인터페이스</h2> <p>샘플을 좀 더 발전시켜봅시다. 여기 firstName과 lastName 필드가 있는 객체를 설명하는 인터페이스가 있습니다. TypeScript에서는, 내부 구조가 호환되는 경우 두 개의 타입이 호환됩니다. 이를 통해, 명시적인 <code>implements</code> 절 없이도 인터페이스가 필요로 하는 모양을 갖추는 것만으로 인터페이스를 구현할 수 있습니다.</p> <pre data-language=\"ts\">interface Person {\n  firstName: string;\n  lastName: string;\n}\n \nfunction greeter(person: Person) {\n  return \"Hello, \" + person.firstName + \" \" + person.lastName;\n}\n \nlet user = { firstName: \"Jane\", lastName: \"User\" };\n \ndocument.body.textContent = greeter(user);</pre> <h2 id=\"클래스\" style=\"position:relative;\">클래스</h2> <p>마지막으로, 클래스를 사용하여 예제를 확장해봅시다. TypeScript는 클래스 기반 객체 지향 프로그래밍 지원과 같은 JavaScript의 새로운 기능을 지원합니다.</p> <p>몇 가지 퍼블릭 필드와 생성자를 포함한 <code>Student</code> 클래스를 생성해봅시다. 클래스와 인터페이스가 함께 잘 작동하므로, 프로그래머가 적절한 수준의 추상화를 결정할 수 있습니다.</p> <p>또한, 생성자에 대한 인수에 <code>public</code>을 사용하는 것은 자동으로 그 이름을 가진 속성을 만들 수 있게 해주는 약어입니다.</p> <pre data-language=\"ts\">class Student {\n  fullName: string;\n  constructor(\n    public firstName: string,\n    public middleInitial: string,\n    public lastName: string\n  ) {\n    this.fullName = firstName + \" \" + middleInitial + \" \" + lastName;\n  }\n}\n \ninterface Person {\n  firstName: string;\n  lastName: string;\n}\n \nfunction greeter(person: Person) {\n  return \"Hello, \" + person.firstName + \" \" + person.lastName;\n}\n \nlet user = new Student(\"Jane\", \"M.\", \"User\");\n \ndocument.body.textContent = greeter(user);</pre> <p><code>tsc greeter.ts</code> 명령어를 다시 실행해보면, 기존 코드와 새로 생성된 JavaScript 코드가 동일하다는 것을 알 수 있습니다. TypeScript의 클래스는 JavaScript에서 자주 사용되는 동일한 프로토타입 기반 OO의 약어입니다.</p> <h2 id=\"typescript-웹-앱-실행해보기\" style=\"position:relative;\">TypeScript 웹 앱 실행해보기</h2> <p><code>greeter.html</code>에 다음과 같이 입력하세요:</p> <pre data-language=\"html\">&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n  &lt;head&gt;\n    &lt;title&gt;TypeScript Greeter&lt;/title&gt;\n  &lt;/head&gt;\n  &lt;body&gt;\n    &lt;script src=\"greeter.js\"&gt;&lt;/script&gt;\n  &lt;/body&gt;\n&lt;/html&gt;</pre> <p>브라우저에서 <code>greeter.html</code>을 열어 첫 번째 간단한 TypeScript 웹 애플리케이션을 실행하세요!</p> <p>추가로: Visual Studio에서 <code>greeter.ts</code>를 열거나, TypeScript playground에 코드를 복사해보세요. 식별자 위로 마우스를 가져가면 해당 타입을 볼 수 있습니다. 어떤 경우에는 사용자를 위해 자동으로 타입이 추론됩니다. 마지막 줄을 다시 입력하고, DOM 요소 유형에 따라 완성 목록과 매개 변수 도움말을 참고해보세요. greeter 함수에 대한 참조에 커서를 놓고, F12를 눌러 해당 정의로 이동해보세요. 심벌에 우클릭하여 리팩토링을 사용하여 이름을 바꿀 수 있습니다.</p> <p>제공된 타입 정보는 애플리케이션 규모에서 JavaScript로 작업하는 도구와 함께 동작합니다. TypeScript에서 가능한 것에 대한 더 많은 예제는 웹사이트의 Samples 부분을 참고하세요.</p> <p><img src=\"data:image/png;base64,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\" alt=\"Visual Studio picture\"></p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2012-2023 Microsoft<br>Licensed under the Apache License, Version 2.0.<br>\n    <a href=\"https://www.typescriptlang.org/ko/docs/handbook/typescript-tooling-in-5-minutes.html\" class=\"_attribution-link\">https://www.typescriptlang.org/ko/docs/handbook/typescript-tooling-in-5-minutes.html</a>\n  </p>\n</div>\n","jsx":"<h1>JSX</h1>\n<p><a href=\"https://facebook.github.io/jsx/\">JSX</a>는 XML과 유사한 내장형 구문입니다. 이것은 구현에 따라 변환의 의미가 다르나 유효한 JavaScript로 변환되어야 합니다. JSX는 <a href=\"https://reactjs.org/\">React</a> 프레임워크로써 인기를 얻었지만, 그 이후 다른 구현도 등장하였습니다. TypeScript는 임베딩(embedding), 타입 검사 및 JSX를 JavaScript로 직접 컴파일하는 것을 지원합니다.</p> <h2 id=\"기본-사용-방법\" style=\"position:relative;\">기본 사용 방법</h2> <p>JSX를 사용하기 전에 아래의 두 가지를 수행해야 합니다.</p> <ol> <li>\n<code>.tsx</code> 확장자로 파일 이름 지정하기</li> <li>\n<code>jsx</code> 옵션 활성화하기</li> </ol> <p>TypeScript는 다음 세 가지의 JSX 모드를 제공합니다: <code>preserve</code>, <code>react</code>, <code>react-native</code>. 이 모드는 출력 단계에만 영향을 미치며 타입 검사에는 영향을 미치지 않습니다. <code>preserve</code> 모드는 JSX를 출력 일부로 유지하여 이를 다른 변환 단계(예: <a href=\"https://babeljs.io/\">Babel</a>)에서 추가로 사용합니다. 또한 출력 파일 확장자는 <code>.jsx</code>입니다. <code>react</code> 모드는 <code>React.createElement</code>를 출력하고 사용하기 전 JSX 변환을 거칠 필요가 없으며 출력 파일 확장자는 <code>.js</code>입니다. <code>react-native</code> 모드는 모든 JSX를 유지한다는 점에서 <code>preserve</code> 모드와 유사하나, 출력 파일 확장자가 <code>.js</code>라는 차이가 있습니다.</p> <table> <thead> <tr> <th>모드</th> <th>입력</th> <th>출력</th> <th>출력 파일 확장자</th> </tr> </thead> <tbody> <tr> <td><code>preserve</code></td> <td><code>&lt;div /&gt;</code></td> <td><code>&lt;div /&gt;</code></td> <td><code>.jsx</code></td> </tr> <tr> <td><code>react</code></td> <td><code>&lt;div /&gt;</code></td> <td><code>React.createElement(\"div\")</code></td> <td><code>.js</code></td> </tr> <tr> <td><code>react-native</code></td> <td><code>&lt;div /&gt;</code></td> <td><code>&lt;div /&gt;</code></td> <td><code>.js</code></td> </tr> <tr> <td><code>react-jsx</code></td> <td><code>&lt;div /&gt;</code></td> <td><code>_jsx(\"div\", {}, void 0);</code></td> <td><code>.js</code></td> </tr> <tr> <td><code>react-jsxdev</code></td> <td><code>&lt;div /&gt;</code></td> <td><code>_jsxDEV(\"div\", {}, void 0, false, {...}, this);</code></td> <td><code>.js</code></td> </tr> </tbody> </table> <p><code>--jsx</code> 커맨드 라인 플래그 또는 <a href=\"https://www.typescriptlang.org/tsconfig#jsx\">tsconfig.json</a> 파일 내 <code>jsx</code>의 해당 옵션을 통해 모드를 설정할 수 있습니다.</p> <blockquote> <p>*참고: <code>--jsxFactory</code> 옵션을 사용하여 React JSX 방출 시 사용할 JSX 팩토리 함수로 지정할 수 있습니다. (기본값은 <code>React.createElement</code>)</p> </blockquote> <h2 id=\"as-연산자\" style=\"position:relative;\">\n<code>as</code> 연산자</h2> <p>타입 단언 작성 방법은 다음과 같습니다:</p> <pre data-language=\"ts\">var foo = &lt;foo&gt;bar;</pre> <p>이는 변수 <code>bar</code>가 <code>foo</code> 타입을 갖도록 단언합니다. TypeScript 또한 단언을 위해 꺾쇠괄호를 사용하기 때문에, JSX의 구문과의 결합은 특정 구문 분석에 어려움이 발생할 수 있습니다. 결과적으로 TypeScript는 <code>.tsx</code>파일에서의 꺾쇠괄호 타입 단언을 허용하지 않습니다.</p> <p>이 구문은 <code>.tsx</code> 파일에서 사용될 수 없으므로, 대체 타입 단언 연산자인 <code>as</code>를 사용해야 합니다. <code>as</code> 연산자를 사용하여 위의 예제를 쉽게 재작성할 수 있습니다.</p> <pre data-language=\"ts\">var foo = bar as foo;</pre> <p><code>as</code> 연산자는 <code>.ts</code>와 <code>.tsx</code> 형식의 파일 모두에서 유효하며, 꺾쇠괄호 타입 단언 스타일과 동작이 같습니다.</p> <h2 id=\"타입-검사\" style=\"position:relative;\">타입 검사</h2> <p>JSX를 통한 타입 검사를 이해하기 위해서는 먼저 내장 요소와 값-기반 요소의 차이점에 대해 이해해야 합니다. <code>&lt;expr /&gt;</code>라는 JSX 표현이 주어졌을 때, <code>expr</code>는 환경에 내장된 요소(예: DOM 환경의 <code>div</code> 또는 <code>span</code> ) 또는 사용자 지정 컴포넌트를 참조할 것입니다. 이것이 중요한 이유 두 가지는 다음과 같습니다:</p> <ol> <li>React에서 내장 요소는 문자열 (<code>React.createElement(\"div\")</code>)로 방출되지만 생성한 구성 요소는 (<code>React.createElement(MyComponent)</code>)가 아닙니다.</li> <li>JSX 요소에 전달되는 속성의 타입은 다르게 조회되어야 합니다. 내장 요소의 속성은 <em>내재적으로</em> 알려져야 하지만, 컴포넌트는 각자의 속성 집합을 지정하고자 합니다.</li> </ol> <p>TypeScript는 이를 구분하기 위해 <a href=\"http://facebook.github.io/react/docs/jsx-in-depth.html#html-tags-vs.-react-components\">React와 같은 규칙</a>을 사용합니다. 내장 요소는 항상 소문자로 시작하고, 값-기반 요소는 항상 대문자로 시작합니다.</p> <h2 id=\"내장-요소\" style=\"position:relative;\">내장 요소</h2> <p>내장 요소는 특별한 인터페이스인 <code>JSX.IntrinsicElements</code>에서 조회됩니다. 기본적으로 인터페이스가 지정되지 않으면 그대로 진행되어 내장 함수는 타입 검사가 이루어지지 않을 것입니다. 그러나 이 인터페이스가 <em>있는</em> 경우 내장 함수의 이름이 <code>JSX.IntrinsicElements</code> 인터페이스에 있는 프로퍼티로 조회됩니다. 예를 들어:</p> <pre data-language=\"ts\">declare namespace JSX {\n  interface IntrinsicElements {\n    foo: any;\n  }\n}\n\n&lt;foo /&gt;; // 성공\n&lt;bar /&gt;; // 오류</pre> <p>위의 예시에서는 <code>&lt;foo /&gt;</code>는 정상 작동하나, <code>&lt;bar /&gt;</code>는 <code>JSX.IntrinsicElements</code>에 지정되지 않았기 때문에 오류가 발생합니다.</p> <blockquote> <p>참고: 아래와 같이 <code>JSX.IntrinsicElements</code>에 catch-all 문자열 인덱서 또한 지정할 수 있습니다.</p> </blockquote> <pre data-language=\"ts\">declare namespace JSX {\n  interface IntrinsicElements {\n    [elemName: string]: any;\n  }\n}</pre> <h2 id=\"값-기반-요소\" style=\"position:relative;\">값-기반 요소</h2> <p>값-기반 요소는 해당 스코프 내의 식별자로 간단하게 조회됩니다.</p> <pre data-language=\"ts\">import MyComponent from \"./myComponent\";\n\n&lt;MyComponent /&gt;; // 성공\n&lt;SomeOtherComponent /&gt;; // 오류</pre> <p>값-기반 요소를 정의하는 두 가지 방법은 다음과 같습니다.</p> <ol> <li>함수형 컴포넌트 (FC)</li> <li>클래스형 컴포넌트</li> </ol> <p>두 타입의 값-기반 요소는 JSX 표현에서 구별할 수 없으므로, TS는 우선 과부하 해결을 이용하여 함수형 컴포넌트로 표현을 해석합니다. 만약 해당 작업이 성공하면, TS는 선언에 대한 표현식 해석을 완료합니다. 만약 값이 함수형 컴포넌트로 확인되지 않으면, TS는 클래스 컴포넌트로 해석합니다. 그래도 실패한다면 TS는 오류를 보고합니다.</p> <h3 id=\"함수형-컴포넌트\" style=\"position:relative;\">함수형 컴포넌트</h3> <p>이름으로 알 수 있듯이, 컴포넌트는 첫 번째 인수가 <code>props</code> 객체인 JavaScript 함수로 정의됩니다. TS는 반환 타입을 <code>JSX.Element</code>에 할당이 가능해야 합니다.</p> <pre data-language=\"ts\">interface FooProp {\n  name: string;\n  X: number;\n  Y: number;\n}\n\ndeclare function AnotherComponent(prop: { name: string });\nfunction ComponentFoo(prop: FooProp) {\n  return &lt;AnotherComponent name={prop.name} /&gt;;\n}\n\nconst Button = (prop: { value: string }, context: { color: string }) =&gt; (\n  &lt;button /&gt;\n);</pre> <p>함수형 컴포넌트는 JavaScript 함수이기 때문에 과부하를 사용할 수 있습니다:</p> <pre data-language=\"ts\">interface ClickableProps {\n  children: JSX.Element[] | JSX.Element\n}\n\ninterface HomeProps extends ClickableProps {\n  home: JSX.Element;\n}\n\ninterface SideProps extends ClickableProps {\n  side: JSX.Element | string;\n}\n\nfunction MainButton(prop: HomeProps): JSX.Element;\nfunction MainButton(prop: SideProps): JSX.Element {\n  ...\n}</pre> <blockquote> <p>참고: 함수형 컴포넌트는 무 상태 함수형 컴포넌트(SFC)로 알려져 있습니다. 최근 버전의 React에서는 함수형 컴포넌트를 무 상태로 더는 간주하지 않으므로, <code>SFC</code> 타입과 그것의 별칭인 <code>StatelessComponent</code> 은 이제는 사용되지 않습니다.</p> </blockquote> <h3 id=\"클래스형-컴포넌트\" style=\"position:relative;\">클래스형 컴포넌트</h3> <p>클래스형 컴포넌트 타입을 정의하는 것도 가능합니다. 하지만 이를 위해서는 <em>요소 클래스 타입(element class type)</em> 과 *요소 인스턴스 타입(element instance type)*이라는 두 가지 용어를 이해하는 것이 좋습니다.</p> <p><code>&lt;Expr /&gt;</code>가 주어지면, <em>요소 클래스 타입</em>은 <code>Expr</code>타입입니다. 따라서 위의 예시에서 <code>MyComponent</code>가 ES6 클래스인 경우, 해당 클래스의 타입은 클래스의 생성자이고 전역입니다. 만약 <code>MyComponent</code>가 팩토리 함수인 경우, 해당 클래스의 타입은 해당 함수입니다.</p> <p>한 번 클래스의 타입이 결정되면, 인스턴스 타입은 클래스 타입의 생성 또는 호출 시그니처(두 가지 중 존재하는 것)의 반환 타입의 결합으로 결정됩니다. 다시 말하지만, ES6 클래스의 경우 인스턴스 타입은 해당 클래스 인스턴스의 타입이어야 하고, 팩토리 함수의 경우 함수에 의해 반환된 값의 타입이어야 합니다.</p> <pre data-language=\"ts\">class MyComponent {\n  render() {}\n}\n\n// 생성 시그니처 사용\nvar myComponent = new MyComponent();\n\n// 요소 클래스 타입 =&gt; MyComponent\n// 요소 인스턴스 타입 =&gt; { render: () =&gt; void }\n\nfunction MyFactoryFunction() {\n  return {\n    render: () =&gt; {},\n  };\n}\n\n// 호출 시그니처 사용\nvar myComponent = MyFactoryFunction();\n\n// 요소 클래스 타입 =&gt; FactoryFunction\n// 요소 인스턴스 타입 =&gt; { render: () =&gt; void }</pre> <p>요소 인스턴스 타입은 <code> JSX.ElementClass</code>에 할당이 가능해야 하며, 그렇지 않으면 오류가 발생합니다. 기본적으로 <code>JSX.ElementClass</code>는 <code>{}</code>이지만, 적절한 인터페이스를 따르는 타입으로만 JSX 사용을 제한하도록 확장할 수 있습니다.</p> <pre data-language=\"ts\">declare namespace JSX {\n  interface ElementClass {\n    render: any;\n  }\n}\n\nclass MyComponent {\n  render() {}\n}\nfunction MyFactoryFunction() {\n  return { render: () =&gt; {} };\n}\n\n&lt;MyComponent /&gt;; // 성공\n&lt;MyFactoryFunction /&gt;; // 성공\n\nclass NotAValidComponent {}\nfunction NotAValidFactoryFunction() {\n  return {};\n}\n\n&lt;NotAValidComponent /&gt;; // 오류\n&lt;NotAValidFactoryFunction /&gt;; // 오류</pre> <h2 id=\"속성-타입-검사\" style=\"position:relative;\">속성 타입 검사</h2> <p>속성 타입 검사를 위해서는 먼저 <em>요소 속성 타입</em>을 결정해야 합니다. 이는 내장 요소와 값-기반 요소에서 약간의 차이가 있습니다.</p> <p>내장 요소의 경우, 요소 속성 타입은 <code>JSX.IntrinsicElements</code> 내 프로퍼티의 타입입니다.</p> <pre data-language=\"ts\">declare namespace JSX {\n  interface IntrinsicElements {\n    foo: { bar?: boolean };\n  }\n}\n\n// 'foo'의 요소 속성 타입은 '{bar?: boolean}'\n&lt;foo bar /&gt;;</pre> <p>값-기반 요소의 경우, 이는 약간 더 복잡합니다. 요소 속성 타입은 이전에 결정된 <em>요소 인스턴스 타입</em> 의 프로퍼티 타입으로 결정됩니다. 사용할 프로퍼티는 <code>JSX.ElementAttributesProperty</code>에 의해 결정됩니다. 이는 단일 프로퍼티로 선언되어야 합니다. 이후에는 해당 프로퍼티의 이름을 사용합니다. TypeScript 2.8부터는 <code>JSX.ElementAttributesProperty</code> 를 제공하지 않을 경우, 클래스 요소의 생성자 또는 함수형 컴포넌트의 호출의 첫 번째 매개변수의 타입을 대신 사용할 수 있습니다.</p> <pre data-language=\"ts\">declare namespace JSX {\n  interface ElementAttributesProperty {\n    props; // 사용할 프로퍼티 이름 지정\n  }\n}\n\nclass MyComponent {\n  // 요소 인스턴스 타입의 프로퍼티 지정\n  props: {\n    foo?: string;\n  };\n}\n\n// 'MyComponent'의 요소 속성 타입은 '{foo?: string}'\n&lt;MyComponent foo=\"bar\" /&gt;;</pre> <p>요소 속성 타입은 JSX에서 속성의 타입 검사에 사용됩니다. 선택적 및 필수적인 프로퍼티들이 지원됩니다.</p> <pre data-language=\"ts\">declare namespace JSX {\n  interface IntrinsicElements {\n    foo: { requiredProp: string; optionalProp?: number };\n  }\n}\n\n&lt;foo requiredProp=\"bar\" /&gt;; // 성공\n&lt;foo requiredProp=\"bar\" optionalProp={0} /&gt;; // 성공\n&lt;foo /&gt;; // 오류, requiredProp이 누락됨\n&lt;foo requiredProp={0} /&gt;; // 오류, requiredProp은 문자열이여야 함\n&lt;foo requiredProp=\"bar\" unknownProp /&gt;; // 오류, unknownProp는 존재하지 않음\n&lt;foo requiredProp=\"bar\" some-unknown-prop /&gt;; // 성공, 'some-unknown-prop'는 유효한 식별자가 아니기 때문</pre> <blockquote> <p>참고: 속성의 이름이 유효한 식별자(<em>data-*</em> 속성 등)인 경우, 요소 속성 타입을 찾을 수 없는 경우에도 이를 오류로 간주하지 않습니다.</p> </blockquote> <p>추가로 <code>JSX.IntrinsicAttributes</code> 인터페이스는 일반적으로 컴포넌트의 props 또는 인수로 사용되지 않는 JSX 프레임워크의 사용을 위한 추가적인 프로퍼티를 지정할 수 있습니다. - 예를 들면 React의 <code>key</code>. 더 나아가서, <code>JSX.IntrinsicClassAttributes&lt;T&gt;</code> 제네릭 타입 또한 클래스형 컴포넌트를 위한 추가적인 속성의 유형과 동일하게 지정할 수 있습니다(함수형 컴포넌트는 불가능). 해당 타입의 경우, 제네릭 매개변수는 클래스 인스턴스 타입에 해당합니다. React에서는 <code>Ref&lt;T&gt;</code>의 타입의 <code>ref</code> 속성을 허용하기 위하여 사용됩니다. 일반적으로 JSX 프레임워크 사용자가 모든 태그에 특정 속성을 제공할 필요가 없는 경우, 이 인터페이스의 모든 프로퍼티는 선택적이어야 합니다.</p> <p>스프레드 연산자 또한 동작합니다:</p> <pre data-language=\"ts\">var props = { requiredProp: \"bar\" };\n&lt;foo {...props} /&gt;; // 성공\n\nvar badProps = {};\n&lt;foo {...badProps} /&gt;; // 오류</pre> <h2 id=\"자식-타입-검사\" style=\"position:relative;\">자식 타입 검사</h2> <p>TypeScript 2.3부터, TS는 <em>자식(children)</em> 타입 검사를 도입했습니다. <em>자식</em>은 자식 <em>JSXExpressions</em>이 속성에 삽입하고자 하는 <em>요소 속성 타입</em>의 특수 프로퍼티입니다. TS가 <em>props</em> 명을 결정하기 위해 <code>JSX.ElementAttributesProperty</code>를 사용하는 것과 유사하게, TS는 <em>자식</em> 내의 props명을 결정하기 위하여 <code>JSX.ElementChildrenAttribute</code>를 사용합니다. <code>JSX.ElementChildrenAttribute</code> 는 단일 프로퍼티로 정의되어야만 합니다.</p> <pre data-language=\"ts\">declare namespace JSX {\n  interface ElementChildrenAttribute {\n    children: {}; // 사용할 자식의 이름을 지정\n  }\n}</pre> <pre data-language=\"ts\">&lt;div&gt;\n  &lt;h1&gt;Hello&lt;/h1&gt;\n&lt;/div&gt;;\n\n&lt;div&gt;\n  &lt;h1&gt;Hello&lt;/h1&gt;\n  World\n&lt;/div&gt;;\n\nconst CustomComp = (props) =&gt; &lt;div&gt;{props.children}&lt;/div&gt;\n&lt;CustomComp&gt;\n  &lt;div&gt;Hello World&lt;/div&gt;\n  {\"This is just a JS expression...\" + 1000}\n&lt;/CustomComp&gt;</pre> <p>다른 속성과 같이<em>자식</em>의 타입도 지정할 수 있습니다. 예를 들어서 <a href=\"https://github.com/DefinitelyTyped/DefinitelyTyped/tree/master/types/react\">React 타이핑</a>을 사용하는 경우, 이는 기본 타입을 오버라이드 할 것입니다.</p> <pre data-language=\"ts\">interface PropsType {\n  children: JSX.Element\n  name: string\n}\n\nclass Component extends React.Component&lt;PropsType, {}&gt; {\n  render() {\n    return (\n      &lt;h2&gt;\n        {this.props.children}\n      &lt;/h2&gt;\n    )\n  }\n}\n\n// OK\n&lt;Component name=\"foo\"&gt;\n  &lt;h1&gt;Hello World&lt;/h1&gt;\n&lt;/Component&gt;\n\n// 오류: 자식은 JSX.Element의 배열이 아닌 JSX.Element 타입입니다\n&lt;Component name=\"bar\"&gt;\n  &lt;h1&gt;Hello World&lt;/h1&gt;\n  &lt;h2&gt;Hello World&lt;/h2&gt;\n&lt;/Component&gt;\n\n// 오류: 자식은 JSX.Element의 배열 또는 문자열이 아닌 JSX.Element 타입입니다\n&lt;Component name=\"baz\"&gt;\n  &lt;h1&gt;Hello&lt;/h1&gt;\n  World\n&lt;/Component&gt;</pre> <h2 id=\"jsx-결과-타입\" style=\"position:relative;\">JSX 결과 타입</h2> <p>기본적으로 JSX 표현 식의 결괏값은 <code>any</code> 타입입니다. <code>JSX.Element</code> 인터페이스를 통해 해당 타입으로 변경할 수 있습니다. 그러나 JSX 내 요소, 속성 혹은 자식의 정보는 해당 인터페이스를 통해 검색할 수 없습니다. 해당 인터페이스는 블랙박스(black box)입니다.</p> <h2 id=\"표현-식-포함하기\" style=\"position:relative;\">표현 식 포함하기</h2> <p>JSX는 태그 사이에서의 표현 식을 중괄호(<code>{ }</code>)에 넣어 사용합니다.</p> <pre data-language=\"ts\">var a = (\n  &lt;div&gt;\n    {[\"foo\", \"bar\"].map((i) =&gt; (\n      &lt;span&gt;{i / 2}&lt;/span&gt;\n    ))}\n  &lt;/div&gt;\n);</pre> <p>위의 코드는 문자열을 통해 숫자를 나눌 수 없으므로 결과로 오류가 발생할 것입니다. <code> preserve</code> 옵션을 사용한 출력은 다음과 같습니다:</p> <pre data-language=\"ts\">var a = (\n  &lt;div&gt;\n    {[\"foo\", \"bar\"].map(function (i) {\n      return &lt;span&gt;{i / 2}&lt;/span&gt;;\n    })}\n  &lt;/div&gt;\n);</pre> <h2 id=\"react-통합\" style=\"position:relative;\">React 통합</h2> <p>React와 JSX를 함께 사용하기 위해서는 <a href=\"https://github.com/DefinitelyTyped/DefinitelyTyped/tree/master/types/react\">React 타이핑</a>을 사용해야 합니다. 이 타이핑은 React와 사용하기 위한 적절한 <code>JSX</code> 네임스페이스를 정의합니다.</p> <pre data-language=\"ts\">/// &lt;reference path=\"react.d.ts\" /&gt;\n\ninterface Props {\n  foo: string;\n}\n\nclass MyComponent extends React.Component&lt;Props, {}&gt; {\n  render() {\n    return &lt;span&gt;{this.props.foo}&lt;/span&gt;;\n  }\n}\n\n&lt;MyComponent foo=\"bar\" /&gt;; // 성공\n&lt;MyComponent foo={0} /&gt;; // 오류</pre> <h3 id=\"jsx-구성\" style=\"position:relative;\">JSX 구성</h3> <p>JSX 사용자 정의에 사용되는 다양한 컴파일러 플래그가 있으며, 이는 컴파일러 플래그와 인라인 파일별 프라그마로 동작합니다. 자세한 내용은 tsconfig 참조 페이지를 통해 배울 수 있습니다:</p> <ul> <li><a href=\"https://www.typescriptlang.org/tsconfig/#jsxFactory\"><code>jsxFactory</code></a></li> <li><a href=\"https://www.typescriptlang.org/tsconfig/#jsxFragmentFactory\"><code>jsxFragmentFactory</code></a></li> <li><a href=\"https://www.typescriptlang.org/tsconfig/#jsxImportSource\"><code>jsxImportSource</code></a></li> </ul><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2012-2023 Microsoft<br>Licensed under the Apache License, Version 2.0.<br>\n    <a href=\"https://www.typescriptlang.org/ko/docs/handbook/jsx.html\" class=\"_attribution-link\">https://www.typescriptlang.org/ko/docs/handbook/jsx.html</a>\n  </p>\n</div>\n","tsconfig":"<h1>TSConfig Reference</h1>\n\n<div class=\"tsconfig main-content-block\">\n<h2>Compiler Options</h2>\n<div class=\"tsconfig-quick-nav\">\n\n<div class=\"tsconfig-quick-nav-category\">\n<h5 id=\"quick-nav-Top Level\">Top Level</h5>\n<ol aria-labelledby=\"quick-nav-Top Level\">\n<li><code><a href=\"#files\">files</a><span>, </span></code></li>\n<li><code><a href=\"#extends\">extends</a><span>, </span></code></li>\n<li><code><a href=\"#include\">include</a><span>, </span></code></li>\n<li><code><a href=\"#exclude\">exclude</a><span> and </span></code></li>\n<li><code><a href=\"#references\">references</a></code></li>\n</ol>\n</div>\n</div>\n<div class=\"tsconfig-quick-nav grouped\">\n<h4><code><a href=\"#compilerOptions\">\"compilerOptions\"</a></code></h4>\n<div class=\"tsconfig-quick-nav-category\">\n<h5 id=\"quick-nav-Type_Checking_6248\">Type Checking</h5>\n<ol aria-labelledby=\"quick-nav-Type_Checking_6248\">\n<li><code><a href=\"#allowUnreachableCode\">allowUnreachableCode</a><span>, </span></code></li>\n<li><code><a href=\"#allowUnusedLabels\">allowUnusedLabels</a><span>, </span></code></li>\n<li><code><a href=\"#alwaysStrict\">alwaysStrict</a><span>, </span></code></li>\n<li><code><a href=\"#exactOptionalPropertyTypes\">exactOptionalPropertyTypes</a><span>, </span></code></li>\n<li><code><a href=\"#noFallthroughCasesInSwitch\">noFallthroughCasesInSwitch</a><span>, </span></code></li>\n<li><code><a href=\"#noImplicitAny\">noImplicitAny</a><span>, </span></code></li>\n<li><code><a href=\"#noImplicitOverride\">noImplicitOverride</a><span>, </span></code></li>\n<li><code><a href=\"#noImplicitReturns\">noImplicitReturns</a><span>, </span></code></li>\n<li><code><a href=\"#noImplicitThis\">noImplicitThis</a><span>, </span></code></li>\n<li><code><a href=\"#noPropertyAccessFromIndexSignature\">noPropertyAccessFromIndexSignature</a><span>, </span></code></li>\n<li><code><a href=\"#noUncheckedIndexedAccess\">noUncheckedIndexedAccess</a><span>, </span></code></li>\n<li><code><a href=\"#noUnusedLocals\">noUnusedLocals</a><span>, </span></code></li>\n<li><code><a href=\"#noUnusedParameters\">noUnusedParameters</a><span>, </span></code></li>\n<li><code><a href=\"#strict\">strict</a><span>, </span></code></li>\n<li><code><a href=\"#strictBindCallApply\">strictBindCallApply</a><span>, </span></code></li>\n<li><code><a href=\"#strictFunctionTypes\">strictFunctionTypes</a><span>, </span></code></li>\n<li><code><a href=\"#strictNullChecks\">strictNullChecks</a><span>, </span></code></li>\n<li><code><a href=\"#strictPropertyInitialization\">strictPropertyInitialization</a><span> and </span></code></li>\n<li><code><a href=\"#useUnknownInCatchVariables\">useUnknownInCatchVariables</a></code></li>\n</ol>\n</div>\n<div class=\"tsconfig-quick-nav-category\">\n<h5 id=\"quick-nav-Modules_6244\">Modules</h5>\n<ol aria-labelledby=\"quick-nav-Modules_6244\">\n<li><code><a href=\"#allowArbitraryExtensions\">allowArbitraryExtensions</a><span>, </span></code></li>\n<li><code><a href=\"#allowImportingTsExtensions\">allowImportingTsExtensions</a><span>, </span></code></li>\n<li><code><a href=\"#allowUmdGlobalAccess\">allowUmdGlobalAccess</a><span>, </span></code></li>\n<li><code><a href=\"#baseUrl\">baseUrl</a><span>, </span></code></li>\n<li><code><a href=\"#customConditions\">customConditions</a><span>, </span></code></li>\n<li><code><a href=\"#module\">module</a><span>, </span></code></li>\n<li><code><a href=\"#moduleResolution\">moduleResolution</a><span>, </span></code></li>\n<li><code><a href=\"#moduleSuffixes\">moduleSuffixes</a><span>, </span></code></li>\n<li><code><a href=\"#noResolve\">noResolve</a><span>, </span></code></li>\n<li><code><a href=\"#paths\">paths</a><span>, </span></code></li>\n<li><code><a href=\"#resolveJsonModule\">resolveJsonModule</a><span>, </span></code></li>\n<li><code><a href=\"#resolvePackageJsonExports\">resolvePackageJsonExports</a><span>, </span></code></li>\n<li><code><a href=\"#resolvePackageJsonImports\">resolvePackageJsonImports</a><span>, </span></code></li>\n<li><code><a href=\"#rootDir\">rootDir</a><span>, </span></code></li>\n<li><code><a href=\"#rootDirs\">rootDirs</a><span>, </span></code></li>\n<li><code><a href=\"#typeRoots\">typeRoots</a><span> and </span></code></li>\n<li><code><a href=\"#types\">types</a></code></li>\n</ol>\n</div>\n<div class=\"tsconfig-quick-nav-category\">\n<h5 id=\"quick-nav-Emit_6246\">Emit</h5>\n<ol aria-labelledby=\"quick-nav-Emit_6246\">\n<li><code><a href=\"#declaration\">declaration</a><span>, </span></code></li>\n<li><code><a href=\"#declarationDir\">declarationDir</a><span>, </span></code></li>\n<li><code><a href=\"#declarationMap\">declarationMap</a><span>, </span></code></li>\n<li><code><a href=\"#downlevelIteration\">downlevelIteration</a><span>, </span></code></li>\n<li><code><a href=\"#emitBOM\">emitBOM</a><span>, </span></code></li>\n<li><code><a href=\"#emitDeclarationOnly\">emitDeclarationOnly</a><span>, </span></code></li>\n<li><code><a href=\"#importHelpers\">importHelpers</a><span>, </span></code></li>\n<li><code><a href=\"#importsNotUsedAsValues\">importsNotUsedAsValues</a><span>, </span></code></li>\n<li><code><a href=\"#inlineSourceMap\">inlineSourceMap</a><span>, </span></code></li>\n<li><code><a href=\"#inlineSources\">inlineSources</a><span>, </span></code></li>\n<li><code><a href=\"#mapRoot\">mapRoot</a><span>, </span></code></li>\n<li><code><a href=\"#newLine\">newLine</a><span>, </span></code></li>\n<li><code><a href=\"#noEmit\">noEmit</a><span>, </span></code></li>\n<li><code><a href=\"#noEmitHelpers\">noEmitHelpers</a><span>, </span></code></li>\n<li><code><a href=\"#noEmitOnError\">noEmitOnError</a><span>, </span></code></li>\n<li><code><a href=\"#outDir\">outDir</a><span>, </span></code></li>\n<li><code><a href=\"#outFile\">outFile</a><span>, </span></code></li>\n<li><code><a href=\"#preserveConstEnums\">preserveConstEnums</a><span>, </span></code></li>\n<li><code><a href=\"#preserveValueImports\">preserveValueImports</a><span>, </span></code></li>\n<li><code><a href=\"#removeComments\">removeComments</a><span>, </span></code></li>\n<li><code><a href=\"#sourceMap\">sourceMap</a><span>, </span></code></li>\n<li><code><a href=\"#sourceRoot\">sourceRoot</a><span> and </span></code></li>\n<li><code><a href=\"#stripInternal\">stripInternal</a></code></li>\n</ol>\n</div>\n<div class=\"tsconfig-quick-nav-category\">\n<h5 id=\"quick-nav-JavaScript_Support_6247\">JavaScript Support</h5>\n<ol aria-labelledby=\"quick-nav-JavaScript_Support_6247\">\n<li><code><a href=\"#allowJs\">allowJs</a><span>, </span></code></li>\n<li><code><a href=\"#checkJs\">checkJs</a><span> and </span></code></li>\n<li><code><a href=\"#maxNodeModuleJsDepth\">maxNodeModuleJsDepth</a></code></li>\n</ol>\n</div>\n<div class=\"tsconfig-quick-nav-category\">\n<h5 id=\"quick-nav-Editor_Support_6249\">Editor Support</h5>\n<ol aria-labelledby=\"quick-nav-Editor_Support_6249\">\n<li><code><a href=\"#disableSizeLimit\">disableSizeLimit</a><span> and </span></code></li>\n<li><code><a href=\"#plugins\">plugins</a></code></li>\n</ol>\n</div>\n<div class=\"tsconfig-quick-nav-category\">\n<h5 id=\"quick-nav-Interop_Constraints_6252\">Interop Constraints</h5>\n<ol aria-labelledby=\"quick-nav-Interop_Constraints_6252\">\n<li><code><a href=\"#allowSyntheticDefaultImports\">allowSyntheticDefaultImports</a><span>, </span></code></li>\n<li><code><a href=\"#esModuleInterop\">esModuleInterop</a><span>, </span></code></li>\n<li><code><a href=\"#forceConsistentCasingInFileNames\">forceConsistentCasingInFileNames</a><span>, </span></code></li>\n<li><code><a href=\"#isolatedModules\">isolatedModules</a><span>, </span></code></li>\n<li><code><a href=\"#preserveSymlinks\">preserveSymlinks</a><span> and </span></code></li>\n<li><code><a href=\"#verbatimModuleSyntax\">verbatimModuleSyntax</a></code></li>\n</ol>\n</div>\n<div class=\"tsconfig-quick-nav-category\">\n<h5 id=\"quick-nav-Backwards_Compatibility_6253\">Backwards Compatibility</h5>\n<ol aria-labelledby=\"quick-nav-Backwards_Compatibility_6253\">\n<li><code><a href=\"#charset\">charset</a><span>, </span></code></li>\n<li><code><a href=\"#keyofStringsOnly\">keyofStringsOnly</a><span>, </span></code></li>\n<li><code><a href=\"#noImplicitUseStrict\">noImplicitUseStrict</a><span>, </span></code></li>\n<li><code><a href=\"#noStrictGenericChecks\">noStrictGenericChecks</a><span>, </span></code></li>\n<li><code><a href=\"#out\">out</a><span>, </span></code></li>\n<li><code><a href=\"#suppressExcessPropertyErrors\">suppressExcessPropertyErrors</a><span> and </span></code></li>\n<li><code><a href=\"#suppressImplicitAnyIndexErrors\">suppressImplicitAnyIndexErrors</a></code></li>\n</ol>\n</div>\n<div class=\"tsconfig-quick-nav-category\">\n<h5 id=\"quick-nav-Language_and_Environment_6254\">Language and Environment</h5>\n<ol aria-labelledby=\"quick-nav-Language_and_Environment_6254\">\n<li><code><a href=\"#emitDecoratorMetadata\">emitDecoratorMetadata</a><span>, </span></code></li>\n<li><code><a href=\"#experimentalDecorators\">experimentalDecorators</a><span>, </span></code></li>\n<li><code><a href=\"#jsx\">jsx</a><span>, </span></code></li>\n<li><code><a href=\"#jsxFactory\">jsxFactory</a><span>, </span></code></li>\n<li><code><a href=\"#jsxFragmentFactory\">jsxFragmentFactory</a><span>, </span></code></li>\n<li><code><a href=\"#jsxImportSource\">jsxImportSource</a><span>, </span></code></li>\n<li><code><a href=\"#lib\">lib</a><span>, </span></code></li>\n<li><code><a href=\"#moduleDetection\">moduleDetection</a><span>, </span></code></li>\n<li><code><a href=\"#noLib\">noLib</a><span>, </span></code></li>\n<li><code><a href=\"#reactNamespace\">reactNamespace</a><span>, </span></code></li>\n<li><code><a href=\"#target\">target</a><span> and </span></code></li>\n<li><code><a href=\"#useDefineForClassFields\">useDefineForClassFields</a></code></li>\n</ol>\n</div>\n<div class=\"tsconfig-quick-nav-category\">\n<h5 id=\"quick-nav-Compiler_Diagnostics_6251\">Compiler Diagnostics</h5>\n<ol aria-labelledby=\"quick-nav-Compiler_Diagnostics_6251\">\n<li><code><a href=\"#diagnostics\">diagnostics</a><span>, </span></code></li>\n<li><code><a href=\"#explainFiles\">explainFiles</a><span>, </span></code></li>\n<li><code><a href=\"#extendedDiagnostics\">extendedDiagnostics</a><span>, </span></code></li>\n<li><code><a href=\"#generateCpuProfile\">generateCpuProfile</a><span>, </span></code></li>\n<li><code><a href=\"#listEmittedFiles\">listEmittedFiles</a><span>, </span></code></li>\n<li><code><a href=\"#listFiles\">listFiles</a><span> and </span></code></li>\n<li><code><a href=\"#traceResolution\">traceResolution</a></code></li>\n</ol>\n</div>\n<div class=\"tsconfig-quick-nav-category\">\n<h5 id=\"quick-nav-Projects_6255\">Projects</h5>\n<ol aria-labelledby=\"quick-nav-Projects_6255\">\n<li><code><a href=\"#composite\">composite</a><span>, </span></code></li>\n<li><code><a href=\"#disableReferencedProjectLoad\">disableReferencedProjectLoad</a><span>, </span></code></li>\n<li><code><a href=\"#disableSolutionSearching\">disableSolutionSearching</a><span>, </span></code></li>\n<li><code><a href=\"#disableSourceOfProjectReferenceRedirect\">disableSourceOfProjectReferenceRedirect</a><span>, </span></code></li>\n<li><code><a href=\"#incremental\">incremental</a><span> and </span></code></li>\n<li><code><a href=\"#tsBuildInfoFile\">tsBuildInfoFile</a></code></li>\n</ol>\n</div>\n<div class=\"tsconfig-quick-nav-category\">\n<h5 id=\"quick-nav-Output_Formatting_6256\">Output Formatting</h5>\n<ol aria-labelledby=\"quick-nav-Output_Formatting_6256\">\n<li><code><a href=\"#noErrorTruncation\">noErrorTruncation</a><span>, </span></code></li>\n<li><code><a href=\"#preserveWatchOutput\">preserveWatchOutput</a><span> and </span></code></li>\n<li><code><a href=\"#pretty\">pretty</a></code></li>\n</ol>\n</div>\n<div class=\"tsconfig-quick-nav-category\">\n<h5 id=\"quick-nav-Completeness_6257\">Completeness</h5>\n<ol aria-labelledby=\"quick-nav-Completeness_6257\">\n<li><code><a href=\"#skipDefaultLibCheck\">skipDefaultLibCheck</a><span> and </span></code></li>\n<li><code><a href=\"#skipLibCheck\">skipLibCheck</a></code></li>\n</ol>\n</div>\n<div class=\"tsconfig-quick-nav-category\">\n<h5 id=\"quick-nav-Command_line_Options_6171\">Command Line</h5>\n\n</div>\n<div class=\"tsconfig-quick-nav-category\">\n<h5 id=\"quick-nav-Watch_and_Build_Modes_6250\">Watch Options</h5>\n<ol aria-labelledby=\"quick-nav-Watch_and_Build_Modes_6250\"><li><code><a href=\"#assumeChangesOnlyAffectDirectDependencies\">assumeChangesOnlyAffectDirectDependencies</a></code></li></ol>\n</div>\n</div>\n<div class=\"tsconfig-quick-nav grouped\">\n<h4><code><a href=\"#watchOptions\">\"watchOptions\"</a></code></h4>\n<div class=\"tsconfig-quick-nav-category\">\n<h5 id=\"quick-nav-watchOptions\">watchOptions</h5>\n<ol aria-labelledby=\"quick-nav-watchOptions\">\n<li><code><a href=\"#watch-watchFile\">watchFile</a><span>, </span></code></li>\n<li><code><a href=\"#watch-watchDirectory\">watchDirectory</a><span>, </span></code></li>\n<li><code><a href=\"#watch-fallbackPolling\">fallbackPolling</a><span>, </span></code></li>\n<li><code><a href=\"#watch-synchronousWatchDirectory\">synchronousWatchDirectory</a><span>, </span></code></li>\n<li><code><a href=\"#watch-excludeDirectories\">excludeDirectories</a><span> and </span></code></li>\n<li><code><a href=\"#watch-excludeFiles\">excludeFiles</a></code></li>\n</ol>\n</div>\n</div>\n<div class=\"tsconfig-quick-nav grouped\">\n<h4><code><a href=\"#typeAcquisition\">\"typeAcquisition\"</a></code></h4>\n<div class=\"tsconfig-quick-nav-category\">\n<h5 id=\"quick-nav-typeAcquisition\">typeAcquisition</h5>\n<ol aria-labelledby=\"quick-nav-typeAcquisition\">\n<li><code><a href=\"#type-enable\">enable</a><span>, </span></code></li>\n<li><code><a href=\"#type-include\">include</a><span>, </span></code></li>\n<li><code><a href=\"#type-exclude\">exclude</a><span> and </span></code></li>\n<li><code><a href=\"#type-disableFilenameBasedTypeAcquisition\">disableFilenameBasedTypeAcquisition</a></code></li>\n</ol>\n</div>\n</div>\n</div>\n<div>\n<div><article id=\"Top Level\"> <h3 id=\"root-fields\" style=\"position:relative;\">Root Fields</h3> <p>Starting up are the root options in the TSConfig - these options relate to how your TypeScript or JavaScript project is set up.</p> <div> <section> <h3 id=\"files-config\"> Files - <code>files</code>\n</h3> <div> <div> <p>프로그램에 포함할 파일 허용 목록을 지정합니다. 파일을 찾지 못하면 오류가 발생합니다.</p> <pre tsconfig=\"true\" data-language=\"typescript\">{\n  \"compilerOptions\": {},\n  \"files\": [\n    \"core.ts\",\n    \"sys.ts\",\n    \"types.ts\",\n    \"scanner.ts\",\n    \"parser.ts\",\n    \"utilities.ts\",\n    \"binder.ts\",\n    \"checker.ts\",\n    \"tsc.ts\"\n  ]\n}</pre> <p>파일 수가 적어 파일 참조에 glob을 사용할 필요가 없을 때 유용합니다. 필요한 경우 <a href=\"#include\"><code>include</code></a>을 사용합니다.</p> </div> <ul>\n<li>\n<span>Default:</span><p><code>false</code></p> </li> <li>\n<span>Related:</span><ul>\n<li>\n<p><a href=\"#include\" aria-label=\"Jump to compiler option info for include\"><code>include</code></a></p> </li>\n<li>\n<p><a href=\"#exclude\" aria-label=\"Jump to compiler option info for exclude\"><code>exclude</code></a></p> </li>\n</ul>\n</li>\n</ul> </div></section> <section> <h3 id=\"extends-config\"> Extends - <code>extends</code>\n</h3> <div> <div> <p>The value of <code>extends</code> is a string which contains a path to another configuration file to inherit from. The path may use Node.js style resolution.</p> <p>The configuration from the base file are loaded first, then overridden by those in the inheriting config file. All relative paths found in the configuration file will be resolved relative to the configuration file they originated in.</p> <p>It’s worth noting that <a href=\"#files\"><code>files</code></a>, <a href=\"#include\"><code>include</code></a>, and <a href=\"#exclude\"><code>exclude</code></a> from the inheriting config file <em>overwrite</em> those from the base config file, and that circularity between configuration files is not allowed.</p> <p>Currently, the only top-level property that is excluded from inheritance is <a href=\"#references\"><code>references</code></a>.</p> <h5 id=\"example\" style=\"position:relative;\">Example</h5> <p><code>configs/base.json</code>:</p> <pre tsconfig=\"true\" data-language=\"typescript\">{\n  \"compilerOptions\": {\n    \"noImplicitAny\": true,\n    \"strictNullChecks\": true\n  }\n}</pre> <p><code>tsconfig.json</code>:</p> <pre tsconfig=\"true\" data-language=\"typescript\">{\n  \"extends\": \"./configs/base\",\n  \"files\": [\"main.ts\", \"supplemental.ts\"]\n}</pre> <p><code>tsconfig.nostrictnull.json</code>:</p> <pre tsconfig=\"true\" data-language=\"typescript\">{\n  \"extends\": \"./tsconfig\",\n  \"compilerOptions\": {\n    \"strictNullChecks\": false\n  }\n}</pre> <p>Properties with relative paths found in the configuration file, which aren’t excluded from inheritance, will be resolved relative to the configuration file they originated in.</p> </div> <ul>\n<li>\n<span>Default:</span><p><code>false</code></p> </li> <li>\n<span>Released:</span><p><a aria-label=\"Release notes for TypeScript 2.1\" href=\"https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-1.html\">2.1</a></p> </li>\n</ul> </div></section> <section> <h3 id=\"include-config\"> Include - <code>include</code>\n</h3> <div> <div> <p>프로그램에 포함할 파일 이름이나 패턴을 배열로 지정합니다. 이 파일 이름은 <code>tsconfig.json</code> 파일에 포함된 디렉터리를 기준으로 하여 결정됩니다.</p> <pre data-language=\"json\">{\n  \"include\": [\"src/**/*\", \"tests/**/*\"]\n}</pre> <p>위 문법은 아래와 같이 파일을 포함합니다.</p>  <pre data-language=\"typescript\">.\n├── scripts                ⨯\n│   ├── lint.ts            ⨯\n│   ├── update_deps.ts     ⨯\n│   └── utils.ts           ⨯\n├── src                    ✓\n│   ├── client             ✓\n│   │    ├── index.ts      ✓\n│   │    └── utils.ts      ✓\n│   ├── server             ✓\n│   │    └── index.ts      ✓\n├── tests                  ✓\n│   ├── app.test.ts        ✓\n│   ├── utils.ts           ✓\n│   └── tests.d.ts         ✓\n├── package.json\n├── tsconfig.json\n└── yarn.lock</pre> <p><code>include</code> 와 <code>exclude</code>는 글롭(glob) 패턴을 만들기 위한 와일드카드 문자를 지원합니다.:</p> <ul> <li>\n<code>*</code> 0개 혹은 그 이상의 문자를 매치합니다. (디렉터리 구분자를 제외하고)</li> <li>\n<code>?</code> 문자 한 개를 매치합니다. (디렉터리 구분자를 제외하고)</li> <li>\n<code>**/</code> 모든 하위 디렉터리를 매치합니다.</li> </ul> <p>만약 글롭 패턴에 파일 확장자가 포함되어있지 않다면 오직 지원되는 확장자를 가진 파일들만 포함됩니다. (e. g. <code>.ts</code>, <code>.tsx</code>, <code>.d.ts</code>가 기본적으로 포함되며, <code>allowJS</code>가 true로 설정되었을 경우에는 <code>.js</code>, <code>.jsx</code> 까지 포함)</p> </div> <ul>\n<li>\n<span>Default:</span><p><code>[]</code> if <a href=\"#files\"><code>files</code></a> is specified; <code>**/*</code> otherwise.</p> </li> <li>\n<span>Related:</span><ul>\n<li>\n<p><a href=\"#files\" aria-label=\"Jump to compiler option info for files\"><code>files</code></a></p> </li>\n<li>\n<p><a href=\"#exclude\" aria-label=\"Jump to compiler option info for exclude\"><code>exclude</code></a></p> </li>\n</ul>\n</li> <li>\n<span>Released:</span><p><a aria-label=\"Release notes for TypeScript 2.0\" href=\"https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-0.html\">2.0</a></p> </li>\n</ul> </div></section> <section> <h3 id=\"exclude-config\"> Exclude - <code>exclude</code>\n</h3> <div> <div> <p><code>include</code> 에서 파일을 포함할 때 생략할 파일 이름이나 패턴을 배열로 지정합니다.</p> <p><strong>중요</strong> : <code>exclude</code> 는 <em>오직</em> <code>include</code> 의 설정의 결과로 포함되는 파일만 변경합니다. <code>exclude</code> 로 지정된 파일은 코드상의 <code>types</code>를 포함하여, <code>import</code>에 의해 코드 베이스의 일부가 될 수 있습니다. 이는 <code>/// &lt;reference</code> 지시문 또는 <code>files</code> 목록에 지정되어 있기 때문입니다.</p> <p>이것은 파일이 코드 베이스에 포함되는 것을 <strong>방지</strong>하는 메커니즘이 아닙니다. 단순히 <code>include</code>의 설정이 찾은 내용만을 변경하게 됩니다.</p> </div> <ul>\n<li>\n<span>Default:</span><p>node_modules bower_components jspm_packages <a href=\"#outDir\"><code>outDir</code></a></p> </li> <li>\n<span>Related:</span><ul>\n<li>\n<p><a href=\"#include\" aria-label=\"Jump to compiler option info for include\"><code>include</code></a></p> </li>\n<li>\n<p><a href=\"#files\" aria-label=\"Jump to compiler option info for files\"><code>files</code></a></p> </li>\n</ul>\n</li>\n</ul> </div></section> <section> <h3 id=\"references-config\"> References - <code>references</code>\n</h3> <div> <div> <p>Project references are a way to structure your TypeScript programs into smaller pieces. Using Project References can greatly improve build and editor interaction times, enforce logical separation between components, and organize your code in new and improved ways.</p> <p>You can read more about how references works in the <a href=\"https://www.typescriptlang.org/docs/handbook/project-references.html\">Project References</a> section of the handbook</p> </div> <ul><li>\n<span>Default:</span><p><code>false</code></p> </li></ul> </div></section> </div> </article></div> <div><article id=\"compilerOptions\"> <h3 id=\"compiler-options\" style=\"position:relative;\">Compiler Options</h3> <p>These options make up the bulk of TypeScript’s configuration and it covers how the language should work.</p> <nav id=\"sticky\"><ul> <li><a href=\"#Type_Checking_6248\">Type Checking</a></li> <li><a href=\"#Modules_6244\">Modules</a></li> <li><a href=\"#Emit_6246\">Emit</a></li> <li><a href=\"#JavaScript_Support_6247\">JavaScript Support</a></li> <li><a href=\"#Editor_Support_6249\">Editor Support</a></li> <li><a href=\"#Interop_Constraints_6252\">Interop Constraints</a></li> <li><a href=\"#Backwards_Compatibility_6253\">Backwards Compatibility</a></li> <li><a href=\"#Language_and_Environment_6254\">Language and Environment</a></li> <li><a href=\"#Compiler_Diagnostics_6251\">Compiler Diagnostics</a></li> <li><a href=\"#Projects_6255\">Projects</a></li> <li><a href=\"#Output_Formatting_6256\">Output Formatting</a></li> <li><a href=\"#Completeness_6257\">Completeness</a></li> <li><a href=\"#Command_line_Options_6171\">Command Line</a></li> <li><a href=\"#Watch_and_Build_Modes_6250\">Watch Options</a></li> </ul></nav> <div> <div class=\"category\"> <h2 id=\"Type_Checking_6248\">Type Checking</h2> </div> <section> <h3 id=\"allowUnreachableCode-config\"> Allow Unreachable Code - <code>allowUnreachableCode</code>\n</h3> <div> <div> <p>When:</p> <ul> <li>\n<code>undefined</code> (default) provide suggestions as warnings to editors</li> <li>\n<code>true</code> unreachable code is ignored</li> <li>\n<code>false</code> raises compiler errors about unreachable code</li> </ul> <p>These warnings are only about code which is provably unreachable due to the use of JavaScript syntax, for example:</p> <pre data-language=\"ts\">function fn(n: number) {\n  if (n &gt; 5) {\n    return true;\n  } else {\n    return false;\n  }\n  return true;\n}</pre> <p>With <code>\"allowUnreachableCode\": false</code>:</p> <pre data-language=\"ts\">function fn(n: number) {\n  if (n &gt; 5) {\n    return true;\n  } else {\n    return false;\n  }\n  return true;\n}</pre> <p>This does not affect errors on the basis of code which <em>appears</em> to be unreachable due to type analysis.</p> </div> <ul><li>\n<span>Released:</span><p><a aria-label=\"Release notes for TypeScript 1.8\" href=\"https://www.typescriptlang.org/docs/handbook/release-notes/typescript-1-8.html\">1.8</a></p> </li></ul> </div></section> <section> <h3 id=\"allowUnusedLabels-config\"> Allow Unused Labels - <code>allowUnusedLabels</code>\n</h3> <div> <div> <p>When:</p> <ul> <li>\n<code>undefined</code> (default) provide suggestions as warnings to editors</li> <li>\n<code>true</code> unused labels are ignored</li> <li>\n<code>false</code> raises compiler errors about unused labels</li> </ul> <p>Labels are very rare in JavaScript and typically indicate an attempt to write an object literal:</p> <pre data-language=\"ts\">function verifyAge(age: number) {\n  // Forgot 'return' statement\n  if (age &gt; 18) {\n    verified: true;\n  }\n}</pre> </div> <ul><li>\n<span>Released:</span><p><a aria-label=\"Release notes for TypeScript 1.8\" href=\"https://www.typescriptlang.org/docs/handbook/release-notes/typescript-1-8.html\">1.8</a></p> </li></ul> </div></section> <section> <h3 id=\"alwaysStrict-config\"> Always Strict - <code>alwaysStrict</code>\n</h3> <div> <div> <p>파일을 ECMAScript 엄격 모드로 분석 하고, 각 소스 파일에 “use strict”를 생성합니다.</p> <p>ES5에 도입된 <a href=\"https://developer.mozilla.org/docs/Web/JavaScript/Reference/Strict_mode\">ECMAScript 엄격</a> 모드는 성능 향상을 위해 JavaScript 엔진의 런타임 동작을 변화시켜, 일련의 에러를 무시하지 않고 발생시킵니다.</p> </div> <ul>\n<li>\n<span>Recommended</span> </li> <li>\n<span>Default:</span><p><code>true</code> if <a href=\"#strict\"><code>strict</code></a>; <code>false</code> otherwise.</p> </li> <li>\n<span>Related:</span><ul><li>\n<p><a href=\"#strict\" aria-label=\"Jump to compiler option info for strict\"><code>strict</code></a></p> </li></ul>\n</li> <li>\n<span>Released:</span><p><a aria-label=\"Release notes for TypeScript 2.1\" href=\"https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-1.html\">2.1</a></p> </li>\n</ul> </div></section> <section> <h3 id=\"exactOptionalPropertyTypes-config\"> Exact Optional Property Types - <code>exactOptionalPropertyTypes</code>\n</h3> <div> <div> <p>With exactOptionalPropertyTypes enabled, TypeScript applies stricter rules around how it handles properties on <code>type</code> or <code>interfaces</code> which have a <code>?</code> prefix.</p> <p>For example, this interface declares that there is a property which can be one of two strings: ‘dark’ or ‘light’ or it should not be in the object.</p> <pre data-language=\"ts\">interface UserDefaults {\n  // The absence of a value represents 'system'\n  colorThemeOverride?: \"dark\" | \"light\";\n}</pre> <p>Without this flag enabled, there are three values which you can set <code>colorThemeOverride</code> to be: “dark”, “light” and <code>undefined</code>.</p> <p>Setting the value to <code>undefined</code> will allow most JavaScript runtime checks for the existence to fail, which is effectively falsy. However, this isn’t quite accurate; <code>colorThemeOverride: undefined</code> is not the same as <code>colorThemeOverride</code> not being defined. For example, <code>\"colorThemeOverride\" in settings</code> would have different behavior with <code>undefined</code> as the key compared to not being defined.</p> <p><code>exactOptionalPropertyTypes</code> makes TypeScript truly enforce the definition provided as an optional property:</p> <pre data-language=\"ts\">const settings = getUserSettings();\nsettings.colorThemeOverride = \"dark\";\nsettings.colorThemeOverride = \"light\";\n \n// But not:\nsettings.colorThemeOverride = undefined;</pre> </div> <ul>\n<li>\n<span>Recommended</span> </li> <li>\n<span>Released:</span><p><a aria-label=\"Release notes for TypeScript 4.4\" href=\"https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-4.html\">4.4</a></p> </li>\n</ul> </div></section> <section> <h3 id=\"noFallthroughCasesInSwitch-config\"> No Fallthrough Cases In Switch - <code>noFallthroughCasesInSwitch</code>\n</h3> <div> <div> <p>Report errors for fallthrough cases in switch statements. Ensures that any non-empty case inside a switch statement includes either <code>break</code>, <code>return</code>, or <code>throw</code>. This means you won’t accidentally ship a case fallthrough bug.</p> <pre data-language=\"ts\">const a: number = 6;\n \nswitch (a) {\n  case 0:\n    console.log(\"even\");\n  case 1:\n    console.log(\"odd\");\n    break;\n}</pre> </div> <ul><li>\n<span>Released:</span><p><a aria-label=\"Release notes for TypeScript 1.8\" href=\"https://www.typescriptlang.org/docs/handbook/release-notes/typescript-1-8.html\">1.8</a></p> </li></ul> </div></section> <section> <h3 id=\"noImplicitAny-config\"> No Implicit Any - <code>noImplicitAny</code>\n</h3> <div> <div> <p>타입이 표기되어 있지 않아, 타입 추론을 할 수 없을 때 TypeScript는 해당 변수의 타입을 <code>any</code>로 대체합니다.</p> <p>이것으로 인해 일부 오류가 누락될 수 있습니다. 예를 들면:</p> <pre data-language=\"ts\">function fn(s) {\n  // 오류가 아닌가요?\n  console.log(s.subtr(3));\n}\nfn(42);</pre> <p>그러나 <code>noImplicitAny</code>를 활성화하면 TypeScript는 <code>any</code>를 추론 할 때마다 오류를 발생시킵니다:</p> <pre data-language=\"ts\">function fn(s) {\n  console.log(s.subtr(3));\n}</pre> </div> <ul>\n<li>\n<span>Recommended</span> </li> <li>\n<span>Default:</span><p><code>true</code> if <a href=\"#strict\"><code>strict</code></a>; <code>false</code> otherwise.</p> </li> <li>\n<span>Related:</span><ul><li>\n<p><a href=\"#strict\" aria-label=\"Jump to compiler option info for strict\"><code>strict</code></a></p> </li></ul>\n</li>\n</ul> </div></section> <section> <h3 id=\"noImplicitOverride-config\"> No Implicit Override - <code>noImplicitOverride</code>\n</h3> <div> <div> <p>When working with classes which use inheritance, it’s possible for a sub-class to get “out of sync” with the functions it overloads when they are renamed in the base class.</p> <p>For example, imagine you are modeling a music album syncing system:</p> <pre data-language=\"ts\">class Album {\n  download() {\n    // Default behavior\n  }\n}\n \nclass SharedAlbum extends Album {\n  download() {\n    // Override to get info from many sources\n  }\n}</pre> <p>Then when you add support for machine-learning generated playlists, you refactor the <code>Album</code> class to have a ‘setup’ function instead:</p> <pre data-language=\"ts\">class Album {\n  setup() {\n    // Default behavior\n  }\n}\n \nclass MLAlbum extends Album {\n  setup() {\n    // Override to get info from algorithm\n  }\n}\n \nclass SharedAlbum extends Album {\n  download() {\n    // Override to get info from many sources\n  }\n}</pre> <p>In this case, TypeScript has provided no warning that <code>download</code> on <code>SharedAlbum</code> <em>expected</em> to override a function in the base class.</p> <p>Using <code>noImplicitOverride</code> you can ensure that the sub-classes never go out of sync, by ensuring that functions which override include the keyword <code>override</code>.</p> <p>The following example has <code>noImplicitOverride</code> enabled, and you can see the error received when <code>override</code> is missing:</p> <pre data-language=\"ts\">class Album {\n  setup() {}\n}\n \nclass MLAlbum extends Album {\n  override setup() {}\n}\n \nclass SharedAlbum extends Album {\n  setup() {}\n}</pre> </div> <ul><li>\n<span>Released:</span><p><a aria-label=\"Release notes for TypeScript 4.3\" href=\"https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-3.html\">4.3</a></p> </li></ul> </div></section> <section> <h3 id=\"noImplicitReturns-config\"> No Implicit Returns - <code>noImplicitReturns</code>\n</h3> <div> <div> <p>When enabled, TypeScript will check all code paths in a function to ensure they return a value.</p> <pre data-language=\"ts\">function lookupHeadphonesManufacturer(color: \"blue\" | \"black\"): string {\n  if (color === \"blue\") {\n    return \"beats\";\n  } else {\n    \"bose\";\n  }\n}</pre> </div> <ul><li>\n<span>Released:</span><p><a aria-label=\"Release notes for TypeScript 1.8\" href=\"https://www.typescriptlang.org/docs/handbook/release-notes/typescript-1-8.html\">1.8</a></p> </li></ul> </div></section> <section> <h3 id=\"noImplicitThis-config\"> No Implicit This - <code>noImplicitThis</code>\n</h3> <div> <div> <p>Raise error on ‘this’ expressions with an implied ‘any’ type.</p> <p>For example, the class below returns a function which tries to access <code>this.width</code> and <code>this.height</code> – but the context for <code>this</code> inside the function inside <code>getAreaFunction</code> is not the instance of the Rectangle.</p> <pre data-language=\"ts\">class Rectangle {\n  width: number;\n  height: number;\n \n  constructor(width: number, height: number) {\n    this.width = width;\n    this.height = height;\n  }\n \n  getAreaFunction() {\n    return function () {\n      return this.width * this.height;\n    };\n  }\n}</pre> </div> <ul>\n<li>\n<span>Recommended</span> </li> <li>\n<span>Default:</span><p><code>true</code> if <a href=\"#strict\"><code>strict</code></a>; <code>false</code> otherwise.</p> </li> <li>\n<span>Related:</span><ul><li>\n<p><a href=\"#strict\" aria-label=\"Jump to compiler option info for strict\"><code>strict</code></a></p> </li></ul>\n</li> <li>\n<span>Released:</span><p><a aria-label=\"Release notes for TypeScript 2.0\" href=\"https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-0.html\">2.0</a></p> </li>\n</ul> </div></section> <section> <h3 id=\"noPropertyAccessFromIndexSignature-config\"> No Property Access From Index Signature - <code>noPropertyAccessFromIndexSignature</code>\n</h3> <div> <div> <p>This setting ensures consistency between accessing a field via the “dot” (<code>obj.key</code>) syntax, and “indexed” (<code>obj[\"key\"]</code>) and the way which the property is declared in the type.</p> <p>Without this flag, TypeScript will allow you to use the dot syntax to access fields which are not defined:</p> <pre data-language=\"ts\">interface GameSettings {\n  // Known up-front properties\n  speed: \"fast\" | \"medium\" | \"slow\";\n  quality: \"high\" | \"low\";\n \n  // Assume anything unknown to the interface\n  // is a string.\n  [key: string]: string;\n}\n \nconst settings = getSettings();\nsettings.speed;\nsettings.quality;\n \n// Unknown key accessors are allowed on\n// this object, and are `string`\nsettings.username;</pre> <p>Turning the flag on will raise an error because the unknown field uses dot syntax instead of indexed syntax.</p> <pre data-language=\"ts\">const settings = getSettings();\nsettings.speed;\nsettings.quality;\n \n// This would need to be settings[\"username\"];\nsettings.username;</pre> <p>The goal of this flag is to signal intent in your calling syntax about how certain you are this property exists.</p> </div> <ul><li>\n<span>Released:</span><p><a aria-label=\"Release notes for TypeScript 4.2\" href=\"https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-2.html\">4.2</a></p> </li></ul> </div></section> <section> <h3 id=\"noUncheckedIndexedAccess-config\"> No Unchecked Indexed Access - <code>noUncheckedIndexedAccess</code>\n</h3> <div> <div> <p>TypeScript has a way to describe objects which have unknown keys but known values on an object, via index signatures.</p> <pre data-language=\"ts\">interface EnvironmentVars {\n  NAME: string;\n  OS: string;\n \n  // Unknown properties are covered by this index signature.\n  [propName: string]: string;\n}\n \ndeclare const env: EnvironmentVars;\n \n// Declared as existing\nconst sysName = env.NAME;\nconst os = env.OS;\n \n// Not declared, but because of the index\n// signature, then it is considered a string\nconst nodeEnv = env.NODE_ENV;</pre> <p>Turning on <code>noUncheckedIndexedAccess</code> will add <code>undefined</code> to any un-declared field in the type.</p> <pre data-language=\"ts\">declare const env: EnvironmentVars;\n \n// Declared as existing\nconst sysName = env.NAME;\nconst os = env.OS;\n \n// Not declared, but because of the index\n// signature, then it is considered a string\nconst nodeEnv = env.NODE_ENV;</pre> </div> <ul><li>\n<span>Released:</span><p><a aria-label=\"Release notes for TypeScript 4.1\" href=\"https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-1.html\">4.1</a></p> </li></ul> </div></section> <section> <h3 id=\"noUnusedLocals-config\"> No Unused Locals - <code>noUnusedLocals</code>\n</h3> <div> <div> <p>Report errors on unused local variables.</p> <pre data-language=\"ts\">const createKeyboard = (modelID: number) =&gt; {\n  const defaultModelID = 23;\n  return { type: \"keyboard\", modelID };\n};</pre> </div> <ul><li>\n<span>Released:</span><p><a aria-label=\"Release notes for TypeScript 2.0\" href=\"https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-0.html\">2.0</a></p> </li></ul> </div></section> <section> <h3 id=\"noUnusedParameters-config\"> No Unused Parameters - <code>noUnusedParameters</code>\n</h3> <div> <div> <p>Report errors on unused parameters in functions.</p> <pre data-language=\"ts\">const createDefaultKeyboard = (modelID: number) =&gt; {\n  const defaultModelID = 23;\n  return { type: \"keyboard\", modelID: defaultModelID };\n};</pre> </div> <ul><li>\n<span>Released:</span><p><a aria-label=\"Release notes for TypeScript 2.0\" href=\"https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-0.html\">2.0</a></p> </li></ul> </div></section> <section> <h3 id=\"strict-config\"> Strict - <code>strict</code>\n</h3> <div> <div> <p><code>strict</code> 플래그는 다양한 타입 검사를 가능하게 하여 프로그램 정확성을 더욱 보장합니다. strict 플래그를 켜는 것은 아래에 설명된 모든 <em>strict mode family</em> 옵션을 활성화하는 것과 같습니다. 필요에 따라 개별 strict mode family 검사를 끌 수 있습니다.</p> <p>향후 버전의 TypeScript는 이 플래그에서 추가적인 엄격한 검사를 도입할 수 있어, TypeScript를 업그레이드하면 프로그램에 새로운 타입 오류가 발생할 수도 있습니다. 적당히 가능할 때, 해당 플래그를 추가하여 동작을 비활성화합니다.</p> </div> <ul>\n<li>\n<span>Recommended</span> </li> <li>\n<span>Related:</span><ul>\n<li>\n<p><a href=\"#alwaysStrict\" aria-label=\"Jump to compiler option info for alwaysStrict\"><code>alwaysStrict</code></a></p> </li>\n<li>\n<p><a href=\"#strictNullChecks\" aria-label=\"Jump to compiler option info for strictNullChecks\"><code>strictNullChecks</code></a></p> </li>\n<li>\n<p><a href=\"#strictBindCallApply\" aria-label=\"Jump to compiler option info for strictBindCallApply\"><code>strictBindCallApply</code></a></p> </li>\n<li>\n<p><a href=\"#strictFunctionTypes\" aria-label=\"Jump to compiler option info for strictFunctionTypes\"><code>strictFunctionTypes</code></a></p> </li>\n<li>\n<p><a href=\"#strictPropertyInitialization\" aria-label=\"Jump to compiler option info for strictPropertyInitialization\"><code>strictPropertyInitialization</code></a></p> </li>\n<li>\n<p><a href=\"#noImplicitAny\" aria-label=\"Jump to compiler option info for noImplicitAny\"><code>noImplicitAny</code></a></p> </li>\n<li>\n<p><a href=\"#noImplicitThis\" aria-label=\"Jump to compiler option info for noImplicitThis\"><code>noImplicitThis</code></a></p> </li>\n<li>\n<p><a href=\"#useUnknownInCatchVariables\" aria-label=\"Jump to compiler option info for useUnknownInCatchVariables\"><code>useUnknownInCatchVariables</code></a></p> </li>\n</ul>\n</li> <li>\n<span>Released:</span><p><a aria-label=\"Release notes for TypeScript 2.3\" href=\"https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-3.html\">2.3</a></p> </li>\n</ul> </div></section> <section> <h3 id=\"strictBindCallApply-config\"> Strict Bind Call Apply - <code>strictBindCallApply</code>\n</h3> <div> <div> <p>When set, TypeScript will check that the built-in methods of functions <code>call</code>, <code>bind</code>, and <code>apply</code> are invoked with correct argument for the underlying function:</p> <pre data-language=\"ts\">// With strictBindCallApply on\nfunction fn(x: string) {\n  return parseInt(x);\n}\n \nconst n1 = fn.call(undefined, \"10\");\n \nconst n2 = fn.call(undefined, false);</pre> <p>Otherwise, these functions accept any arguments and will return <code>any</code>:</p> <pre data-language=\"ts\">// With strictBindCallApply off\nfunction fn(x: string) {\n  return parseInt(x);\n}\n \n// Note: No error; return type is 'any'\nconst n = fn.call(undefined, false);</pre> </div> <ul>\n<li>\n<span>Recommended</span> </li> <li>\n<span>Default:</span><p><code>true</code> if <a href=\"#strict\"><code>strict</code></a>; <code>false</code> otherwise.</p> </li> <li>\n<span>Related:</span><ul><li>\n<p><a href=\"#strict\" aria-label=\"Jump to compiler option info for strict\"><code>strict</code></a></p> </li></ul>\n</li> <li>\n<span>Released:</span><p><a aria-label=\"Release notes for TypeScript 3.2\" href=\"https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-2.html\">3.2</a></p> </li>\n</ul> </div></section> <section> <h3 id=\"strictFunctionTypes-config\"> Strict Function Types - <code>strictFunctionTypes</code>\n</h3> <div> <div> <p>When enabled, this flag causes functions parameters to be checked more correctly.</p> <p>Here’s a basic example with <code>strictFunctionTypes</code> off:</p> <pre data-language=\"ts\">function fn(x: string) {\n  console.log(\"Hello, \" + x.toLowerCase());\n}\n \ntype StringOrNumberFunc = (ns: string | number) =&gt; void;\n \n// Unsafe assignment\nlet func: StringOrNumberFunc = fn;\n// Unsafe call - will crash\nfunc(10);</pre> <p>With <code>strictFunctionTypes</code> <em>on</em>, the error is correctly detected:</p> <pre data-language=\"ts\">function fn(x: string) {\n  console.log(\"Hello, \" + x.toLowerCase());\n}\n \ntype StringOrNumberFunc = (ns: string | number) =&gt; void;\n \n// Unsafe assignment is prevented\nlet func: StringOrNumberFunc = fn;</pre> <p>During development of this feature, we discovered a large number of inherently unsafe class hierarchies, including some in the DOM. Because of this, the setting only applies to functions written in <em>function</em> syntax, not to those in <em>method</em> syntax:</p> <pre data-language=\"ts\">type Methodish = {\n  func(x: string | number): void;\n};\n \nfunction fn(x: string) {\n  console.log(\"Hello, \" + x.toLowerCase());\n}\n \n// Ultimately an unsafe assignment, but not detected\nconst m: Methodish = {\n  func: fn,\n};\nm.func(10);</pre> </div> <ul>\n<li>\n<span>Recommended</span> </li> <li>\n<span>Default:</span><p><code>true</code> if <a href=\"#strict\"><code>strict</code></a>; <code>false</code> otherwise.</p> </li> <li>\n<span>Related:</span><ul><li>\n<p><a href=\"#strict\" aria-label=\"Jump to compiler option info for strict\"><code>strict</code></a></p> </li></ul>\n</li> <li>\n<span>Released:</span><p><a aria-label=\"Release notes for TypeScript 2.6\" href=\"https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-6.html\">2.6</a></p> </li>\n</ul> </div></section> <section> <h3 id=\"strictNullChecks-config\"> Strict Null Checks - <code>strictNullChecks</code>\n</h3> <div> <div> <p>When <code>strictNullChecks</code> is <code>false</code>, <code>null</code> and <code>undefined</code> are effectively ignored by the language. This can lead to unexpected errors at runtime.</p> <p>When <code>strictNullChecks</code> is <code>true</code>, <code>null</code> and <code>undefined</code> have their own distinct types and you’ll get a type error if you try to use them where a concrete value is expected.</p> <p>For example with this TypeScript code, <code>users.find</code> has no guarantee that it will actually find a user, but you can write code as though it will:</p> <pre data-language=\"ts\">declare const loggedInUsername: string;\n \nconst users = [\n  { name: \"Oby\", age: 12 },\n  { name: \"Heera\", age: 32 },\n];\n \nconst loggedInUser = users.find((u) =&gt; u.name === loggedInUsername);\nconsole.log(loggedInUser.age);</pre> <p>Setting <code>strictNullChecks</code> to <code>true</code> will raise an error that you have not made a guarantee that the <code>loggedInUser</code> exists before trying to use it.</p> <pre data-language=\"ts\">declare const loggedInUsername: string;\n \nconst users = [\n  { name: \"Oby\", age: 12 },\n  { name: \"Heera\", age: 32 },\n];\n \nconst loggedInUser = users.find((u) =&gt; u.name === loggedInUsername);\nconsole.log(loggedInUser.age);</pre> <p>The second example failed because the array’s <code>find</code> function looks a bit like this simplification:</p> <pre data-language=\"ts\">// When strictNullChecks: true\ntype Array = {\n  find(predicate: (value: any, index: number) =&gt; boolean): S | undefined;\n};\n\n// When strictNullChecks: false the undefined is removed from the type system,\n// allowing you to write code which assumes it always found a result\ntype Array = {\n  find(predicate: (value: any, index: number) =&gt; boolean): S;\n};</pre> </div> <ul>\n<li>\n<span>Recommended</span> </li> <li>\n<span>Default:</span><p><code>true</code> if <a href=\"#strict\"><code>strict</code></a>; <code>false</code> otherwise.</p> </li> <li>\n<span>Related:</span><ul><li>\n<p><a href=\"#strict\" aria-label=\"Jump to compiler option info for strict\"><code>strict</code></a></p> </li></ul>\n</li> <li>\n<span>Released:</span><p><a aria-label=\"Release notes for TypeScript 2.0\" href=\"https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-0.html\">2.0</a></p> </li>\n</ul> </div></section> <section> <h3 id=\"strictPropertyInitialization-config\"> Strict Property Initialization - <code>strictPropertyInitialization</code>\n</h3> <div> <div> <p>When set to true, TypeScript will raise an error when a class property was declared but not set in the constructor.</p> <pre data-language=\"ts\">class UserAccount {\n  name: string;\n  accountType = \"user\";\n \n  email: string;\n  address: string | undefined;\n \n  constructor(name: string) {\n    this.name = name;\n    // Note that this.email is not set\n  }\n}</pre> <p>In the above case:</p> <ul> <li>\n<code>this.name</code> is set specifically.</li> <li>\n<code>this.accountType</code> is set by default.</li> <li>\n<code>this.email</code> is not set and raises an error.</li> <li>\n<code>this.address</code> is declared as potentially <code>undefined</code> which means it does not have to be set.</li> </ul> </div> <ul>\n<li>\n<span>Recommended</span> </li> <li>\n<span>Default:</span><p><code>true</code> if <a href=\"#strict\"><code>strict</code></a>; <code>false</code> otherwise.</p> </li> <li>\n<span>Related:</span><ul><li>\n<p><a href=\"#strict\" aria-label=\"Jump to compiler option info for strict\"><code>strict</code></a></p> </li></ul>\n</li> <li>\n<span>Released:</span><p><a aria-label=\"Release notes for TypeScript 2.7\" href=\"https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-7.html\">2.7</a></p> </li>\n</ul> </div></section> <section> <h3 id=\"useUnknownInCatchVariables-config\"> Use Unknown In Catch Variables - <code>useUnknownInCatchVariables</code>\n</h3> <div> <div> <p>In TypeScript 4.0, support was added to allow changing the type of the variable in a catch clause from <code>any</code> to <code>unknown</code>. Allowing for code like:</p> <pre data-language=\"ts\">try {\n  // ...\n} catch (err) {\n  // We have to verify err is an\n  // error before using it as one.\n  if (err instanceof Error) {\n    console.log(err.message);\n  }\n}</pre> <p>This pattern ensures that error handling code becomes more comprehensive because you cannot guarantee that the object being thrown <em>is</em> a Error subclass ahead of time. With the flag <code>useUnknownInCatchVariables</code> enabled, then you do not need the additional syntax (<code>: unknown</code>) nor a linter rule to try enforce this behavior.</p> </div> <ul>\n<li>\n<span>Recommended</span> </li> <li>\n<span>Default:</span><p><code>true</code> if <a href=\"#strict\"><code>strict</code></a>; <code>false</code> otherwise.</p> </li> <li>\n<span>Related:</span><ul><li>\n<p><a href=\"#strict\" aria-label=\"Jump to compiler option info for strict\"><code>strict</code></a></p> </li></ul>\n</li> <li>\n<span>Released:</span><p><a aria-label=\"Release notes for TypeScript 4.4\" href=\"https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-4.html\">4.4</a></p> </li>\n</ul> </div></section> <div class=\"category\"> <h2 id=\"Modules_6244\">Modules</h2> </div> <section> <h3 id=\"allowArbitraryExtensions-config\"> Allow Arbitrary Extensions - <code>allowArbitraryExtensions</code>\n</h3> <div> <div> <p>In TypeScript 5.0, when an import path ends in an extension that isn’t a known JavaScript or TypeScript file extension, the compiler will look for a declaration file for that path in the form of <code>{file basename}.d.{extension}.ts</code>. For example, if you are using a CSS loader in a bundler project, you might want to write (or generate) declaration files for those stylesheets:</p> <pre data-language=\"css\">/* app.css */\n.cookie-banner {\n  display: none;\n}</pre> <pre data-language=\"ts\">// app.d.css.ts\ndeclare const css: {\n  cookieBanner: string;\n};\nexport default css;</pre> <pre data-language=\"ts\">// App.tsx\nimport styles from \"./app.css\";\n\nstyles.cookieBanner; // string</pre> <p>By default, this import will raise an error to let you know that TypeScript doesn’t understand this file type and your runtime might not support importing it. But if you’ve configured your runtime or bundler to handle it, you can suppress the error with the new <code>--allowArbitraryExtensions</code> compiler option.</p> <p>Note that historically, a similar effect has often been achievable by adding a declaration file named <code>app.css.d.ts</code> instead of <code>app.d.css.ts</code> - however, this just worked through Node’s <code>require</code> resolution rules for CommonJS. Strictly speaking, the former is interpreted as a declaration file for a JavaScript file named <code>app.css.js</code>. Because relative files imports need to include extensions in Node’s ESM support, TypeScript would error on our example in an ESM file under <code>--moduleResolution node16</code> or <code>nodenext</code>.</p> <p>For more information, read up <a href=\"https://github.com/microsoft/TypeScript/issues/50133\">the proposal for this feature</a> and <a href=\"https://github.com/microsoft/TypeScript/pull/51435\">its corresponding pull request</a>.</p> </div>  </div></section> <section> <h3 id=\"allowImportingTsExtensions-config\"> Allow Importing TS Extensions - <code>allowImportingTsExtensions</code>\n</h3> <div> <div> <p><code>--allowImportingTsExtensions</code> allows TypeScript files to import each other with a TypeScript-specific extension like <code>.ts</code>, <code>.mts</code>, or <code>.tsx</code>.</p> <p>This flag is only allowed when <code>--noEmit</code> or <code>--emitDeclarationOnly</code> is enabled, since these import paths would not be resolvable at runtime in JavaScript output files. The expectation here is that your resolver (e.g. your bundler, a runtime, or some other tool) is going to make these imports between <code>.ts</code> files work.</p> </div>  </div></section> <section> <h3 id=\"allowUmdGlobalAccess-config\"> Allow Umd Global Access - <code>allowUmdGlobalAccess</code>\n</h3> <div> <div> <p>When set to true, <code>allowUmdGlobalAccess</code> lets you access UMD exports as globals from inside module files. A module file is a file that has imports and/or exports. Without this flag, using an export from a UMD module requires an import declaration.</p> <p>An example use case for this flag would be a web project where you know the particular library (like jQuery or Lodash) will always be available at runtime, but you can’t access it with an import.</p> </div> <ul><li>\n<span>Released:</span><p><a aria-label=\"Release notes for TypeScript 3.5\" href=\"https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-5.html\">3.5</a></p> </li></ul> </div></section> <section> <h3 id=\"baseUrl-config\"> Base Url - <code>baseUrl</code>\n</h3> <div> <div> <p>절대 경로 참조가 아닌 모듈 이름을 해결하기 위한 기본 디렉터리를 설정할 수 있습니다.</p> <p>절대 경로로 해결하기 위한 루트 폴더를 정의할 수도 있습니다. 예를 들면,</p> <pre data-language=\"typescript\">baseUrl\n├── ex.ts\n├── hello\n│   └── world.ts\n└── tsconfig.json</pre> <p>이 프로젝트에서<code>\"baseUrl\": \"./\"</code>을 사용하면, TypeScript는<code>tsconfig.json</code>과 같은 폴더에서 시작하는 파일을 찾습니다.</p> <pre data-language=\"ts\">import { helloWorld } from \"hello/world\";\n\nconsole.log(helloWorld);</pre> <p>항상 사용하는 <code>\"../\"</code> 또는 <code>\"./\"</code>같은 import에 질렸거나, 파일을 이동해서 변경해야 할 때, 사용할 수 있는 좋은 방법입니다.</p> </div>  </div></section> <section> <h3 id=\"customConditions-config\"> Custom Conditions - <code>customConditions</code>\n</h3> <div> <div> <p><code>--customConditions</code> takes a list of additional <a href=\"https://nodejs.org/api/packages.html#nested-conditions\">conditions</a> that should succeed when TypeScript resolves from an <a href=\"https://nodejs.org/api/packages.html#exports\"><code>exports</code></a> or <a href=\"https://nodejs.org/api/packages.html#imports\"><code>imports</code></a> field of a <code>package.json</code>. These conditions are added to whatever existing conditions a resolver will use by default.</p> <p>For example, when this field is set in a <code>tsconfig.json</code> as so:</p> <pre data-language=\"jsonc\">{\n  \"compilerOptions\": {\n    \"target\": \"es2022\",\n    \"moduleResolution\": \"bundler\",\n    \"customConditions\": [\"my-condition\"]\n  }\n}</pre> <p>Any time an <code>exports</code> or <code>imports</code> field is referenced in <code>package.json</code>, TypeScript will consider conditions called <code>my-condition</code>.</p> <p>So when importing from a package with the following <code>package.json</code></p> <pre data-language=\"jsonc\">{\n  // ...\n  \"exports\": {\n    \".\": {\n      \"my-condition\": \"./foo.mjs\",\n      \"node\": \"./bar.mjs\",\n      \"import\": \"./baz.mjs\",\n      \"require\": \"./biz.mjs\"\n    }\n  }\n}</pre> <p>TypeScript will try to look for files corresponding to <code>foo.mjs</code>.</p> <p>This field is only valid under the <code>node16</code>, <code>nodenext</code>, and <code>bundler</code> options for <a href=\"#moduleResolution\"><code>--moduleResolution</code></a>.</p> </div> <ul><li>\n<span>Related:</span><ul>\n<li>\n<p><a href=\"#moduleResolution\" aria-label=\"Jump to compiler option info for moduleResolution\"><code>moduleResolution</code></a></p> </li>\n<li>\n<p><a href=\"#resolvePackageJsonExports\" aria-label=\"Jump to compiler option info for resolvePackageJsonExports\"><code>resolvePackageJsonExports</code></a></p> </li>\n<li>\n<p><a href=\"#resolvePackageJsonImports\" aria-label=\"Jump to compiler option info for resolvePackageJsonImports\"><code>resolvePackageJsonImports</code></a></p> </li>\n</ul>\n</li></ul> </div></section> <section> <h3 id=\"module-config\"> Module - <code>module</code>\n</h3> <div> <div> <p>Sets the module system for the program. See the <a href=\"https://www.typescriptlang.org/docs/handbook/modules.html\">Modules</a> reference page for more information. You very likely want <code>\"CommonJS\"</code> for node projects.</p> <p>Changing <code>module</code> affects <a href=\"#moduleResolution\"><code>moduleResolution</code></a> which <a href=\"https://www.typescriptlang.org/docs/handbook/module-resolution.html\">also has a reference page</a>.</p> <p>Here’s some example output for this file:</p> <pre data-language=\"ts\">// @filename: index.ts\nimport { valueOfPi } from \"./constants\";\n \nexport const twoPi = valueOfPi * 2;</pre> <h4 id=\"commonjs\" style=\"position:relative;\"><code>CommonJS</code></h4> <pre data-language=\"ts\">\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.twoPi = void 0;\nconst constants_1 = require(\"./constants\");\nexports.twoPi = constants_1.valueOfPi * 2;\n </pre> <h4 id=\"umd\" style=\"position:relative;\"><code>UMD</code></h4> <pre data-language=\"ts\">(function (factory) {\n    if (typeof module === \"object\" &amp;&amp; typeof module.exports === \"object\") {\n        var v = factory(require, exports);\n        if (v !== undefined) module.exports = v;\n    }\n    else if (typeof define === \"function\" &amp;&amp; define.amd) {\n        define([\"require\", \"exports\", \"./constants\"], factory);\n    }\n})(function (require, exports) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    exports.twoPi = void 0;\n    const constants_1 = require(\"./constants\");\n    exports.twoPi = constants_1.valueOfPi * 2;\n});\n </pre> <h4 id=\"amd\" style=\"position:relative;\"><code>AMD</code></h4> <pre data-language=\"ts\">define([\"require\", \"exports\", \"./constants\"], function (require, exports, constants_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    exports.twoPi = void 0;\n    exports.twoPi = constants_1.valueOfPi * 2;\n});\n </pre> <h4 id=\"system\" style=\"position:relative;\"><code>System</code></h4> <pre data-language=\"ts\">System.register([\"./constants\"], function (exports_1, context_1) {\n    \"use strict\";\n    var constants_1, twoPi;\n    var __moduleName = context_1 &amp;&amp; context_1.id;\n    return {\n        setters: [\n            function (constants_1_1) {\n                constants_1 = constants_1_1;\n            }\n        ],\n        execute: function () {\n            exports_1(\"twoPi\", twoPi = constants_1.valueOfPi * 2);\n        }\n    };\n});\n </pre> <h4 id=\"esnext\" style=\"position:relative;\"><code>ESNext</code></h4> <pre data-language=\"ts\">import { valueOfPi } from \"./constants\";\nexport const twoPi = valueOfPi * 2;\n </pre> <h4 id=\"es2015es6es2020es2022\" style=\"position:relative;\">\n<code>ES2015</code>/<code>ES6</code>/<code>ES2020</code>/<code>ES2022</code>\n</h4> <pre data-language=\"ts\">import { valueOfPi } from \"./constants\";\nexport const twoPi = valueOfPi * 2;\n </pre> <p>In addition to the base functionality of <code>ES2015</code>/<code>ES6</code>, <code>ES2020</code> adds support for <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/import\">dynamic <code>import</code>s</a>, and <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/import.meta\"><code>import.meta</code></a> while <code>ES2022</code> further adds support for <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/await#top_level_await\">top level <code>await</code></a>.</p> <h4 id=\"node16nodenext-nightly-builds\" style=\"position:relative;\">\n<code>node16</code>/<code>nodenext</code> (nightly builds)</h4> <p>Available from 4.7+, the <code>node16</code> and <code>nodenext</code> modes integrate with Node’s <a href=\"https://nodejs.org/api/esm.html\">native ECMAScript Module support</a>. The emitted JavaScript uses either <code>CommonJS</code> or <code>ES2020</code> output depending on the file extension and the value of the <code>type</code> setting in the nearest <code>package.json</code>. Module resolution also works differently. You can learn more in the <a href=\"https://www.typescriptlang.org/docs/handbook/esm-node.html\">handbook</a>.</p> <h4 id=\"none\" style=\"position:relative;\"><code>None</code></h4> <pre data-language=\"ts\">\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.twoPi = void 0;\nconst constants_1 = require(\"./constants\");\nexports.twoPi = constants_1.valueOfPi * 2;\n </pre> </div> <ul>\n<li>\n<span>Default:</span><p><code>CommonJS</code> if <a href=\"#target\"><code>target</code></a> is <code>ES3</code> or <code>ES5</code>; <code>ES6</code>/<code>ES2015</code> otherwise.</p> </li> <li>\n<span>Allowed:</span><ul>\n<li>\n<p><code>none</code></p> </li>\n<li>\n<p><code>commonjs</code></p> </li>\n<li>\n<p><code>amd</code></p> </li>\n<li>\n<p><code>umd</code></p> </li>\n<li>\n<p><code>system</code></p> </li>\n<li>\n<p><code>es6</code>/<code>es2015</code></p> </li>\n<li>\n<p><code>es2020</code></p> </li>\n<li>\n<p><code>es2022</code></p> </li>\n<li>\n<p><code>esnext</code></p> </li>\n<li>\n<p><code>node16</code></p> </li>\n<li>\n<p><code>nodenext</code></p> </li>\n</ul>\n</li> <li>\n<span>Related:</span><ul>\n<li>\n<p><a href=\"#moduleResolution\" aria-label=\"Jump to compiler option info for moduleResolution\"><code>moduleResolution</code></a></p> </li>\n<li>\n<p><a href=\"#esModuleInterop\" aria-label=\"Jump to compiler option info for esModuleInterop\"><code>esModuleInterop</code></a></p> </li>\n<li>\n<p><a href=\"#allowImportingTsExtensions\" aria-label=\"Jump to compiler option info for allowImportingTsExtensions\"><code>allowImportingTsExtensions</code></a></p> </li>\n<li>\n<p><a href=\"#allowArbitraryExtensions\" aria-label=\"Jump to compiler option info for allowArbitraryExtensions\"><code>allowArbitraryExtensions</code></a></p> </li>\n<li>\n<p><a href=\"#resolveJsonModule\" aria-label=\"Jump to compiler option info for resolveJsonModule\"><code>resolveJsonModule</code></a></p> </li>\n</ul>\n</li> <li>\n<span>Released:</span><p><a aria-label=\"Release notes for TypeScript 1.0\" href=\"https://www.typescriptlang.org/docs/handbook/release-notes/typescript-1-0.html\">1.0</a></p> </li>\n</ul> </div></section> <section> <h3 id=\"moduleResolution-config\"> Module Resolution - <code>moduleResolution</code>\n</h3> <div> <div> <p>모듈 해결 전략을 지정합니다 : <code>'node'</code> (Node.js) 또는 <code>'classic'</code> (1.6 릴리즈 이전에 TypeScript에서 사용된). 최신 코드에서는 <code>classic</code>을 사용할 필요가 없을 것입니다.</p> <p><a href=\"https://www.typescriptlang.org/docs/handbook/module-resolution.html\">Module Resolution</a>에 핸드북 참조 페이지가 있습니다.</p> </div> <ul>\n<li>\n<span>Default:</span><p><code>Classic</code> if <a href=\"#module\"><code>module</code></a> is <code>AMD</code>, <code>UMD</code>, <code>System</code>, or <code>ES6</code>/<code>ES2015</code>; Matches if <a href=\"#module\"><code>module</code></a> is <code>node16</code> or <code>nodenext</code>; <code>Node</code> otherwise.</p> </li> <li>\n<span>Allowed:</span><ul>\n<li>\n<p><code>classic</code></p> </li>\n<li>\n<p><code>node10</code>/<code>node</code></p> </li>\n<li>\n<p><code>node16</code></p> </li>\n<li>\n<p><code>nodenext</code></p> </li>\n<li>\n<p><code>bundler</code></p> </li>\n</ul>\n</li> <li>\n<span>Related:</span><ul>\n<li>\n<p><a href=\"#module\" aria-label=\"Jump to compiler option info for module\"><code>module</code></a></p> </li>\n<li>\n<p><a href=\"#paths\" aria-label=\"Jump to compiler option info for paths\"><code>paths</code></a></p> </li>\n<li>\n<p><a href=\"#baseUrl\" aria-label=\"Jump to compiler option info for baseUrl\"><code>baseUrl</code></a></p> </li>\n<li>\n<p><a href=\"#rootDirs\" aria-label=\"Jump to compiler option info for rootDirs\"><code>rootDirs</code></a></p> </li>\n<li>\n<p><a href=\"#moduleSuffixes\" aria-label=\"Jump to compiler option info for moduleSuffixes\"><code>moduleSuffixes</code></a></p> </li>\n<li>\n<p><a href=\"#customConditions\" aria-label=\"Jump to compiler option info for customConditions\"><code>customConditions</code></a></p> </li>\n<li>\n<p><a href=\"#resolvePackageJsonExports\" aria-label=\"Jump to compiler option info for resolvePackageJsonExports\"><code>resolvePackageJsonExports</code></a></p> </li>\n<li>\n<p><a href=\"#resolvePackageJsonImports\" aria-label=\"Jump to compiler option info for resolvePackageJsonImports\"><code>resolvePackageJsonImports</code></a></p> </li>\n</ul>\n</li>\n</ul> </div></section> <section> <h3 id=\"moduleSuffixes-config\"> Module Suffixes - <code>moduleSuffixes</code>\n</h3> <div> <div> <p>Provides a way to override the default list of file name suffixes to search when resolving a module.</p> <pre tsconfig=\"true\" data-language=\"typescript\">{\n  \"compilerOptions\": {\n    \"moduleSuffixes\": [\".ios\", \".native\", \"\"]\n  }\n}</pre> <p>Given the above configuration, an import like the following:</p> <pre data-language=\"ts\">import * as foo from \"./foo\";</pre> <p>TypeScript will look for the relative files <code>./foo.ios.ts</code>, <code>./foo.native.ts</code>, and finally <code>./foo.ts</code>.</p> <p>Note the empty string <code>\"\"</code> in <a href=\"#moduleSuffixes\"><code>moduleSuffixes</code></a> which is necessary for TypeScript to also look-up <code>./foo.ts</code>.</p> <p>This feature can be useful for React Native projects where each target platform can use a separate tsconfig.json with differing <code>moduleSuffixes</code>.</p> </div> <ul><li>\n<span>Released:</span><p><a aria-label=\"Release notes for TypeScript 4.7\" href=\"https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-7.html\">4.7</a></p> </li></ul> </div></section> <section> <h3 id=\"noResolve-config\"> No Resolve - <code>noResolve</code>\n</h3> <div> <div> <p>기본적으로 TypeScript는 <code>import</code> 및 <code>&lt;reference</code> 지시문에 대한 초기 파일 세트를 검사하고 이러한 확인된 파일을 프로그램에 추가합니다.</p> <p><code>noResolve</code>가 설정되어 있으면 이 프로세스가 발생하지 않습니다. 그러나, <code>import</code>문은 여전히 유효한 모듈인지 확인하기 위해 검사되므로, 다른 방법으로 이것이 충족되는지 확인해야 합니다.</p> </div>  </div></section> <section> <h3 id=\"paths-config\"> Paths - <code>paths</code>\n</h3> <div> <div> <p>가져오기를 <code>baseUrl</code> 과 관련된 조회 위치로 다시 매핑하는 일련의 항목으로, <a href=\"https://www.typescriptlang.org/docs/handbook/module-resolution.html#path-mapping\">handbook</a>에 <code>paths</code> 의 더 많은 coverage가 수록되어 있습니다.</p> <p><code>paths</code> 를 사용하면 Typescript가 <code>require</code>/<code>import</code> 에서 가져오기를 해결하는 방법을 선언 할 수 있습니다.</p> <pre tsconfig=\"true\" data-language=\"typescript\">{\n  \"compilerOptions\": {\n    \"baseUrl\": \".\", // 이 옵션은 반드시 \"paths\"가 명확할 때 지정해야 합니다.\n    \"paths\": {\n      \"jquery\": [\"node_modules/jquery/dist/jquery\"] // 이 매핑은 \"baseUrl\"에 상대적입니다.\n    }\n  }\n}</pre> <p>이렇게하면<code>import \"jquery\"</code>를 작성할 수 있고 모든 올바른 입력을 로컬에서 얻을 수 있습니다.</p> <pre tsconfig=\"true\" data-language=\"typescript\">{\n  \"compilerOptions\": {\n    \"baseUrl\": \"src\",\n    \"paths\": {\n        \"app/*\": [\"app/*\"],\n        \"config/*\": [\"app/_config/*\"],\n        \"environment/*\": [\"environments/*\"],\n        \"shared/*\": [\"app/_shared/*\"],\n        \"helpers/*\": [\"helpers/*\"],\n        \"tests/*\": [\"tests/*\"]\n    },\n}</pre> <p>이렇게 하면 TypeScript 파일 resolver가 많은 custom prefix로 코드를 찾을 수 있도록 지원할 수 있습니다. 이 패턴을 사용하면 codebase 안에서 긴 상대 경로를 피할 수 있습니다.</p> </div>  </div></section> <section> <h3 id=\"resolveJsonModule-config\"> Resolve JSON Module - <code>resolveJsonModule</code>\n</h3> <div> <div> <p>Allows importing modules with a <code>.json</code> extension, which is a common practice in node projects. This includes generating a type for the <code>import</code> based on the static JSON shape.</p> <p>TypeScript does not support resolving JSON files by default:</p> <pre data-language=\"ts\">// @filename: settings.json\n{\n    \"repo\": \"TypeScript\",\n    \"dry\": false,\n    \"debug\": false\n}\n// @filename: index.ts\nimport settings from \"./settings.json\";\n \nsettings.debug === true;\nsettings.dry === 2;</pre> <p>Enabling the option allows importing JSON, and validating the types in that JSON file.</p> <pre data-language=\"ts\">// @filename: settings.json\n{\n    \"repo\": \"TypeScript\",\n    \"dry\": false,\n    \"debug\": false\n}\n// @filename: index.ts\nimport settings from \"./settings.json\";\n \nsettings.debug === true;\nsettings.dry === 2;</pre> </div>  </div></section> <section> <h3 id=\"resolvePackageJsonExports-config\"> Resolve package.json Exports - <code>resolvePackageJsonExports</code>\n</h3> <div> <div> <p><code>--resolvePackageJsonExports</code> forces TypeScript to consult <a href=\"https://nodejs.org/api/packages.html#exports\">the <code>exports</code> field of <code>package.json</code> files</a> if it ever reads from a package in <code>node_modules</code>.</p> <p>This option defaults to <code>true</code> under the <code>node16</code>, <code>nodenext</code>, and <code>bundler</code> options for <a href=\"#moduleResolution\"><code>--moduleResolution</code></a>.</p> </div> <ul>\n<li>\n<span>Default:</span><p><code>true</code> when <a href=\"#moduleResolution\"><code>moduleResolution</code></a> is <code>node16</code>, <code>nodenext</code>, or <code>bundler</code>; otherwise <code>false</code></p> </li> <li>\n<span>Related:</span><ul>\n<li>\n<p><a href=\"#moduleResolution\" aria-label=\"Jump to compiler option info for moduleResolution\"><code>moduleResolution</code></a></p> </li>\n<li>\n<p><a href=\"#customConditions\" aria-label=\"Jump to compiler option info for customConditions\"><code>customConditions</code></a></p> </li>\n<li>\n<p><a href=\"#resolvePackageJsonImports\" aria-label=\"Jump to compiler option info for resolvePackageJsonImports\"><code>resolvePackageJsonImports</code></a></p> </li>\n</ul>\n</li>\n</ul> </div></section> <section> <h3 id=\"resolvePackageJsonImports-config\"> Resolve package.json Imports - <code>resolvePackageJsonImports</code>\n</h3> <div> <div> <p><code>--resolvePackageJsonImports</code> forces TypeScript to consult <a href=\"https://nodejs.org/api/packages.html#imports\">the <code>imports</code> field of <code>package.json</code> files</a> when performing a lookup that starts with <code>#</code> from a file whose ancestor directory contains a <code>package.json</code>.</p> <p>This option defaults to <code>true</code> under the <code>node16</code>, <code>nodenext</code>, and <code>bundler</code> options for <a href=\"#moduleResolution\"><code>--moduleResolution</code></a>.</p> </div> <ul>\n<li>\n<span>Default:</span><p><code>true</code> when <a href=\"#moduleResolution\"><code>moduleResolution</code></a> is <code>node16</code>, <code>nodenext</code>, or <code>bundler</code>; otherwise <code>false</code></p> </li> <li>\n<span>Related:</span><ul>\n<li>\n<p><a href=\"#moduleResolution\" aria-label=\"Jump to compiler option info for moduleResolution\"><code>moduleResolution</code></a></p> </li>\n<li>\n<p><a href=\"#customConditions\" aria-label=\"Jump to compiler option info for customConditions\"><code>customConditions</code></a></p> </li>\n<li>\n<p><a href=\"#resolvePackageJsonExports\" aria-label=\"Jump to compiler option info for resolvePackageJsonExports\"><code>resolvePackageJsonExports</code></a></p> </li>\n</ul>\n</li>\n</ul> </div></section> <section> <h3 id=\"rootDir-config\"> Root Dir - <code>rootDir</code>\n</h3> <div> <div> <p><strong>Default</strong>: The longest common path of all non-declaration input files. If <a href=\"#composite\"><code>composite</code></a> is set, the default is instead the directory containing the <code>tsconfig.json</code> file.</p> <p>When TypeScript compiles files, it keeps the same directory structure in the output directory as exists in the input directory.</p> <p>For example, let’s say you have some input files:</p> <pre data-language=\"typescript\">MyProj\n├── tsconfig.json\n├── core\n│   ├── a.ts\n│   ├── b.ts\n│   ├── sub\n│   │   ├── c.ts\n├── types.d.ts</pre> <p>The inferred value for <code>rootDir</code> is the longest common path of all non-declaration input files, which in this case is <code>core/</code>.</p> <p>If your <a href=\"#outDir\"><code>outDir</code></a> was <code>dist</code>, TypeScript would write this tree:</p> <pre data-language=\"typescript\">MyProj\n├── dist\n│   ├── a.js\n│   ├── b.js\n│   ├── sub\n│   │   ├── c.js</pre> <p>However, you may have intended for <code>core</code> to be part of the output directory structure. By setting <code>rootDir: \".\"</code> in <code>tsconfig.json</code>, TypeScript would write this tree:</p> <pre data-language=\"typescript\">MyProj\n├── dist\n│   ├── core\n│   │   ├── a.js\n│   │   ├── b.js\n│   │   ├── sub\n│   │   │   ├── c.js</pre> <p>Importantly, <code>rootDir</code> <strong>does not affect which files become part of the compilation</strong>. It has no interaction with the <a href=\"#include\"><code>include</code></a>, <a href=\"#exclude\"><code>exclude</code></a>, or <a href=\"#files\"><code>files</code></a> <code>tsconfig.json</code> settings.</p> <p>Note that TypeScript will never write an output file to a directory outside of <a href=\"#outDir\"><code>outDir</code></a>, and will never skip emitting a file. For this reason, <code>rootDir</code> also enforces that all files which need to be emitted are underneath the <code>rootDir</code> path.</p> <p>For example, let’s say you had this tree:</p> <pre data-language=\"typescript\">MyProj\n├── tsconfig.json\n├── core\n│   ├── a.ts\n│   ├── b.ts\n├── helpers.ts</pre> <p>It would be an error to specify <code>rootDir</code> as <code>core</code> <em>and</em> <a href=\"#include\"><code>include</code></a> as <code>*</code> because it creates a file (<code>helpers.ts</code>) that would need to be emitted <em>outside</em> the <a href=\"#outDir\"><code>outDir</code></a> (i.e. <code>../helpers.js</code>).</p> </div> <ul>\n<li>\n<span>Default:</span><p>Computed from the list of input files.</p> </li> <li>\n<span>Released:</span><p><a aria-label=\"Release notes for TypeScript 1.5\" href=\"https://www.typescriptlang.org/docs/handbook/release-notes/typescript-1-5.html\">1.5</a></p> </li>\n</ul> </div></section> <section> <h3 id=\"rootDirs-config\"> Root Dirs - <code>rootDirs</code>\n</h3> <div> <div> <p>Using <code>rootDirs</code>, you can inform the compiler that there are many “virtual” directories acting as a single root. This allows the compiler to resolve relative module imports within these “virtual” directories, as if they were merged in to one directory.</p> <p>For example:</p> <pre data-language=\"typescript\"> src\n └── views\n     └── view1.ts (can import \"./template1\", \"./view2`)\n     └── view2.ts (can import \"./template1\", \"./view1`)\n\n generated\n └── templates\n         └── views\n             └── template1.ts (can import \"./view1\", \"./view2\")</pre> <pre tsconfig=\"true\" data-language=\"typescript\">{\n  \"compilerOptions\": {\n    \"rootDirs\": [\"src/views\", \"generated/templates/views\"]\n  }\n}</pre> <p>This does not affect how TypeScript emits JavaScript, it only emulates the assumption that they will be able to work via those relative paths at runtime.</p> <p><code>rootDirs</code> can be used to provide a separate “type layer” to files that are not TypeScript or JavaScript by providing a home for generated <code>.d.ts</code> files in another folder. This technique is useful for bundled applications where you use <code>import</code> of files that aren’t necessarily code:</p> <pre data-language=\"shell\"> src\n └── index.ts\n └── css\n     └── main.css\n     └── navigation.css\n\n generated\n └── css\n     └── main.css.d.ts\n     └── navigation.css.d.ts</pre> <pre tsconfig=\"true\" data-language=\"typescript\">{\n  \"compilerOptions\": {\n    \"rootDirs\": [\"src\", \"generated\"]\n  }\n}</pre> <p>This technique lets you generate types ahead of time for the non-code source files. Imports then work naturally based off the source file’s location. For example <code>./src/index.ts</code> can import the file <code>./src/css/main.css</code> and TypeScript will be aware of the bundler’s behavior for that filetype via the corresponding generated declaration file.</p> <pre data-language=\"ts\">// @filename: index.ts\nimport { appClass } from \"./main.css\";</pre> </div> <ul>\n<li>\n<span>Default:</span><p>Computed from the list of input files.</p> </li> <li>\n<span>Released:</span><p><a aria-label=\"Release notes for TypeScript 2.0\" href=\"https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-0.html\">2.0</a></p> </li>\n</ul> </div></section> <section> <h3 id=\"typeRoots-config\"> Type Roots - <code>typeRoots</code>\n</h3> <div> <div> <p>By default all <em>visible</em> ”<code>@types</code>” packages are included in your compilation. Packages in <code>node_modules/@types</code> of any enclosing folder are considered <em>visible</em>. For example, that means packages within <code>./node_modules/@types/</code>, <code>../node_modules/@types/</code>, <code>../../node_modules/@types/</code>, and so on.</p> <p>If <code>typeRoots</code> is specified, <em>only</em> packages under <code>typeRoots</code> will be included. For example:</p> <pre tsconfig=\"true\" data-language=\"typescript\">{\n  \"compilerOptions\": {\n    \"typeRoots\": [\"./typings\", \"./vendor/types\"]\n  }\n}</pre> <p>This config file will include <em>all</em> packages under <code>./typings</code> and <code>./vendor/types</code>, and no packages from <code>./node_modules/@types</code>. All paths are relative to the <code>tsconfig.json</code>.</p> </div> <ul><li>\n<span>Related:</span><ul><li>\n<p><a href=\"#types\" aria-label=\"Jump to compiler option info for types\"><code>types</code></a></p> </li></ul>\n</li></ul> </div></section> <section> <h3 id=\"types-config\"> Types - <code>types</code>\n</h3> <div> <div> <p>By default all <em>visible</em> ”<code>@types</code>” packages are included in your compilation. Packages in <code>node_modules/@types</code> of any enclosing folder are considered <em>visible</em>. For example, that means packages within <code>./node_modules/@types/</code>, <code>../node_modules/@types/</code>, <code>../../node_modules/@types/</code>, and so on.</p> <p>If <code>types</code> is specified, only packages listed will be included in the global scope. For instance:</p> <pre tsconfig=\"true\" data-language=\"typescript\">{\n  \"compilerOptions\": {\n    \"types\": [\"node\", \"jest\", \"express\"]\n  }\n}</pre> <p>This <code>tsconfig.json</code> file will <em>only</em> include <code>./node_modules/@types/node</code>, <code>./node_modules/@types/jest</code> and <code>./node_modules/@types/express</code>. Other packages under <code>node_modules/@types/*</code> will not be included.</p> <h3 id=\"what-does-this-affect\" style=\"position:relative;\">What does this affect?</h3> <p>This option does not affect how <code>@types/*</code> are included in your application code, for example if you had the above <code>compilerOptions</code> example with code like:</p> <pre data-language=\"ts\">import * as moment from \"moment\";\n\nmoment().format(\"MMMM Do YYYY, h:mm:ss a\");</pre> <p>The <code>moment</code> import would be fully typed.</p> <p>When you have this option set, by not including a module in the <code>types</code> array it:</p> <ul> <li>Will not add globals to your project (e.g <code>process</code> in node, or <code>expect</code> in Jest)</li> <li>Will not have exports appear as auto-import recommendations</li> </ul> <p>This feature differs from <a href=\"#typeRoots\"><code>typeRoots</code></a> in that it is about specifying only the exact types you want included, whereas <a href=\"#typeRoots\"><code>typeRoots</code></a> supports saying you want particular folders.</p> </div> <ul><li>\n<span>Related:</span><ul><li>\n<p><a href=\"#typeRoots\" aria-label=\"Jump to compiler option info for typeRoots\"><code>typeRoots</code></a></p> </li></ul>\n</li></ul> </div></section> <div class=\"category\"> <h2 id=\"Emit_6246\">Emit</h2> </div> <section> <h3 id=\"declaration-config\"> Declaration - <code>declaration</code>\n</h3> <div> <div> <p>프로젝트 내의 모든 TypeScript나 JavaScript 파일에 대한 <code>.d.ts</code>파일을 생성합니다. 이러한 <code>.d.ts</code>파일은 모듈의 외부 API를 설명하는 타입 정의 파일입니다. <code>.d.ts</code> 파일 사용하면, TypeScript와 같은 도구로 intellisense와 타입이 정해지지 않은 코드의 정확한 타입을 제공할 수 있습니다.</p> <p><code>declaration</code>이 <code>true</code>로 설정되면, 아래와 같은 TypeScript 코드로 컴파일러를 실행합니다:</p> <pre data-language=\"ts\">export let helloWorld = \"hi\";</pre> <p>아래와 같은<code>index.js</code>파일이 생성될 것입니다:</p> <pre data-language=\"ts\">export let helloWorld = \"hi\";\n </pre> <p>해당 <code>helloWorld.d.ts</code>:</p> <pre data-language=\"ts\">export declare let helloWorld: string;\n </pre> <p>JavaScript 파일 용 <code>.d.ts</code>파일로 작업할 때, <a href=\"#emitDeclarationOnly\"><code>emitDeclarationOnly</code></a>를 사용하거나 <a href=\"#outDir\"><code>outDir</code></a>를 사용하여 JavaScript 파일이 덮어써지지 않도록 할 수 있습니다.</p> </div> <ul>\n<li>\n<span>Default:</span><p><code>true</code> if <a href=\"#composite\"><code>composite</code></a>; <code>false</code> otherwise.</p> </li> <li>\n<span>Related:</span><ul>\n<li>\n<p><a href=\"#declarationDir\" aria-label=\"Jump to compiler option info for declarationDir\"><code>declarationDir</code></a></p> </li>\n<li>\n<p><a href=\"#emitDeclarationOnly\" aria-label=\"Jump to compiler option info for emitDeclarationOnly\"><code>emitDeclarationOnly</code></a></p> </li>\n</ul>\n</li> <li>\n<span>Released:</span><p><a aria-label=\"Release notes for TypeScript 1.0\" href=\"https://www.typescriptlang.org/docs/handbook/release-notes/typescript-1-0.html\">1.0</a></p> </li>\n</ul> </div></section> <section> <h3 id=\"declarationDir-config\"> Declaration Dir - <code>declarationDir</code>\n</h3> <div> <div> <p>Offers a way to configure the root directory for where declaration files are emitted.</p> <pre data-language=\"typescript\">example\n├── index.ts\n├── package.json\n└── tsconfig.json</pre> <p>with this <code>tsconfig.json</code>:</p> <pre tsconfig=\"true\" data-language=\"typescript\">{\n  \"compilerOptions\": {\n    \"declaration\": true,\n    \"declarationDir\": \"./types\"\n  }\n}</pre> <p>Would place the d.ts for the <code>index.ts</code> in a <code>types</code> folder:</p> <pre data-language=\"typescript\">example\n├── index.js\n├── index.ts\n├── package.json\n├── tsconfig.json\n└── types\n    └── index.d.ts</pre> </div> <ul>\n<li>\n<span>Related:</span><ul><li>\n<p><a href=\"#declaration\" aria-label=\"Jump to compiler option info for declaration\"><code>declaration</code></a></p> </li></ul>\n</li> <li>\n<span>Released:</span><p><a aria-label=\"Release notes for TypeScript 2.0\" href=\"https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-0.html\">2.0</a></p> </li>\n</ul> </div></section> <section> <h3 id=\"declarationMap-config\"> Declaration Map - <code>declarationMap</code>\n</h3> <div> <div> <p>Generates a source map for <code>.d.ts</code> files which map back to the original <code>.ts</code> source file. This will allow editors such as VS Code to go to the original <code>.ts</code> file when using features like <em>Go to Definition</em>.</p> <p>You should strongly consider turning this on if you’re using project references.</p> </div> <ul><li>\n<span>Released:</span><p><a aria-label=\"Release notes for TypeScript 2.9\" href=\"https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-9.html\">2.9</a></p> </li></ul> </div></section> <section> <h3 id=\"downlevelIteration-config\"> Downlevel Iteration - <code>downlevelIteration</code>\n</h3> <div> <div> <p>Downleveling is TypeScript’s term for transpiling to an older version of JavaScript. This flag is to enable support for a more accurate implementation of how modern JavaScript iterates through new concepts in older JavaScript runtimes.</p> <p>ECMAScript 6 added several new iteration primitives: the <code>for / of</code> loop (<code>for (el of arr)</code>), Array spread (<code>[a, ...b]</code>), argument spread (<code>fn(...args)</code>), and <code>Symbol.iterator</code>. <code>downlevelIteration</code> allows for these iteration primitives to be used more accurately in ES5 environments if a <code>Symbol.iterator</code> implementation is present.</p> <h4 id=\"example-effects-on-for--of\" style=\"position:relative;\">Example: Effects on <code>for / of</code>\n</h4> <p>With this TypeScript code:</p> <pre data-language=\"ts\">const str = \"Hello!\";\nfor (const s of str) {\n  console.log(s);\n}</pre> <p>Without <code>downlevelIteration</code> enabled, a <code>for / of</code> loop on any object is downleveled to a traditional <code>for</code> loop:</p> <pre data-language=\"ts\">\"use strict\";\nvar str = \"Hello!\";\nfor (var _i = 0, str_1 = str; _i &lt; str_1.length; _i++) {\n    var s = str_1[_i];\n    console.log(s);\n}\n </pre> <p>This is often what people expect, but it’s not 100% compliant with ECMAScript iteration protocol. Certain strings, such as emoji (😜), have a <code>.length</code> of 2 (or even more!), but should iterate as 1 unit in a <code>for-of</code> loop. See <a href=\"https://blog.jonnew.com/posts/poo-dot-length-equals-two\">this blog post by Jonathan New</a> for a longer explanation.</p> <p>When <code>downlevelIteration</code> is enabled, TypeScript will use a helper function that checks for a <code>Symbol.iterator</code> implementation (either native or polyfill). If this implementation is missing, you’ll fall back to index-based iteration.</p> <pre data-language=\"ts\">\"use strict\";\nvar __values = (this &amp;&amp; this.__values) || function(o) {\n    var s = typeof Symbol === \"function\" &amp;&amp; Symbol.iterator, m = s &amp;&amp; o[s], i = 0;\n    if (m) return m.call(o);\n    if (o &amp;&amp; typeof o.length === \"number\") return {\n        next: function () {\n            if (o &amp;&amp; i &gt;= o.length) o = void 0;\n            return { value: o &amp;&amp; o[i++], done: !o };\n        }\n    };\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n};\nvar e_1, _a;\nvar str = \"Hello!\";\ntry {\n    for (var str_1 = __values(str), str_1_1 = str_1.next(); !str_1_1.done; str_1_1 = str_1.next()) {\n        var s = str_1_1.value;\n        console.log(s);\n    }\n}\ncatch (e_1_1) { e_1 = { error: e_1_1 }; }\nfinally {\n    try {\n        if (str_1_1 &amp;&amp; !str_1_1.done &amp;&amp; (_a = str_1.return)) _a.call(str_1);\n    }\n    finally { if (e_1) throw e_1.error; }\n}\n </pre> <p>You can use <a href=\"https://www.npmjs.com/package/tslib\">tslib</a> via <a href=\"#importHelpers\"><code>importHelpers</code></a> to reduce the amount of inline JavaScript too:</p> <pre data-language=\"ts\">\"use strict\";\nvar __values = (this &amp;&amp; this.__values) || function(o) {\n    var s = typeof Symbol === \"function\" &amp;&amp; Symbol.iterator, m = s &amp;&amp; o[s], i = 0;\n    if (m) return m.call(o);\n    if (o &amp;&amp; typeof o.length === \"number\") return {\n        next: function () {\n            if (o &amp;&amp; i &gt;= o.length) o = void 0;\n            return { value: o &amp;&amp; o[i++], done: !o };\n        }\n    };\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n};\nvar e_1, _a;\nvar str = \"Hello!\";\ntry {\n    for (var str_1 = __values(str), str_1_1 = str_1.next(); !str_1_1.done; str_1_1 = str_1.next()) {\n        var s = str_1_1.value;\n        console.log(s);\n    }\n}\ncatch (e_1_1) { e_1 = { error: e_1_1 }; }\nfinally {\n    try {\n        if (str_1_1 &amp;&amp; !str_1_1.done &amp;&amp; (_a = str_1.return)) _a.call(str_1);\n    }\n    finally { if (e_1) throw e_1.error; }\n}\n </pre> <p><strong>Note:</strong> enabling <code>downlevelIteration</code> does not improve compliance if <code>Symbol.iterator</code> is not present in the runtime.</p> <h4 id=\"example-effects-on-array-spreads\" style=\"position:relative;\">Example: Effects on Array Spreads</h4> <p>This is an array spread:</p> <pre data-language=\"js\">// Make a new array who elements are 1 followed by the elements of arr2\nconst arr = [1, ...arr2];</pre> <p>Based on the description, it sounds easy to downlevel to ES5:</p> <pre data-language=\"js\">// The same, right?\nconst arr = [1].concat(arr2);</pre> <p>However, this is observably different in certain rare cases.</p> <p>For example, if a source array is missing one or more items (contains a hole), the spread syntax will replace each empty item with <code>undefined</code>, whereas <code>.concat</code> will leave them intact.</p> <pre data-language=\"js\">// Make an array where the element at index 1 is missing\nlet arrayWithHole = [\"a\", , \"c\"];\nlet spread = [...arrayWithHole];\nlet concatenated = [].concat(arrayWithHole);\n\nconsole.log(arrayWithHole);\n// [ 'a', &lt;1 empty item&gt;, 'c' ]\nconsole.log(spread);\n// [ 'a', undefined, 'c' ]\nconsole.log(concatenated);\n// [ 'a', &lt;1 empty item&gt;, 'c' ]</pre> <p>Just as with <code>for / of</code>, <code>downlevelIteration</code> will use <code>Symbol.iterator</code> (if present) to more accurately emulate ES 6 behavior.</p> </div> <ul>\n<li>\n<span>Related:</span><ul><li>\n<p><a href=\"#importHelpers\" aria-label=\"Jump to compiler option info for importHelpers\"><code>importHelpers</code></a></p> </li></ul>\n</li> <li>\n<span>Released:</span><p><a aria-label=\"Release notes for TypeScript 2.3\" href=\"https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-3.html\">2.3</a></p> </li>\n</ul> </div></section> <section> <h3 id=\"emitBOM-config\"> Emit BOM - <code>emitBOM</code>\n</h3> <div> <div> <p>Controls whether TypeScript will emit a <a href=\"https://wikipedia.org/wiki/Byte_order_mark\">byte order mark (BOM)</a> when writing output files. Some runtime environments require a BOM to correctly interpret a JavaScript files; others require that it is not present. The default value of <code>false</code> is generally best unless you have a reason to change it.</p> </div>  </div></section> <section> <h3 id=\"emitDeclarationOnly-config\"> Emit Declaration Only - <code>emitDeclarationOnly</code>\n</h3> <div> <div> <p><em>Only</em> emit <code>.d.ts</code> files; do not emit <code>.js</code> files.</p> <p>This setting is useful in two cases:</p> <ul> <li>You are using a transpiler other than TypeScript to generate your JavaScript.</li> <li>You are using TypeScript to only generate <code>d.ts</code> files for your consumers.</li> </ul> </div> <ul>\n<li>\n<span>Related:</span><ul><li>\n<p><a href=\"#declaration\" aria-label=\"Jump to compiler option info for declaration\"><code>declaration</code></a></p> </li></ul>\n</li> <li>\n<span>Released:</span><p><a aria-label=\"Release notes for TypeScript 2.8\" href=\"https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-8.html\">2.8</a></p> </li>\n</ul> </div></section> <section> <h3 id=\"importHelpers-config\"> Import Helpers - <code>importHelpers</code>\n</h3> <div> <div> <p>For certain downleveling operations, TypeScript uses some helper code for operations like extending class, spreading arrays or objects, and async operations. By default, these helpers are inserted into files which use them. This can result in code duplication if the same helper is used in many different modules.</p> <p>If the <code>importHelpers</code> flag is on, these helper functions are instead imported from the <a href=\"https://www.npmjs.com/package/tslib\">tslib</a> module. You will need to ensure that the <code>tslib</code> module is able to be imported at runtime. This only affects modules; global script files will not attempt to import modules.</p> <p>For example, with this TypeScript:</p> <pre data-language=\"ts\">export function fn(arr: number[]) {\n  const arr2 = [1, ...arr];\n}</pre> <p>Turning on <a href=\"#downlevelIteration\"><code>downlevelIteration</code></a> and <code>importHelpers</code> is still false:</p> <pre data-language=\"ts\">var __read = (this &amp;&amp; this.__read) || function (o, n) {\n    var m = typeof Symbol === \"function\" &amp;&amp; o[Symbol.iterator];\n    if (!m) return o;\n    var i = m.call(o), r, ar = [], e;\n    try {\n        while ((n === void 0 || n-- &gt; 0) &amp;&amp; !(r = i.next()).done) ar.push(r.value);\n    }\n    catch (error) { e = { error: error }; }\n    finally {\n        try {\n            if (r &amp;&amp; !r.done &amp;&amp; (m = i[\"return\"])) m.call(i);\n        }\n        finally { if (e) throw e.error; }\n    }\n    return ar;\n};\nvar __spreadArray = (this &amp;&amp; this.__spreadArray) || function (to, from, pack) {\n    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i &lt; l; i++) {\n        if (ar || !(i in from)) {\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n            ar[i] = from[i];\n        }\n    }\n    return to.concat(ar || Array.prototype.slice.call(from));\n};\nexport function fn(arr) {\n    var arr2 = __spreadArray([1], __read(arr), false);\n}\n </pre> <p>Then turning on both <a href=\"#downlevelIteration\"><code>downlevelIteration</code></a> and <code>importHelpers</code>:</p> <pre data-language=\"ts\">import { __read, __spreadArray } from \"tslib\";\nexport function fn(arr) {\n    var arr2 = __spreadArray([1], __read(arr), false);\n}\n </pre> <p>You can use <a href=\"#noEmitHelpers\"><code>noEmitHelpers</code></a> when you provide your own implementations of these functions.</p> </div> <ul><li>\n<span>Related:</span><ul>\n<li>\n<p><a href=\"#noEmitHelpers\" aria-label=\"Jump to compiler option info for noEmitHelpers\"><code>noEmitHelpers</code></a></p> </li>\n<li>\n<p><a href=\"#downlevelIteration\" aria-label=\"Jump to compiler option info for downlevelIteration\"><code>downlevelIteration</code></a></p> </li>\n</ul>\n</li></ul> </div></section> <section> <h3 id=\"importsNotUsedAsValues-config\"> Imports Not Used As Values - <code>importsNotUsedAsValues</code>\n</h3> <div> <div> <p>Deprecated in favor of <a href=\"#verbatimModuleSyntax\"><code>verbatimModuleSyntax</code></a>.</p> <p>This flag controls how <code>import</code> works, there are 3 different options:</p> <ul> <li> <p><code>remove</code>: The default behavior of dropping <code>import</code> statements which only reference types.</p> </li> <li> <p><code>preserve</code>: Preserves all <code>import</code> statements whose values or types are never used. This can cause imports/side-effects to be preserved.</p> </li> <li> <p><code>error</code>: This preserves all imports (the same as the preserve option), but will error when a value import is only used as a type. This might be useful if you want to ensure no values are being accidentally imported, but still make side-effect imports explicit.</p> </li> </ul> <p>This flag works because you can use <code>import type</code> to explicitly create an <code>import</code> statement which should never be emitted into JavaScript.</p> </div> <ul>\n<li>\n<span>Default:</span><p><code>remove</code></p> </li> <li>\n<span>Allowed:</span><ul>\n<li>\n<p><code>remove</code></p> </li>\n<li>\n<p><code>preserve</code></p> </li>\n<li>\n<p><code>error</code></p> </li>\n</ul>\n</li> <li>\n<span>Related:</span><ul>\n<li>\n<p><a href=\"#preserveValueImports\" aria-label=\"Jump to compiler option info for preserveValueImports\"><code>preserveValueImports</code></a></p> </li>\n<li>\n<p><a href=\"#verbatimModuleSyntax\" aria-label=\"Jump to compiler option info for verbatimModuleSyntax\"><code>verbatimModuleSyntax</code></a></p> </li>\n</ul>\n</li> <li>\n<span>Released:</span><p><a aria-label=\"Release notes for TypeScript 3.8\" href=\"https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-8.html\">3.8</a></p> </li>\n</ul> </div></section> <section> <h3 id=\"inlineSourceMap-config\"> Inline Source Map - <code>inlineSourceMap</code>\n</h3> <div> <div> <p>When set, instead of writing out a <code>.js.map</code> file to provide source maps, TypeScript will embed the source map content in the <code>.js</code> files. Although this results in larger JS files, it can be convenient in some scenarios. For example, you might want to debug JS files on a webserver that doesn’t allow <code>.map</code> files to be served.</p> <p>Mutually exclusive with <a href=\"#sourceMap\"><code>sourceMap</code></a>.</p> <p>For example, with this TypeScript:</p> <pre data-language=\"ts\">const helloWorld = \"hi\";\nconsole.log(helloWorld);</pre> <p>Converts to this JavaScript:</p> <pre data-language=\"ts\">\"use strict\";\nconst helloWorld = \"hi\";\nconsole.log(helloWorld);\n </pre> <p>Then enable building it with <code>inlineSourceMap</code> enabled there is a comment at the bottom of the file which includes a source-map for the file.</p> <pre data-language=\"ts\">\"use strict\";\nconst helloWorld = \"hi\";\nconsole.log(helloWorld);\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5kZXguanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJpbmRleC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO0FBQUEsTUFBTSxVQUFVLEdBQUcsSUFBSSxDQUFDO0FBQ3hCLE9BQU8sQ0FBQyxHQUFHLENBQUMsVUFBVSxDQUFDLENBQUMifQ==</pre> </div> <ul><li>\n<span>Released:</span><p><a aria-label=\"Release notes for TypeScript 1.5\" href=\"https://www.typescriptlang.org/docs/handbook/release-notes/typescript-1-5.html\">1.5</a></p> </li></ul> </div></section> <section> <h3 id=\"inlineSources-config\"> Inline Sources - <code>inlineSources</code>\n</h3> <div> <div> <p>When set, TypeScript will include the original content of the <code>.ts</code> file as an embedded string in the source map (using the source map’s <code>sourcesContent</code> property). This is often useful in the same cases as <a href=\"#inlineSourceMap\"><code>inlineSourceMap</code></a>.</p> <p>Requires either <a href=\"#sourceMap\"><code>sourceMap</code></a> or <a href=\"#inlineSourceMap\"><code>inlineSourceMap</code></a> to be set.</p> <p>For example, with this TypeScript:</p> <pre data-language=\"ts\">const helloWorld = \"hi\";\nconsole.log(helloWorld);</pre> <p>By default converts to this JavaScript:</p> <pre data-language=\"ts\">\"use strict\";\nconst helloWorld = \"hi\";\nconsole.log(helloWorld);\n </pre> <p>Then enable building it with <code>inlineSources</code> and <a href=\"#inlineSourceMap\"><code>inlineSourceMap</code></a> enabled there is a comment at the bottom of the file which includes a source-map for the file. Note that the end is different from the example in <a href=\"#inlineSourceMap\"><code>inlineSourceMap</code></a> because the source-map now contains the original source code also.</p> <pre data-language=\"ts\">\"use strict\";\nconst helloWorld = \"hi\";\nconsole.log(helloWorld);\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5kZXguanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJpbmRleC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO0FBQUEsTUFBTSxVQUFVLEdBQUcsSUFBSSxDQUFDO0FBQ3hCLE9BQU8sQ0FBQyxHQUFHLENBQUMsVUFBVSxDQUFDLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBoZWxsb1dvcmxkID0gXCJoaVwiO1xuY29uc29sZS5sb2coaGVsbG9Xb3JsZCk7Il19</pre> </div> <ul><li>\n<span>Released:</span><p><a aria-label=\"Release notes for TypeScript 1.5\" href=\"https://www.typescriptlang.org/docs/handbook/release-notes/typescript-1-5.html\">1.5</a></p> </li></ul> </div></section> <section> <h3 id=\"mapRoot-config\"> Map Root - <code>mapRoot</code>\n</h3> <div> <div> <p>Specify the location where debugger should locate map files instead of generated locations. This string is treated verbatim inside the source-map, for example:</p> <pre tsconfig=\"true\" data-language=\"typescript\">{\n  \"compilerOptions\": {\n    \"sourceMap\": true,\n    \"mapRoot\": \"https://my-website.com/debug/sourcemaps/\"\n  }\n}</pre> <p>Would declare that <code>index.js</code> will have sourcemaps at <code>https://my-website.com/debug/sourcemaps/index.js.map</code>.</p> </div>  </div></section> <section> <h3 id=\"newLine-config\"> New Line - <code>newLine</code>\n</h3> <div> <div> <p>파일을 내보낼 때 줄바꿈의 끝을 지정합니다 : ‘CRLF’ (docs) 또는 ‘LF’ (unix).</p> </div> <ul>\n<li>\n<span>Default:</span><p>Platform specific.</p> </li> <li>\n<span>Allowed:</span><ul>\n<li>\n<p><code>crlf</code></p> </li>\n<li>\n<p><code>lf</code></p> </li>\n</ul>\n</li> <li>\n<span>Released:</span><p><a aria-label=\"Release notes for TypeScript 1.5\" href=\"https://www.typescriptlang.org/docs/handbook/release-notes/typescript-1-5.html\">1.5</a></p> </li>\n</ul> </div></section> <section> <h3 id=\"noEmit-config\"> No Emit - <code>noEmit</code>\n</h3> <div> <div> <p>Do not emit compiler output files like JavaScript source code, source-maps or declarations.</p> <p>This makes room for another tool like <a href=\"https://babeljs.io\">Babel</a>, or <a href=\"https://github.com/swc-project/swc\">swc</a> to handle converting the TypeScript file to a file which can run inside a JavaScript environment.</p> <p>You can then use TypeScript as a tool for providing editor integration, and as a source code type-checker.</p> </div>  </div></section> <section> <h3 id=\"noEmitHelpers-config\"> No Emit Helpers - <code>noEmitHelpers</code>\n</h3> <div> <div> <p>Instead of importing helpers with <a href=\"#importHelpers\"><code>importHelpers</code></a>, you can provide implementations in the global scope for the helpers you use and completely turn off emitting of helper functions.</p> <p>For example, using this <code>async</code> function in ES5 requires a <code>await</code>-like function and <code>generator</code>-like function to run:</p> <pre data-language=\"ts\">const getAPI = async (url: string) =&gt; {\n  // Get API\n  return {};\n};</pre> <p>Which creates quite a lot of JavaScript:</p> <pre data-language=\"ts\">\"use strict\";\nvar __awaiter = (this &amp;&amp; this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (this &amp;&amp; this.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] &amp; 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" &amp;&amp; (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (g &amp;&amp; (g = 0, op[0] &amp;&amp; (_ = 0)), _) try {\n            if (f = 1, y &amp;&amp; (t = op[0] &amp; 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) &amp;&amp; t.call(y), 0) : y.next) &amp;&amp; !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] &amp; 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length &gt; 0 &amp;&amp; t[t.length - 1]) &amp;&amp; (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 &amp;&amp; (!t || (op[1] &gt; t[0] &amp;&amp; op[1] &lt; t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 &amp;&amp; _.label &lt; t[1]) { _.label = t[1]; t = op; break; }\n                    if (t &amp;&amp; _.label &lt; t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] &amp; 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\nvar getAPI = function (url) { return __awaiter(void 0, void 0, void 0, function () {\n    return __generator(this, function (_a) {\n        // Get API\n        return [2 /*return*/, {}];\n    });\n}); };\n </pre> <p>Which can be switched out with your own globals via this flag:</p> <pre data-language=\"ts\">\"use strict\";\nvar getAPI = function (url) { return __awaiter(void 0, void 0, void 0, function () {\n    return __generator(this, function (_a) {\n        // Get API\n        return [2 /*return*/, {}];\n    });\n}); };\n </pre> </div> <ul>\n<li>\n<span>Related:</span><ul><li>\n<p><a href=\"#importHelpers\" aria-label=\"Jump to compiler option info for importHelpers\"><code>importHelpers</code></a></p> </li></ul>\n</li> <li>\n<span>Released:</span><p><a aria-label=\"Release notes for TypeScript 1.5\" href=\"https://www.typescriptlang.org/docs/handbook/release-notes/typescript-1-5.html\">1.5</a></p> </li>\n</ul> </div></section> <section> <h3 id=\"noEmitOnError-config\"> No Emit On Error - <code>noEmitOnError</code>\n</h3> <div> <div> <p>Do not emit compiler output files like JavaScript source code, source-maps or declarations if any errors were reported.</p> <p>This defaults to <code>false</code>, making it easier to work with TypeScript in a watch-like environment where you may want to see results of changes to your code in another environment before making sure all errors are resolved.</p> </div> <ul><li>\n<span>Released:</span><p><a aria-label=\"Release notes for TypeScript 1.4\" href=\"https://www.typescriptlang.org/docs/handbook/release-notes/typescript-1-4.html\">1.4</a></p> </li></ul> </div></section> <section> <h3 id=\"outDir-config\"> Out Dir - <code>outDir</code>\n</h3> <div> <div> <p>만일 지정하면, <code>.js</code> (이 외에도 <code>.d.ts</code>, <code>.js.map</code>, 등.) 파일이 지정한 디렉터리로 배출됩니다. 원본 파일의 디렉터리 구조는 보존됩니다; 계산된 루트가 예상과 다를 경우 <a href=\"#rootDir\">rootDir</a> 을 보세요.</p> <p>만일 지정하지 않으면, <code>.js</code> 파일은 <code>.ts</code> 파일이 생성된 곳과 동일한 디렉터리에 생성됩니다:</p> <pre data-language=\"shell\">$ tsc\n\nexample\n├── index.js\n└── index.ts</pre> <p>다음과 같이 <code>tsconfig.json</code> 을 작성할 경우:</p> <pre tsconfig=\"true\" data-language=\"typescript\">{\n  \"compilerOptions\": {\n    \"outDir\": \"dist\"\n  }\n}</pre> <p>이러한 설정으로 <code>tsc</code>를 실행하면 파일이 지정한 <code>dist</code> 폴더로 이동합니다:</p> <pre data-language=\"shell\">$ tsc\n\nexample\n├── dist\n│   └── index.js\n├── index.ts\n└── tsconfig.json</pre> </div> <ul><li>\n<span>Related:</span><ul>\n<li>\n<p><a href=\"#out\" aria-label=\"Jump to compiler option info for out\"><code>out</code></a></p> </li>\n<li>\n<p><a href=\"#outFile\" aria-label=\"Jump to compiler option info for outFile\"><code>outFile</code></a></p> </li>\n</ul>\n</li></ul> </div></section> <section> <h3 id=\"outFile-config\"> Out File - <code>outFile</code>\n</h3> <div> <div> <p>만일 지정하면, 모든 <em>전역</em> (비모듈) 파일이 지정된 단일 출력 파일에 연결됩니다.</p> <p>만일 <code>module</code> 이 <code>system</code> 또는 <code>amd</code> 일 경우, 모든 모듈 파일도 모든 전역 컨텐츠 뒤에 이 파일에 연결됩니다.</p> <p>참고: <code>outFile</code> 은 <code>module</code> 이 <code>None</code> 이거나, <code>System</code>, <code>AMD</code> 가 아니면 <em>사용할 수 없습니다</em>. 이 옵션은 bundle CommonJS 또는 ES6 모듈에 <em>사용할 수 없습니다</em>.</p> </div> <ul>\n<li>\n<span>Related:</span><ul>\n<li>\n<p><a href=\"#out\" aria-label=\"Jump to compiler option info for out\"><code>out</code></a></p> </li>\n<li>\n<p><a href=\"#outDir\" aria-label=\"Jump to compiler option info for outDir\"><code>outDir</code></a></p> </li>\n</ul>\n</li> <li>\n<span>Released:</span><p><a aria-label=\"Release notes for TypeScript 1.0\" href=\"https://www.typescriptlang.org/docs/handbook/release-notes/typescript-1-0.html\">1.0</a></p> </li>\n</ul> </div></section> <section> <h3 id=\"preserveConstEnums-config\"> Preserve Const Enums - <code>preserveConstEnums</code>\n</h3> <div> <div> <p>Do not erase <code>const enum</code> declarations in generated code. <code>const enum</code>s provide a way to reduce the overall memory footprint of your application at runtime by emitting the enum value instead of a reference.</p> <p>For example with this TypeScript:</p> <pre data-language=\"ts\">const enum Album {\n  JimmyEatWorldFutures = 1,\n  TubRingZooHypothesis = 2,\n  DogFashionDiscoAdultery = 3,\n}\n \nconst selectedAlbum = Album.JimmyEatWorldFutures;\nif (selectedAlbum === Album.JimmyEatWorldFutures) {\n  console.log(\"That is a great choice.\");\n}</pre> <p>The default <code>const enum</code> behavior is to convert any <code>Album.Something</code> to the corresponding number literal, and to remove a reference to the enum from the JavaScript completely.</p> <pre data-language=\"ts\">\"use strict\";\nconst selectedAlbum = 1 /* Album.JimmyEatWorldFutures */;\nif (selectedAlbum === 1 /* Album.JimmyEatWorldFutures */) {\n    console.log(\"That is a great choice.\");\n}\n </pre> <p>With <code>preserveConstEnums</code> set to <code>true</code>, the <code>enum</code> exists at runtime and the numbers are still emitted.</p> <pre data-language=\"ts\">\"use strict\";\nvar Album;\n(function (Album) {\n    Album[Album[\"JimmyEatWorldFutures\"] = 1] = \"JimmyEatWorldFutures\";\n    Album[Album[\"TubRingZooHypothesis\"] = 2] = \"TubRingZooHypothesis\";\n    Album[Album[\"DogFashionDiscoAdultery\"] = 3] = \"DogFashionDiscoAdultery\";\n})(Album || (Album = {}));\nconst selectedAlbum = 1 /* Album.JimmyEatWorldFutures */;\nif (selectedAlbum === 1 /* Album.JimmyEatWorldFutures */) {\n    console.log(\"That is a great choice.\");\n}\n </pre> <p>This essentially makes such <code>const enums</code> a source-code feature only, with no runtime traces.</p> </div> <ul><li>\n<span>Default:</span><p><code>true</code> if <a href=\"#isolatedModules\"><code>isolatedModules</code></a>; <code>false</code> otherwise.</p> </li></ul> </div></section> <section> <h3 id=\"preserveValueImports-config\"> Preserve Value Imports - <code>preserveValueImports</code>\n</h3> <div> <div> <p>Deprecated in favor of <a href=\"#verbatimModuleSyntax\"><code>verbatimModuleSyntax</code></a>.</p> <p>There are some cases where TypeScript can’t detect that you’re using an import. For example, take the following code:</p> <pre data-language=\"ts\">import { Animal } from \"./animal.js\";\n\neval(\"console.log(new Animal().isDangerous())\");</pre> <p>or code using ‘Compiles to HTML’ languages like Svelte or Vue. <code>preserveValueImports</code> will prevent TypeScript from removing the import, even if it appears unused.</p> <p>When combined with <a href=\"#isolatedModules\"><code>isolatedModules</code></a>: imported types <em>must</em> be marked as type-only because compilers that process single files at a time have no way of knowing whether imports are values that appear unused, or a type that must be removed in order to avoid a runtime crash.</p> </div> <ul>\n<li>\n<span>Related:</span><ul>\n<li>\n<p><a href=\"#isolatedModules\" aria-label=\"Jump to compiler option info for isolatedModules\"><code>isolatedModules</code></a></p> </li>\n<li>\n<p><a href=\"#importsNotUsedAsValues\" aria-label=\"Jump to compiler option info for importsNotUsedAsValues\"><code>importsNotUsedAsValues</code></a></p> </li>\n<li>\n<p><a href=\"#verbatimModuleSyntax\" aria-label=\"Jump to compiler option info for verbatimModuleSyntax\"><code>verbatimModuleSyntax</code></a></p> </li>\n</ul>\n</li> <li>\n<span>Released:</span><p><a aria-label=\"Release notes for TypeScript 4.5\" href=\"https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-5.html\">4.5</a></p> </li>\n</ul> </div></section> <section> <h3 id=\"removeComments-config\"> Remove Comments - <code>removeComments</code>\n</h3> <div> <div> <p>Strips all comments from TypeScript files when converting into JavaScript. Defaults to <code>false</code>.</p> <p>For example, this is a TypeScript file which has a JSDoc comment:</p> <pre data-language=\"ts\">/** The translation of 'Hello world' into Portuguese */\nexport const helloWorldPTBR = \"Olá Mundo\";</pre> <p>When <code>removeComments</code> is set to <code>true</code>:</p> <pre data-language=\"ts\">export const helloWorldPTBR = \"Olá Mundo\";\n </pre> <p>Without setting <code>removeComments</code> or having it as <code>false</code>:</p> <pre data-language=\"ts\">/** The translation of 'Hello world' into Portuguese */\nexport const helloWorldPTBR = \"Olá Mundo\";\n </pre> <p>This means that your comments will show up in the JavaScript code.</p> </div>  </div></section> <section> <h3 id=\"sourceMap-config\"> Source Map - <code>sourceMap</code>\n</h3> <div> <div> <p>Enables the generation of <a href=\"https://developer.mozilla.org/docs/Tools/Debugger/How_to/Use_a_source_map\">sourcemap files</a>. These files allow debuggers and other tools to display the original TypeScript source code when actually working with the emitted JavaScript files. Source map files are emitted as <code>.js.map</code> (or <code>.jsx.map</code>) files next to the corresponding <code>.js</code> output file.</p> <p>The <code>.js</code> files will in turn contain a sourcemap comment to indicate where the files are to external tools, for example:</p> <pre data-language=\"ts\">// helloWorld.ts\nexport declare const helloWorld = \"hi\";</pre> <p>Compiling with <code>sourceMap</code> set to <code>true</code> creates the following JavaScript file:</p> <pre data-language=\"js\">// helloWorld.js\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.helloWorld = \"hi\";\n//# sourceMappingURL=// helloWorld.js.map</pre> <p>And this also generates this json map:</p> <pre data-language=\"json\">// helloWorld.js.map\n{\n  \"version\": 3,\n  \"file\": \"ex.js\",\n  \"sourceRoot\": \"\",\n  \"sources\": [\"../ex.ts\"],\n  \"names\": [],\n  \"mappings\": \";;AAAa,QAAA,UAAU,GAAG,IAAI,CAAA\"\n}</pre> </div>  </div></section> <section> <h3 id=\"sourceRoot-config\"> Source Root - <code>sourceRoot</code>\n</h3> <div> <div> <p>소스의 상대 위치 대신 디버거가 TypeScript 파일을 찾을 위치를 지정합니다. 이 문자열은 경로 또는 URL을 사용할 수 있는 소스-맵 내에서 그대로 처리됩니다:</p> <pre tsconfig=\"true\" data-language=\"typescript\">{\n  \"compilerOptions\": {\n    \"sourceMap\": true,\n    \"sourceRoot\": \"https://my-website.com/debug/source/\"\n  }\n}</pre> <p><code>index.js</code> 에 <code>https://my-website.com/debug/source/index.ts</code> 위치에 소스 파일이 있다고 명시해야 합니다.</p> </div>  </div></section> <section> <h3 id=\"stripInternal-config\"> Strip Internal - <code>stripInternal</code>\n</h3> <div> <div> <p>Do not emit declarations for code that has an <code>@internal</code> annotation in its JSDoc comment. This is an internal compiler option; use at your own risk, because the compiler does not check that the result is valid. If you are searching for a tool to handle additional levels of visibility within your <code>d.ts</code> files, look at <a href=\"https://api-extractor.com\">api-extractor</a>.</p> <pre data-language=\"ts\">/**\n * Days available in a week\n * @internal\n */\nexport const daysInAWeek = 7;\n \n/** Calculate how much someone earns in a week */\nexport function weeklySalary(dayRate: number) {\n  return daysInAWeek * dayRate;\n}</pre> <p>With the flag set to <code>false</code> (default):</p> <pre data-language=\"ts\">/**\n * Days available in a week\n * @internal\n */\nexport declare const daysInAWeek = 7;\n/** Calculate how much someone earns in a week */\nexport declare function weeklySalary(dayRate: number): number;\n </pre> <p>With <code>stripInternal</code> set to <code>true</code> the <code>d.ts</code> emitted will be redacted.</p> <pre data-language=\"ts\">/** Calculate how much someone earns in a week */\nexport declare function weeklySalary(dayRate: number): number;\n </pre> <p>The JavaScript output is still the same.</p> </div> <ul><li>\n<span>Internal</span> </li></ul> </div></section> <div class=\"category\"> <h2 id=\"JavaScript_Support_6247\">JavaScript Support</h2> </div> <section> <h3 id=\"allowJs-config\"> Allow JS - <code>allowJs</code>\n</h3> <div> <div> <p>Allow JavaScript files to be imported inside your project, instead of just <code>.ts</code> and <code>.tsx</code> files. For example, this JS file:</p> <pre data-language=\"js\">// @filename: card.js\nexport const defaultCardDeck = \"Heart\";</pre> <p>When imported into a TypeScript file will raise an error:</p> <pre data-language=\"ts\">// @filename: index.ts\nimport { defaultCardDeck } from \"./card\";\n \nconsole.log(defaultCardDeck);</pre> <p>Imports fine with <code>allowJs</code> enabled:</p> <pre data-language=\"ts\">// @filename: index.ts\nimport { defaultCardDeck } from \"./card\";\n \nconsole.log(defaultCardDeck);</pre> <p>This flag can be used as a way to incrementally add TypeScript files into JS projects by allowing the <code>.ts</code> and <code>.tsx</code> files to live along-side existing JavaScript files.</p> <p>It can also be used along-side <a href=\"#declaration\"><code>declaration</code></a> and <a href=\"#emitDeclarationOnly\"><code>emitDeclarationOnly</code></a> to <a href=\"https://www.typescriptlang.org/docs/handbook/declaration-files/dts-from-js.html\">create declarations for JS files</a>.</p> </div> <ul>\n<li>\n<span>Related:</span><ul>\n<li>\n<p><a href=\"#checkJs\" aria-label=\"Jump to compiler option info for checkJs\"><code>checkJs</code></a></p> </li>\n<li>\n<p><a href=\"#emitDeclarationOnly\" aria-label=\"Jump to compiler option info for emitDeclarationOnly\"><code>emitDeclarationOnly</code></a></p> </li>\n</ul>\n</li> <li>\n<span>Released:</span><p><a aria-label=\"Release notes for TypeScript 1.8\" href=\"https://www.typescriptlang.org/docs/handbook/release-notes/typescript-1-8.html\">1.8</a></p> </li>\n</ul> </div></section> <section> <h3 id=\"checkJs-config\"> Check JS - <code>checkJs</code>\n</h3> <div> <div> <p>Works in tandem with <a href=\"#allowJs\"><code>allowJs</code></a>. When <code>checkJs</code> is enabled then errors are reported in JavaScript files. This is the equivalent of including <code>// @ts-check</code> at the top of all JavaScript files which are included in your project.</p> <p>For example, this is incorrect JavaScript according to the <code>parseFloat</code> type definition which comes with TypeScript:</p> <pre data-language=\"js\">// parseFloat only takes a string\nmodule.exports.pi = parseFloat(3.142);</pre> <p>When imported into a TypeScript module:</p> <pre data-language=\"ts\">// @filename: constants.js\nmodule.exports.pi = parseFloat(3.142);\n \n// @filename: index.ts\nimport { pi } from \"./constants\";\nconsole.log(pi);</pre> <p>You will not get any errors. However, if you turn on <code>checkJs</code> then you will get error messages from the JavaScript file.</p> <pre data-language=\"ts\">// @filename: constants.js\nmodule.exports.pi = parseFloat(3.142);\n \n// @filename: index.ts\nimport { pi } from \"./constants\";\nconsole.log(pi);</pre> </div> <ul>\n<li>\n<span>Related:</span><ul>\n<li>\n<p><a href=\"#allowJs\" aria-label=\"Jump to compiler option info for allowJs\"><code>allowJs</code></a></p> </li>\n<li>\n<p><a href=\"#emitDeclarationOnly\" aria-label=\"Jump to compiler option info for emitDeclarationOnly\"><code>emitDeclarationOnly</code></a></p> </li>\n</ul>\n</li> <li>\n<span>Released:</span><p><a aria-label=\"Release notes for TypeScript 2.3\" href=\"https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-3.html\">2.3</a></p> </li>\n</ul> </div></section> <section> <h3 id=\"maxNodeModuleJsDepth-config\"> Max Node Module JS Depth - <code>maxNodeModuleJsDepth</code>\n</h3> <div> <div> <p>The maximum dependency depth to search under <code>node_modules</code> and load JavaScript files.</p> <p>This flag can only be used when <a href=\"#allowJs\"><code>allowJs</code></a> is enabled, and is used if you want to have TypeScript infer types for all of the JavaScript inside your <code>node_modules</code>.</p> <p>Ideally this should stay at 0 (the default), and <code>d.ts</code> files should be used to explicitly define the shape of modules. However, there are cases where you may want to turn this on at the expense of speed and potential accuracy.</p> </div>  </div></section> <div class=\"category\"> <h2 id=\"Editor_Support_6249\">Editor Support</h2> </div> <section> <h3 id=\"disableSizeLimit-config\"> Disable Size Limit - <code>disableSizeLimit</code>\n</h3> <div> <div> <p>To avoid a possible memory bloat issues when working with very large JavaScript projects, there is an upper limit to the amount of memory TypeScript will allocate. Turning this flag on will remove the limit.</p> </div>  </div></section> <section> <h3 id=\"plugins-config\"> Plugins - <code>plugins</code>\n</h3> <div> <div> <p>에디터 내에서 실행할 언어 서비스 플러그인 목록.</p> <p>언어 서비스 플러그인은 기존 TypeScript 파일을 기반으로 사용자에게 추가 정보를 제공하는 방법입니다. TypeScript와 편집자 간의 기존 메시지를 개선하거나 자체 오류 메시지를 제공할 수 있습니다.</p> <p>예를 들면:</p> <ul> <li>\n<a href=\"https://github.com/xialvjun/ts-sql-plugin#readme\">ts-sql-plugin</a> — 템플릿 문자열 SQL 생성기로 SQL 린팅(linting)을 추가합니다.</li> <li>\n<a href=\"https://github.com/Microsoft/typescript-styled-plugin\">typescript-styled-plugin</a> — 템플릿 문자열 내부에 CSS 린팅(linting)을 제공합니다.</li> <li>\n<a href=\"https://github.com/Quramy/typescript-eslint-language-service\">typescript-eslint-language-service</a> — 컴파일러 출력 내부에 eslint 오류 메시징 및 수정 기능을 제공합니다.</li> <li>\n<a href=\"https://github.com/Quramy/ts-graphql-plugin\">ts-graphql-plugin</a> — GraphQL 쿼리 템플릿 문자열 내에서 검증 및 자동 완성을 제공합니다.</li> </ul> <p>VS Code는 <a href=\"https://code.visualstudio.com/api/references/contribution-points#contributes.typescriptServerPlugins\">automatically include language service plugins</a>에 대한 확장 기능이 있어서, <code>tsconfig.json</code>에서 정의 할 필요 없이 에디터에서 일부를 실행할 수 있습니다.</p> </div>  </div></section> <div class=\"category\"> <h2 id=\"Interop_Constraints_6252\">Interop Constraints</h2> </div> <section> <h3 id=\"allowSyntheticDefaultImports-config\"> Allow Synthetic Default Imports - <code>allowSyntheticDefaultImports</code>\n</h3> <div> <div> <p>When set to true, <code>allowSyntheticDefaultImports</code> allows you to write an import like:</p> <pre data-language=\"ts\">import React from \"react\";</pre> <p>instead of:</p> <pre data-language=\"ts\">import * as React from \"react\";</pre> <p>When the module <strong>does not</strong> explicitly specify a default export.</p> <p>For example, without <code>allowSyntheticDefaultImports</code> as true:</p> <pre data-language=\"ts\">// @filename: utilFunctions.js\nconst getStringLength = (str) =&gt; str.length;\n \nmodule.exports = {\n  getStringLength,\n};\n \n// @filename: index.ts\nimport utils from \"./utilFunctions\";\n \nconst count = utils.getStringLength(\"Check JS\");</pre> <p>This code raises an error because there isn’t a <code>default</code> object which you can import. Even though it feels like it should. For convenience, transpilers like Babel will automatically create a default if one isn’t created. Making the module look a bit more like:</p> <pre data-language=\"js\">// @filename: utilFunctions.js\nconst getStringLength = (str) =&gt; str.length;\nconst allFunctions = {\n  getStringLength,\n};\n\nmodule.exports = allFunctions;\nmodule.exports.default = allFunctions;</pre> <p>This flag does not affect the JavaScript emitted by TypeScript, it’s only for the type checking. This option brings the behavior of TypeScript in-line with Babel, where extra code is emitted to make using a default export of a module more ergonomic.</p> </div> <ul>\n<li>\n<span>Default:</span><p><code>true</code> if <a href=\"#esModuleInterop\"><code>esModuleInterop</code></a> is enabled, <a href=\"#module\"><code>module</code></a> is <code>system</code>, or <a href=\"#module-resolution\"><code>moduleResolution</code></a> is <code>bundler</code>; <code>false</code> otherwise.</p> </li> <li>\n<span>Related:</span><ul><li>\n<p><a href=\"#esModuleInterop\" aria-label=\"Jump to compiler option info for esModuleInterop\"><code>esModuleInterop</code></a></p> </li></ul>\n</li> <li>\n<span>Released:</span><p><a aria-label=\"Release notes for TypeScript 1.8\" href=\"https://www.typescriptlang.org/docs/handbook/release-notes/typescript-1-8.html\">1.8</a></p> </li>\n</ul> </div></section> <section> <h3 id=\"esModuleInterop-config\"> ES Module Interop - <code>esModuleInterop</code>\n</h3> <div> <div> <p>By default (with <code>esModuleInterop</code> false or not set) TypeScript treats CommonJS/AMD/UMD modules similar to ES6 modules. In doing this, there are two parts in particular which turned out to be flawed assumptions:</p> <ul> <li> <p>a namespace import like <code>import * as moment from \"moment\"</code> acts the same as <code>const moment = require(\"moment\")</code></p> </li> <li> <p>a default import like <code>import moment from \"moment\"</code> acts the same as <code>const moment = require(\"moment\").default</code></p> </li> </ul> <p>This mis-match causes these two issues:</p> <ul> <li> <p>the ES6 modules spec states that a namespace import (<code>import * as x</code>) can only be an object, by having TypeScript treating it the same as <code>= require(\"x\")</code> then TypeScript allowed for the import to be treated as a function and be callable. That’s not valid according to the spec.</p> </li> <li> <p>while accurate to the ES6 modules spec, most libraries with CommonJS/AMD/UMD modules didn’t conform as strictly as TypeScript’s implementation.</p> </li> </ul> <p>Turning on <code>esModuleInterop</code> will fix both of these problems in the code transpiled by TypeScript. The first changes the behavior in the compiler, the second is fixed by two new helper functions which provide a shim to ensure compatibility in the emitted JavaScript:</p> <pre data-language=\"ts\">import * as fs from \"fs\";\nimport _ from \"lodash\";\n\nfs.readFileSync(\"file.txt\", \"utf8\");\n_.chunk([\"a\", \"b\", \"c\", \"d\"], 2);</pre> <p>With <code>esModuleInterop</code> disabled:</p> <pre data-language=\"ts\">\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst fs = require(\"fs\");\nconst lodash_1 = require(\"lodash\");\nfs.readFileSync(\"file.txt\", \"utf8\");\nlodash_1.default.chunk([\"a\", \"b\", \"c\", \"d\"], 2);\n </pre> <p>With <code>esModuleInterop</code> set to <code>true</code>:</p> <pre data-language=\"ts\">\"use strict\";\nvar __createBinding = (this &amp;&amp; this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this &amp;&amp; this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this &amp;&amp; this.__importStar) || function (mod) {\n    if (mod &amp;&amp; mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" &amp;&amp; Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __importDefault = (this &amp;&amp; this.__importDefault) || function (mod) {\n    return (mod &amp;&amp; mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst fs = __importStar(require(\"fs\"));\nconst lodash_1 = __importDefault(require(\"lodash\"));\nfs.readFileSync(\"file.txt\", \"utf8\");\nlodash_1.default.chunk([\"a\", \"b\", \"c\", \"d\"], 2);\n </pre> <p><em>Note</em>: The namespace import <code>import * as fs from \"fs\"</code> only accounts for properties which <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/hasOwnProperty\">are owned</a> (basically properties set on the object and not via the prototype chain) on the imported object. If the module you’re importing defines its API using inherited properties, you need to use the default import form (<code>import fs from \"fs\"</code>), or disable <code>esModuleInterop</code>.</p> <p><em>Note</em>: You can make JS emit terser by enabling <a href=\"#importHelpers\"><code>importHelpers</code></a>:</p> <pre data-language=\"ts\">\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst tslib_1 = require(\"tslib\");\nconst fs = tslib_1.__importStar(require(\"fs\"));\nconst lodash_1 = tslib_1.__importDefault(require(\"lodash\"));\nfs.readFileSync(\"file.txt\", \"utf8\");\nlodash_1.default.chunk([\"a\", \"b\", \"c\", \"d\"], 2);\n </pre> <p>Enabling <code>esModuleInterop</code> will also enable <a href=\"#allowSyntheticDefaultImports\"><code>allowSyntheticDefaultImports</code></a>.</p> </div> <ul>\n<li>\n<span>Recommended</span> </li> <li>\n<span>Default:</span><p><code>true</code> if <a href=\"#module\"><code>module</code></a> is <code>node16</code> or <code>nodenext</code>; <code>false</code> otherwise.</p> </li> <li>\n<span>Related:</span><ul><li>\n<p><a href=\"#allowSyntheticDefaultImports\" aria-label=\"Jump to compiler option info for allowSyntheticDefaultImports\"><code>allowSyntheticDefaultImports</code></a></p> </li></ul>\n</li> <li>\n<span>Released:</span><p><a aria-label=\"Release notes for TypeScript 2.7\" href=\"https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-7.html\">2.7</a></p> </li>\n</ul> </div></section> <section> <h3 id=\"forceConsistentCasingInFileNames-config\"> Force Consistent Casing In File Names - <code>forceConsistentCasingInFileNames</code>\n</h3> <div> <div> <p>TypeScript follows the case sensitivity rules of the file system it’s running on. This can be problematic if some developers are working in a case-sensitive file system and others aren’t. If a file attempts to import <code>fileManager.ts</code> by specifying <code>./FileManager.ts</code> the file will be found in a case-insensitive file system, but not on a case-sensitive file system.</p> <p>When this option is set, TypeScript will issue an error if a program tries to include a file by a casing different from the casing on disk.</p> </div> <ul>\n<li>\n<span>Recommended</span> </li> <li>\n<span>Default:</span><p><code>true</code></p> </li>\n</ul> </div></section> <section> <h3 id=\"isolatedModules-config\"> Isolated Modules - <code>isolatedModules</code>\n</h3> <div> <div> <p>While you can use TypeScript to produce JavaScript code from TypeScript code, it’s also common to use other transpilers such as <a href=\"https://babeljs.io\">Babel</a> to do this. However, other transpilers only operate on a single file at a time, which means they can’t apply code transforms that depend on understanding the full type system. This restriction also applies to TypeScript’s <code>ts.transpileModule</code> API which is used by some build tools.</p> <p>These limitations can cause runtime problems with some TypeScript features like <code>const enum</code>s and <code>namespace</code>s. Setting the <code>isolatedModules</code> flag tells TypeScript to warn you if you write certain code that can’t be correctly interpreted by a single-file transpilation process.</p> <p>It does not change the behavior of your code, or otherwise change the behavior of TypeScript’s checking and emitting process.</p> <p>Some examples of code which does not work when <code>isolatedModules</code> is enabled.</p> <h4 id=\"exports-of-non-value-identifiers\" style=\"position:relative;\">Exports of Non-Value Identifiers</h4> <p>In TypeScript, you can import a <em>type</em> and then subsequently export it:</p> <pre data-language=\"ts\">import { someType, someFunction } from \"someModule\";\n \nsomeFunction();\n \nexport { someType, someFunction };</pre> <p>Because there’s no value for <code>someType</code>, the emitted <code>export</code> will not try to export it (this would be a runtime error in JavaScript):</p> <pre data-language=\"js\">export { someFunction };</pre> <p>Single-file transpilers don’t know whether <code>someType</code> produces a value or not, so it’s an error to export a name that only refers to a type.</p> <h4 id=\"non-module-files\" style=\"position:relative;\">Non-Module Files</h4> <p>If <code>isolatedModules</code> is set, all implementation files must be <em>modules</em> (which means it has some form of <code>import</code>/<code>export</code>). An error occurs if any file isn’t a module:</p> <pre data-language=\"ts\">function fn() {}</pre> <p>This restriction doesn’t apply to <code>.d.ts</code> files.</p> <h4 id=\"references-to-const-enum-members\" style=\"position:relative;\">References to <code>const enum</code> members</h4> <p>In TypeScript, when you reference a <code>const enum</code> member, the reference is replaced by its actual value in the emitted JavaScript. Changing this TypeScript:</p> <pre data-language=\"ts\">declare const enum Numbers {\n  Zero = 0,\n  One = 1,\n}\nconsole.log(Numbers.Zero + Numbers.One);</pre> <p>To this JavaScript:</p> <pre data-language=\"ts\">\"use strict\";\nconsole.log(0 + 1);\n </pre> <p>Without knowledge of the values of these members, other transpilers can’t replace the references to <code>Numbers</code>, which would be a runtime error if left alone (since there are no <code>Numbers</code> object at runtime). Because of this, when <code>isolatedModules</code> is set, it is an error to reference an ambient <code>const enum</code> member.</p> </div>  </div></section> <section> <h3 id=\"preserveSymlinks-config\"> Preserve Symlinks - <code>preserveSymlinks</code>\n</h3> <div> <div> <p>This is to reflect the same flag in Node.js; which does not resolve the real path of symlinks.</p> <p>This flag also exhibits the opposite behavior to Webpack’s <code>resolve.symlinks</code> option (i.e. setting TypeScript’s <code>preserveSymlinks</code> to true parallels setting Webpack’s <code>resolve.symlinks</code> to false, and vice-versa).</p> <p>With this enabled, references to modules and packages (e.g. <code>import</code>s and <code>/// &lt;reference type=\"...\" /&gt;</code> directives) are all resolved relative to the location of the symbolic link file, rather than relative to the path that the symbolic link resolves to.</p> </div>  </div></section> <section> <h3 id=\"verbatimModuleSyntax-config\"> Verbatim Module Syntax - <code>verbatimModuleSyntax</code>\n</h3> <div> <div> <p>By default, TypeScript does something called <em>import elision</em>. Basically, if you write something like</p> <pre data-language=\"ts\">import { Car } from \"./car\";\n\nexport function drive(car: Car) {\n  // ...\n}</pre> <p>TypeScript detects that you’re only using an import for types and drops the import entirely. Your output JavaScript might look something like this:</p> <pre data-language=\"js\">export function drive(car) {\n  // ...\n}</pre> <p>Most of the time this is good, because if <code>Car</code> isn’t a value that’s exported from <code>./car</code>, we’ll get a runtime error.</p> <p>But it does add a layer of complexity for certain edge cases. For example, notice there’s no statement like <code>import \"./car\";</code> - the import was dropped entirely. That actually makes a difference for modules that have side-effects or not.</p> <p>TypeScript’s emit strategy for JavaScript also has another few layers of complexity - import elision isn’t always just driven by how an import is used - it often consults how a value is declared as well. So it’s not always clear whether code like the following</p> <pre data-language=\"ts\">export { Car } from \"./car\";</pre> <p>should be preserved or dropped. If <code>Car</code> is declared with something like a <code>class</code>, then it can be preserved in the resulting JavaScript file. But if <code>Car</code> is only declared as a <code>type</code> alias or <code>interface</code>, then the JavaScript file shouldn’t export <code>Car</code> at all.</p> <p>While TypeScript might be able to make these emit decisions based on information from across files, not every compiler can.</p> <p>The <code>type</code> modifier on imports and exports helps with these situations a bit. We can make it explicit whether an import or export is only being used for type analysis, and can be dropped entirely in JavaScript files by using the <code>type</code> modifier.</p> <pre data-language=\"ts\">// This statement can be dropped entirely in JS output\nimport type * as car from \"./car\";\n\n// The named import/export 'Car' can be dropped in JS output\nimport { type Car } from \"./car\";\nexport { type Car } from \"./car\";</pre> <p><code>type</code> modifiers are not quite useful on their own - by default, module elision will still drop imports, and nothing forces you to make the distinction between <code>type</code> and plain imports and exports. So TypeScript has the flag <code>--importsNotUsedAsValues</code> to make sure you use the <code>type</code> modifier, <code>--preserveValueImports</code> to prevent <em>some</em> module elision behavior, and <code>--isolatedModules</code> to make sure that your TypeScript code works across different compilers. Unfortunately, understanding the fine details of those 3 flags is hard, and there are still some edge cases with unexpected behavior.</p> <p>TypeScript 5.0 introduces a new option called <code>--verbatimModuleSyntax</code> to simplify the situation. The rules are much simpler - any imports or exports without a <code>type</code> modifier are left around. Anything that uses the <code>type</code> modifier is dropped entirely.</p> <pre data-language=\"ts\">// Erased away entirely.\nimport type { A } from \"a\";\n\n// Rewritten to 'import { b } from \"bcd\";'\nimport { b, type c, type d } from \"bcd\";\n\n// Rewritten to 'import {} from \"xyz\";'\nimport { type xyz } from \"xyz\";</pre> <p>With this new option, what you see is what you get.</p> <p>That does have some implications when it comes to module interop though. Under this flag, ECMAScript <code>import</code>s and <code>export</code>s won’t be rewritten to <code>require</code> calls when your settings or file extension implied a different module system. Instead, you’ll get an error. If you need to emit code that uses <code>require</code> and <code>module.exports</code>, you’ll have to use TypeScript’s module syntax that predates ES2015:</p> <table> <thead> <tr> <th>Input TypeScript</th> <th>Output JavaScript</th> </tr> </thead> <tr> <td> <pre data-language=\"ts\">import foo = require(\"foo\");</pre> </td> <td> <pre data-language=\"js\">const foo = require(\"foo\");</pre> </td> </tr> <tr> <td> <pre data-language=\"ts\">function foo() {}\nfunction bar() {}\nfunction baz() {}\n\nexport = {\n  foo,\n  bar,\n  baz,\n};</pre> </td> <td> <pre data-language=\"js\">function foo() {}\nfunction bar() {}\nfunction baz() {}\n\nmodule.exports = {\n  foo,\n  bar,\n  baz,\n};</pre> </td> </tr> </table> <p>While this is a limitation, it does help make some issues more obvious. For example, it’s very common to forget to set the <a href=\"https://nodejs.org/api/packages.html#type\"><code>type</code> field in <code>package.json</code></a> under <code>--module node16</code>. As a result, developers would start writing CommonJS modules instead of an ES modules without realizing it, giving surprising lookup rules and JavaScript output. This new flag ensures that you’re intentional about the file type you’re using because the syntax is intentionally different.</p> <p>Because <code>--verbatimModuleSyntax</code> provides a more consistent story than <code>--importsNotUsedAsValues</code> and <code>--preserveValueImports</code>, those two existing flags are being deprecated in its favor.</p> <p>For more details, read up on <a href=\"https://github.com/microsoft/TypeScript/pull/52203\">the original pull request</a> and <a href=\"https://github.com/microsoft/TypeScript/issues/51479\">its proposal issue</a>.</p> </div>  </div></section> <div class=\"category\"> <h2 id=\"Backwards_Compatibility_6253\">Backwards Compatibility</h2> </div> <section> <h3 id=\"charset-config\"> Charset - <code>charset</code>\n</h3> <div> <div> <p>이전 버전의 TypeScript에서는, 디스크에서 텍스트 파일을 읽을 때 인코딩 방식을 제어했습니다. 현재 TypeScript는 UTF-8 인코딩을 전제로 합니다. 하지만 UTF-16 (BE 와 LE) 또는 UTF-8 BOMs도 정확하게 감지합니다.</p> </div> <ul>\n<li>\n<span>Deprecated</span> </li> <li>\n<span>Default:</span><p><code>utf8</code></p> </li>\n</ul> </div></section> <section> <h3 id=\"keyofStringsOnly-config\"> Keyof Strings Only - <code>keyofStringsOnly</code>\n</h3> <div> <div> <p>This flag changes the <code>keyof</code> type operator to return <code>string</code> instead of <code>string | number</code> when applied to a type with a string index signature.</p> <p>This flag is used to help people keep this behavior from <a href=\"https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-9.html#support-number-and-symbol-named-properties-with-keyof-and-mapped-types\">before TypeScript 2.9’s release</a>.</p> </div> <ul>\n<li>\n<span>Deprecated</span> </li> <li>\n<span>Released:</span><p><a aria-label=\"Release notes for TypeScript 2.9\" href=\"https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-9.html\">2.9</a></p> </li>\n</ul> </div></section> <section> <h3 id=\"noImplicitUseStrict-config\"> No Implicit Use Strict - <code>noImplicitUseStrict</code>\n</h3> <div> <div> <p>You shouldn’t need this. By default, when emitting a module file to a non-ES6 target, TypeScript emits a <code>\"use strict\";</code> prologue at the top of the file. This setting disables the prologue.</p> </div>  </div></section> <section> <h3 id=\"noStrictGenericChecks-config\"> No Strict Generic Checks - <code>noStrictGenericChecks</code>\n</h3> <div> <div> <p>TypeScript will unify type parameters when comparing two generic functions.</p> <pre data-language=\"ts\">type A = &lt;T, U&gt;(x: T, y: U) =&gt; [T, U];\ntype B = &lt;S&gt;(x: S, y: S) =&gt; [S, S];\n \nfunction f(a: A, b: B) {\n  b = a; // Ok\n  a = b; // Error\n}</pre> <p>This flag can be used to remove that check.</p> </div> <ul><li>\n<span>Released:</span><p><a aria-label=\"Release notes for TypeScript 2.4\" href=\"https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-4.html\">2.4</a></p> </li></ul> </div></section> <section> <h3 id=\"out-config\"> Out - <code>out</code>\n</h3> <div> <div> <p>대신에 <a href=\"#outFile\">outFile</a> 을 사용하세요.</p> <p><code>out</code> 옵션은 예측 불가능하거나 일관되지 않은 방식으로 최종 파일 위치를 계산합니다. 이 옵션은 이전 버전과의 호환성을 위해 유지될 뿐 사용을 권장하지 않습니다.</p> </div> <ul>\n<li>\n<span>Deprecated</span> </li> <li>\n<span>Related:</span><ul>\n<li>\n<p><a href=\"#outDir\" aria-label=\"Jump to compiler option info for outDir\"><code>outDir</code></a></p> </li>\n<li>\n<p><a href=\"#outFile\" aria-label=\"Jump to compiler option info for outFile\"><code>outFile</code></a></p> </li>\n</ul>\n</li>\n</ul> </div></section> <section> <h3 id=\"suppressExcessPropertyErrors-config\"> Suppress Excess Property Errors - <code>suppressExcessPropertyErrors</code>\n</h3> <div> <div> <p>This disables reporting of excess property errors, such as the one shown in the following example:</p> <pre data-language=\"ts\">type Point = { x: number; y: number };\nconst p: Point = { x: 1, y: 3, m: 10 };</pre> <p>This flag was added to help people migrate to the stricter checking of new object literals in <a href=\"https://www.typescriptlang.org/docs/handbook/release-notes/typescript-1-6.html#stricter-object-literal-assignment-checks\">TypeScript 1.6</a>.</p> <p>We don’t recommend using this flag in a modern codebase, you can suppress one-off cases where you need it using <code>// @ts-ignore</code>.</p> </div>  </div></section> <section> <h3 id=\"suppressImplicitAnyIndexErrors-config\"> Suppress Implicit Any Index Errors - <code>suppressImplicitAnyIndexErrors</code>\n</h3> <div> <div> <p>Turning <code>suppressImplicitAnyIndexErrors</code> on suppresses reporting the error about implicit anys when indexing into objects, as shown in the following example:</p> <pre data-language=\"ts\">const obj = { x: 10 };\nconsole.log(obj[\"foo\"]);</pre> <p>Using <code>suppressImplicitAnyIndexErrors</code> is quite a drastic approach. It is recommended to use a <code>@ts-ignore</code> comment instead:</p> <pre data-language=\"ts\">const obj = { x: 10 };\n// @ts-ignore\nconsole.log(obj[\"foo\"]);</pre> </div> <ul><li>\n<span>Related:</span><ul><li>\n<p><a href=\"#noImplicitAny\" aria-label=\"Jump to compiler option info for noImplicitAny\"><code>noImplicitAny</code></a></p> </li></ul>\n</li></ul> </div></section> <div class=\"category\"> <h2 id=\"Language_and_Environment_6254\">Language and Environment</h2> </div> <section> <h3 id=\"emitDecoratorMetadata-config\"> Emit Decorator Metadata - <code>emitDecoratorMetadata</code>\n</h3> <div> <div> <p>Enables experimental support for emitting type metadata for decorators which works with the module <a href=\"https://www.npmjs.com/package/reflect-metadata\"><code>reflect-metadata</code></a>.</p> <p>For example, here is the TypeScript</p> <pre data-language=\"ts\">function LogMethod(\n  target: any,\n  propertyKey: string | symbol,\n  descriptor: PropertyDescriptor\n) {\n  console.log(target);\n  console.log(propertyKey);\n  console.log(descriptor);\n}\n \nclass Demo {\n  @LogMethod\n  public foo(bar: number) {\n    // do nothing\n  }\n}\n \nconst demo = new Demo();</pre> <p>With <code>emitDecoratorMetadata</code> not set to true (default) the emitted JavaScript is:</p> <pre data-language=\"ts\">\"use strict\";\nvar __decorate = (this &amp;&amp; this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c &lt; 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" &amp;&amp; typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i &gt;= 0; i--) if (d = decorators[i]) r = (c &lt; 3 ? d(r) : c &gt; 3 ? d(target, key, r) : d(target, key)) || r;\n    return c &gt; 3 &amp;&amp; r &amp;&amp; Object.defineProperty(target, key, r), r;\n};\nfunction LogMethod(target, propertyKey, descriptor) {\n    console.log(target);\n    console.log(propertyKey);\n    console.log(descriptor);\n}\nclass Demo {\n    foo(bar) {\n        // do nothing\n    }\n}\n__decorate([\n    LogMethod\n], Demo.prototype, \"foo\", null);\nconst demo = new Demo();\n </pre> <p>With <code>emitDecoratorMetadata</code> set to true the emitted JavaScript is:</p> <pre data-language=\"ts\">\"use strict\";\nvar __decorate = (this &amp;&amp; this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c &lt; 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" &amp;&amp; typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i &gt;= 0; i--) if (d = decorators[i]) r = (c &lt; 3 ? d(r) : c &gt; 3 ? d(target, key, r) : d(target, key)) || r;\n    return c &gt; 3 &amp;&amp; r &amp;&amp; Object.defineProperty(target, key, r), r;\n};\nvar __metadata = (this &amp;&amp; this.__metadata) || function (k, v) {\n    if (typeof Reflect === \"object\" &amp;&amp; typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\n};\nfunction LogMethod(target, propertyKey, descriptor) {\n    console.log(target);\n    console.log(propertyKey);\n    console.log(descriptor);\n}\nclass Demo {\n    foo(bar) {\n        // do nothing\n    }\n}\n__decorate([\n    LogMethod,\n    __metadata(\"design:type\", Function),\n    __metadata(\"design:paramtypes\", [Number]),\n    __metadata(\"design:returntype\", void 0)\n], Demo.prototype, \"foo\", null);\nconst demo = new Demo();\n </pre> </div> <ul><li>\n<span>Related:</span><ul><li>\n<p><a href=\"#experimentalDecorators\" aria-label=\"Jump to compiler option info for experimentalDecorators\"><code>experimentalDecorators</code></a></p> </li></ul>\n</li></ul> </div></section> <section> <h3 id=\"experimentalDecorators-config\"> Experimental Decorators - <code>experimentalDecorators</code>\n</h3> <div> <div> <p>Enables <a href=\"https://github.com/tc39/proposal-decorators\">experimental support for decorators</a>, which is a version of decorators that predates the TC39 standardization process.</p> <p>Decorators are a language feature which hasn’t yet been fully ratified into the JavaScript specification. This means that the implementation version in TypeScript may differ from the implementation in JavaScript when it it decided by TC39.</p> <p>You can find out more about decorator support in TypeScript in <a href=\"https://www.typescriptlang.org/docs/handbook/decorators.html\">the handbook</a>.</p> </div> <ul><li>\n<span>Related:</span><ul><li>\n<p><a href=\"#emitDecoratorMetadata\" aria-label=\"Jump to compiler option info for emitDecoratorMetadata\"><code>emitDecoratorMetadata</code></a></p> </li></ul>\n</li></ul> </div></section> <section> <h3 id=\"jsx-config\"> JSX - <code>jsx</code>\n</h3> <div> <div> <p>Controls how JSX constructs are emitted in JavaScript files. This only affects output of JS files that started in <code>.tsx</code> files.</p> <ul> <li>\n<code>react</code>: Emit <code>.js</code> files with JSX changed to the equivalent <code>React.createElement</code> calls</li> <li>\n<code>react-jsx</code>: Emit <code>.js</code> files with the JSX changed to <code>_jsx</code> calls</li> <li>\n<code>react-jsxdev</code>: Emit <code>.js</code> files with the JSX changed to <code>_jsx</code> calls</li> <li>\n<code>preserve</code>: Emit <code>.jsx</code> files with the JSX unchanged</li> <li>\n<code>react-native</code>: Emit <code>.js</code> files with the JSX unchanged</li> </ul> <h3 id=\"for-example\" style=\"position:relative;\">For example</h3> <p>This sample code:</p> <pre data-language=\"typescript+html\">export const HelloWorld = () =&gt; &lt;h1&gt;Hello world&lt;/h1&gt;;</pre> <p>Default: <code>\"react\"</code></p> <pre data-language=\"typescript+html\">import React from 'react';\nexport const HelloWorld = () =&gt; React.createElement(\"h1\", null, \"Hello world\");\n </pre> <p>Preserve: <code>\"preserve\"</code></p> <pre data-language=\"typescript+html\">import React from 'react';\nexport const HelloWorld = () =&gt; &lt;h1&gt;Hello world&lt;/h1&gt;;\n </pre> <p>React Native: <code>\"react-native\"</code></p> <pre data-language=\"typescript+html\">import React from 'react';\nexport const HelloWorld = () =&gt; &lt;h1&gt;Hello world&lt;/h1&gt;;\n </pre> <p>React 17 transform: <code>\"react-jsx\"</code><sup><a href=\"https://reactjs.org/blog/2020/09/22/introducing-the-new-jsx-transform.html\">[1]</a></sup></p> <pre data-language=\"typescript+html\">import { jsx as _jsx } from \"react/jsx-runtime\";\nimport React from 'react';\nexport const HelloWorld = () =&gt; _jsx(\"h1\", { children: \"Hello world\" });\n </pre> <p>React 17 dev transform: <code>\"react-jsxdev\"</code><sup><a href=\"https://reactjs.org/blog/2020/09/22/introducing-the-new-jsx-transform.html\">[1]</a></sup></p> <pre data-language=\"typescript+html\">import { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst _jsxFileName = \"/home/runner/work/TypeScript-Website/TypeScript-Website/index.tsx\";\nimport React from 'react';\nexport const HelloWorld = () =&gt; _jsxDEV(\"h1\", { children: \"Hello world\" }, void 0, false, { fileName: _jsxFileName, lineNumber: 9, columnNumber: 32 }, this);\n </pre> </div> <ul>\n<li>\n<span>Allowed:</span><ul>\n<li>\n<p><code>preserve</code></p> </li>\n<li>\n<p><code>react</code></p> </li>\n<li>\n<p><code>react-native</code></p> </li>\n<li>\n<p><code>react-jsx</code></p> </li>\n<li>\n<p><code>react-jsxdev</code></p> </li>\n</ul>\n</li> <li>\n<span>Related:</span><ul>\n<li>\n<p><a href=\"#jsxFactory\" aria-label=\"Jump to compiler option info for jsxFactory\"><code>jsxFactory</code></a></p> </li>\n<li>\n<p><a href=\"#jsxFragmentFactory\" aria-label=\"Jump to compiler option info for jsxFragmentFactory\"><code>jsxFragmentFactory</code></a></p> </li>\n<li>\n<p><a href=\"#jsxImportSource\" aria-label=\"Jump to compiler option info for jsxImportSource\"><code>jsxImportSource</code></a></p> </li>\n</ul>\n</li> <li>\n<span>Released:</span><p><a aria-label=\"Release notes for TypeScript 2.2\" href=\"https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-2.html\">2.2</a></p> </li>\n</ul> </div></section> <section> <h3 id=\"jsxFactory-config\"> JSX Factory - <code>jsxFactory</code>\n</h3> <div> <div> <p>Changes the function called in <code>.js</code> files when compiling JSX Elements using the classic JSX runtime. The most common change is to use <code>\"h\"</code> or <code>\"preact.h\"</code> instead of the default <code>\"React.createElement\"</code> if using <code>preact</code>.</p> <p>For example, this TSX file:</p> <pre data-language=\"typescript+html\">import { h } from \"preact\";\n\nconst HelloWorld = () =&gt; &lt;div&gt;Hello&lt;/div&gt;;</pre> <p>With <code>jsxFactory: \"h\"</code> looks like:</p> <pre data-language=\"typescript+html\">const preact_1 = require(\"preact\");\nconst HelloWorld = () =&gt; (0, preact_1.h)(\"div\", null, \"Hello\");\n </pre> <p>This option can be used on a per-file basis too similar to <a href=\"https://babeljs.io/docs/en/babel-plugin-transform-react-jsx#custom\">Babel’s <code>/** @jsx h */</code> directive</a>.</p> <pre data-language=\"typescript+html\">/** @jsx h */\nimport { h } from \"preact\";\n \nconst HelloWorld = () =&gt; &lt;div&gt;Hello&lt;/div&gt;;</pre> <p>The factory chosen will also affect where the <code>JSX</code> namespace is looked up (for type checking information) before falling back to the global one.</p> <p>If the factory is defined as <code>React.createElement</code> (the default), the compiler will check for <code>React.JSX</code> before checking for a global <code>JSX</code>. If the factory is defined as <code>h</code>, it will check for <code>h.JSX</code> before a global <code>JSX</code>.</p> </div> <ul>\n<li>\n<span>Default:</span><p><code>React.createElement</code></p> </li> <li>\n<span>Allowed:</span><ul><li>\n<p>Any identifier or dotted identifier.</p> </li></ul>\n</li> <li>\n<span>Related:</span><ul>\n<li>\n<p><a href=\"#jsx\" aria-label=\"Jump to compiler option info for jsx\"><code>jsx</code></a></p> </li>\n<li>\n<p><a href=\"#jsxFragmentFactory\" aria-label=\"Jump to compiler option info for jsxFragmentFactory\"><code>jsxFragmentFactory</code></a></p> </li>\n<li>\n<p><a href=\"#jsxImportSource\" aria-label=\"Jump to compiler option info for jsxImportSource\"><code>jsxImportSource</code></a></p> </li>\n</ul>\n</li>\n</ul> </div></section> <section> <h3 id=\"jsxFragmentFactory-config\"> jsxFragmentFactory - <code>jsxFragmentFactory</code>\n</h3> <div> <div> <p><code>Fragment</code>와 같이, <code>JsxFactory</code> 컴파일러 옵션이 지정된 react JSX 출력을 목표로 할 때 사용할 JSX 프래그먼트 팩토리 함수를 지정합니다.</p> <p>예를 들어 이 TSConfig의 경우:</p> <pre tsconfig=\"true\" data-language=\"typescript\">{\n  \"compilerOptions\": {\n    \"target\": \"esnext\",\n    \"module\": \"commonjs\",\n    \"jsx\": \"react\",\n    \"jsxFactory\": \"h\",\n    \"jsxFragmentFactory\": \"Fragment\"\n  }\n}</pre> <p>이 TSX 파일은:</p> <pre data-language=\"typescript+html\">import { h, Fragment } from \"preact\";\n\nconst HelloWorld = () =&gt; (\n  &lt;&gt;\n    &lt;div&gt;Hello&lt;/div&gt;\n  &lt;/&gt;\n);</pre> <p>다음과 같을 것입니다:</p> <pre data-language=\"typescript+html\">const preact_1 = require(\"preact\");\nconst HelloWorld = () =&gt; ((0, preact_1.h)(preact_1.Fragment, null,\n    (0, preact_1.h)(\"div\", null, \"Hello\")));\n </pre> <p>이 옵션은 <a href=\"https://babeljs.io/docs/en/babel-plugin-transform-react-jsx#fragments\">바벨의 <code>/* @jsxFrag h */</code> 지시문</a>과 매우 유사한 파일 단위로 사용이 가능합니다.</p> <p>예를 들어:</p> <pre data-language=\"typescript+html\">/** @jsx h */\n/** @jsxFrag Fragment */\n \nimport { h, Fragment } from \"preact\";\n \nconst HelloWorld = () =&gt; (\n  &lt;&gt;\n    &lt;div&gt;Hello&lt;/div&gt;\n  &lt;/&gt;\n);</pre> </div> <ul>\n<li>\n<span>Default:</span><p><code>React.Fragment</code></p> </li> <li>\n<span>Related:</span><ul>\n<li>\n<p><a href=\"#jsx\" aria-label=\"Jump to compiler option info for jsx\"><code>jsx</code></a></p> </li>\n<li>\n<p><a href=\"#jsxFactory\" aria-label=\"Jump to compiler option info for jsxFactory\"><code>jsxFactory</code></a></p> </li>\n<li>\n<p><a href=\"#jsxImportSource\" aria-label=\"Jump to compiler option info for jsxImportSource\"><code>jsxImportSource</code></a></p> </li>\n</ul>\n</li> <li>\n<span>Released:</span><p><a aria-label=\"Release notes for TypeScript 4.0\" href=\"https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-0.html\">4.0</a></p> </li>\n</ul> </div></section> <section> <h3 id=\"jsxImportSource-config\"> jsxImportSource - <code>jsxImportSource</code>\n</h3> <div> <div> <p>Typescript 4.1 버전에 소개된 <a href=\"#jsx\">jsx</a>를 <code>\"react-jsx\"</code> 또는 <code>\"react-jsxdev\"</code>로 사용할 때, <code>jsx</code> 와 <code>jsxs</code> 팩터리 함수를 import 하는데 사용할 모듈 지정자를 선언합니다.</p> <p><a href=\"https://reactjs.org/blog/2020/09/22/introducing-the-new-jsx-transform.html\">React 17</a>에서, 라이브러리는 독립된 import를 통하여 새로운 형태의 JSX 변환을 지원해 줍니다.</p> <p>예를 들어:</p> <pre data-language=\"typescript+html\">import React from \"react\";\n\nfunction App() {\n  return &lt;h1&gt;Hello World&lt;/h1&gt;;\n}</pre> <p>TSConfig 사용할 때:</p> <pre tsconfig=\"true\" data-language=\"typescript\">{\n  \"compilerOptions\": {\n    \"target\": \"esnext\",\n    \"module\": \"commonjs\",\n    \"jsx\": \"react-jsx\"\n  }\n}</pre> <p>TypeScript에서 컴파일 된 JavaScript는:</p> <pre data-language=\"typescript+html\">\"use strict\";\nvar __importDefault = (this &amp;&amp; this.__importDefault) || function (mod) {\n    return (mod &amp;&amp; mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst jsx_runtime_1 = require(\"react/jsx-runtime\");\nconst react_1 = __importDefault(require(\"react\"));\nfunction App() {\n    return (0, jsx_runtime_1.jsx)(\"h1\", { children: \"Hello World\" });\n}\n </pre> <p>예를 들어, <code>\"jsxImportSource\": \"preact\"</code>를 사용하고 싶으시면, 다음과 같은 tsconfig를 이용하시면 됩니다:</p> <pre tsconfig=\"true\" data-language=\"typescript\">{\n  \"compilerOptions\": {\n    \"target\": \"esnext\",\n    \"module\": \"commonjs\",\n    \"jsx\": \"react-jsx\",\n    \"jsxImportSource\": \"preact\",\n    \"types\": [\"preact\"]\n  }\n}</pre> <p>다음과 같은 코드를 생성합니다:</p> <pre data-language=\"typescript+html\">function App() {\n    return (0, jsx_runtime_1.jsx)(\"h1\", { children: \"Hello World\" });\n}\nexports.App = App;\n </pre> <p>또는, 파일 별 프래그마(per-file pragma)를 이용하여 다음과 같은 옵션을 설정할 수 있습니다:</p> <pre data-language=\"typescript+html\">/** @jsxImportSource preact */\n\nexport function App() {\n  return &lt;h1&gt;Hello World&lt;/h1&gt;;\n}</pre> <p><code>_jsx</code>팩토리를 위한 import로서 <code>preact/jsx-runtime</code>를 추가합니다.</p> <p><em>노트:</em> 의도한 대로 작동이 되려면, <code>tsx</code>파일은 <code>export</code> 또는 <code>import</code>를 추가해야만, 모듈로 간주됩니다.</p> </div> <ul>\n<li>\n<span>Default:</span><p><code>react</code></p> </li> <li>\n<span>Related:</span><ul>\n<li>\n<p><a href=\"#jsx\" aria-label=\"Jump to compiler option info for jsx\"><code>jsx</code></a></p> </li>\n<li>\n<p><a href=\"#jsxFactory\" aria-label=\"Jump to compiler option info for jsxFactory\"><code>jsxFactory</code></a></p> </li>\n</ul>\n</li> <li>\n<span>Released:</span><p><a aria-label=\"Release notes for TypeScript 4.1\" href=\"https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-1.html\">4.1</a></p> </li>\n</ul> </div></section> <section> <h3 id=\"lib-config\"> Lib - <code>lib</code>\n</h3> <div> <div> <p>TypeScript는 JS API(<code>Math</code> 와 같은)에 대한 기본적인 타입 정의와 브라우저 환경(<code>document</code> 와 같은)에 있는 타입 정의를 포함합니다. 이 뿐만 아니라 TypeScript는 지정한 <code>target</code> 과 일치하는 최신 JS 기능을 위한 API도 포함되어 있습니다; 예를 들어 <code>target</code>이 <code>ES6</code> 이상이면 <code>Map</code> 에 대한 정의를 사용할 수 있습니다.</p> <p>이는 몇 가지 이유에 의해 변경될 수 있습니다:</p> <ul> <li>프로그램이 브라우저에서 동작하지 않아 <code>\"dom\"</code> 타입의 정의가 필요 없을 경우</li> <li>런타임 플랫폼이 특정 JavaScript API 객체를 제공하지만(폴리필을 통해서) 아직 주어진 ECMAScript 버전의 문법을 일부 지원하지 않을 경우</li> <li>더 높은 버전의 ECMAScript을 위한 폴리필이나 네이티브 구현이 있을 경우</li> </ul> <h3 id=\"상위-레벨-라이브러리\" style=\"position:relative;\">상위 레벨 라이브러리</h3> <table> <thead> <tr> <th>Name</th> <th>Contents</th> </tr> </thead> <tbody> <tr> <td><code>ES5</code></td> <td>모든 ES3 및 ES5 기능에 대한 핵심적인 정의</td> </tr> <tr> <td><code>ES2015</code></td> <td>ES2015(또는 ES6로 알려진)에서 추가로 사용 가능한 API - <code>array.find</code>, <code>Promise</code>, <code>Proxy</code>, <code>Symbol</code>, <code>Map</code>, <code>Set</code>, <code>Reflect</code>, 기타 등등</td> </tr> <tr> <td><code>ES6</code></td> <td>“ES2015” 의 별칭</td> </tr> <tr> <td><code>ES2016</code></td> <td>ES2016에서 추가로 사용 가능한 API - <code>array.include</code>, 기타 등등</td> </tr> <tr> <td><code>ES7</code></td> <td>“ES2016” 의 별칭</td> </tr> <tr> <td><code>ES2017</code></td> <td>ES2017 에서 추가로 사용 가능한 API - <code>Object.entries</code>, <code>Object.values</code>, <code>Atomics</code>, <code>SharedArrayBuffer</code>, <code>date.formatToParts</code>, typed arrays, 기타 등등</td> </tr> <tr> <td><code>ES2018</code></td> <td>ES2018 에서 추가로 사용 가능한 API - <code>async</code> iterables, <code>promise.finally</code>, <code>Intl.PluralRules</code>, <code>rexexp.groups</code>, 기타 등등</td> </tr> <tr> <td><code>ES2019</code></td> <td>ES2019 에서 추가로 사용 가능한 API - <code>array.flat</code>, <code>array.flatMap</code>, <code>Object.fromEntries</code>, <code>string.trimStart</code>, <code>string.trimEnd</code>, 기타 등등</td> </tr> <tr> <td><code>ES2020</code></td> <td>ES2020 에서 추가로 사용 가능한 API - <code>string.matchAll</code>, etc.</td> </tr> <tr> <td><code>ESNext</code></td> <td>ESNext 에서 추가로 사용 가능한 API - 이는 JavaScript의 사양이 향상될 때 마다 변함.</td> </tr> <tr> <td><code>DOM</code></td> <td>\n<a href=\"https://developer.mozilla.org/docs/Glossary/DOM\">DOM</a> 정의 - <code>window</code>, <code>document</code>, etc.</td> </tr> <tr> <td><code>WebWorker</code></td> <td>\n<a href=\"https://developer.mozilla.org/docs/Web/API/Web_Workers_API/Using_web_workers\">웹 워커(WebWorker)</a> 환경에서 추가로 사용 가능한 API</td> </tr> <tr> <td><code>ScriptHost</code></td> <td>\n<a href=\"https://wikipedia.org/wiki/Windows_Script_Host\">윈도우 스크립트 호스트 시스템(Windows Script Hosting System)</a> 을 위한 API</td> </tr> </tbody> </table> <h3 id=\"개별적인-라이브러리-컴포넌트\" style=\"position:relative;\">개별적인 라이브러리 컴포넌트</h3> <table> <thead> <tr> <th>Name</th> </tr> </thead> <tbody> <tr> <td><code>DOM.Iterable</code></td> </tr> <tr> <td><code>ES2015.Core</code></td> </tr> <tr> <td><code>ES2015.Collection</code></td> </tr> <tr> <td><code>ES2015.Generator</code></td> </tr> <tr> <td><code>ES2015.Iterable</code></td> </tr> <tr> <td><code>ES2015.Promise</code></td> </tr> <tr> <td><code>ES2015.Proxy</code></td> </tr> <tr> <td><code>ES2015.Reflect</code></td> </tr> <tr> <td><code>ES2015.Symbol</code></td> </tr> <tr> <td><code>ES2015.Symbol.WellKnown</code></td> </tr> <tr> <td><code>ES2016.Array.Include</code></td> </tr> <tr> <td><code>ES2017.object</code></td> </tr> <tr> <td><code>ES2017.Intl</code></td> </tr> <tr> <td><code>ES2017.SharedMemory</code></td> </tr> <tr> <td><code>ES2017.String</code></td> </tr> <tr> <td><code>ES2017.TypedArrays</code></td> </tr> <tr> <td><code>ES2018.Intl</code></td> </tr> <tr> <td><code>ES2018.Promise</code></td> </tr> <tr> <td><code>ES2018.RegExp</code></td> </tr> <tr> <td><code>ES2019.Array</code></td> </tr> <tr> <td><code>ES2019.Full</code></td> </tr> <tr> <td><code>ES2019.Object</code></td> </tr> <tr> <td><code>ES2019.String</code></td> </tr> <tr> <td><code>ES2019.Symbol</code></td> </tr> <tr> <td><code>ES2020.Full</code></td> </tr> <tr> <td><code>ES2020.String</code></td> </tr> <tr> <td><code>ES2020.Symbol.wellknown</code></td> </tr> <tr> <td><code>ESNext.AsyncIterable</code></td> </tr> <tr> <td><code>ESNext.Array</code></td> </tr> <tr> <td><code>ESNext.Intl</code></td> </tr> <tr> <td><code>ESNext.Symbol</code></td> </tr> </tbody> </table> <p>위 목록들은 최신이 아닐수도 있습니다. 전체적인 목록은 <a href=\"https://github.com/microsoft/TypeScript/tree/master/lib\">TypeScript의 소스 코드</a> 에서 조회할 수 있습니다.</p> </div> <ul>\n<li>\n<span>Related:</span><ul><li>\n<p><a href=\"#noLib\" aria-label=\"Jump to compiler option info for noLib\"><code>noLib</code></a></p> </li></ul>\n</li> <li>\n<span>Released:</span><p><a aria-label=\"Release notes for TypeScript 2.0\" href=\"https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-0.html\">2.0</a></p> </li>\n</ul> </div></section> <section> <h3 id=\"moduleDetection-config\"> Module Detection - <code>moduleDetection</code>\n</h3> <div> <div> <p>This setting controls how TypeScript determines whether a file is a <a href=\"https://www.typescriptlang.org/docs/handbook/2/modules.html#how-javascript-modules-are-defined\">script or a module</a>.</p> <p>There are three choices:</p> <ul> <li> <p><code>\"auto\"</code> (default) - TypeScript will not only look for import and export statements, but it will also check whether the <code>\"type\"</code> field in a <code>package.json</code> is set to <code>\"module\"</code> when running with <a href=\"#module\"><code>module</code></a>: <code>nodenext</code> or <code>node16</code>, and check whether the current file is a JSX file when running under <a href=\"#jsx\"><code>jsx</code></a>: <code>react-jsx</code>.</p> </li> <li> <p><code>\"legacy\"</code> - The same behavior as 4.6 and prior, usings import and export statements to determine whether a file is a module.</p> </li> <li> <p><code>\"force\"</code> - Ensures that every non-declaration file is treated as a module.</p> </li> </ul> </div> <ul>\n<li>\n<span>Default:</span><p>\"auto\": Treat files with imports, exports, import.meta, jsx (with jsx: react-jsx), or esm format (with module: node16+) as modules.</p> </li> <li>\n<span>Allowed:</span><ul>\n<li>\n<p><code>legacy</code></p> </li>\n<li>\n<p><code>auto</code></p> </li>\n<li>\n<p><code>force</code></p> </li>\n</ul>\n</li> <li>\n<span>Released:</span><p><a aria-label=\"Release notes for TypeScript 4.7\" href=\"https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-7.html\">4.7</a></p> </li>\n</ul> </div></section> <section> <h3 id=\"noLib-config\"> No Lib - <code>noLib</code>\n</h3> <div> <div> <p>Disables the automatic inclusion of any library files. If this option is set, <code>lib</code> is ignored.</p> <p>TypeScript <em>cannot</em> compile anything without a set of interfaces for key primitives like: <code>Array</code>, <code>Boolean</code>, <code>Function</code>, <code>IArguments</code>, <code>Number</code>, <code>Object</code>, <code>RegExp</code>, and <code>String</code>. It is expected that if you use <code>noLib</code> you will be including your own type definitions for these.</p> </div> <ul><li>\n<span>Related:</span><ul><li>\n<p><a href=\"#lib\" aria-label=\"Jump to compiler option info for lib\"><code>lib</code></a></p> </li></ul>\n</li></ul> </div></section> <section> <h3 id=\"reactNamespace-config\"> React Namespace - <code>reactNamespace</code>\n</h3> <div> <div> <p>Use <a href=\"#jsxFactory\"><code>jsxFactory</code></a> instead. Specify the object invoked for <code>createElement</code> when targeting <code>react</code> for TSX files.</p> </div> <ul><li>\n<span>Default:</span><p><code>React</code></p> </li></ul> </div></section> <section> <h3 id=\"target-config\"> Target - <code>target</code>\n</h3> <div> <div> <p>최신 브라우저는 모든 ES6 기능을 지원하므로 <code>ES6</code>는 좋은 선택입니다. 만약 코드가 이전 환경에서 배포된 경우라면 더 낮은 버전을, 최신 환경에서 실행이 보장되는 경우 더 높은 버전을 선택할 수 있습니다.</p> <p><code>target</code> 설정은 하향 평준화된 JS 기능과 온전히 남아있는 것을 변경합니다. 예를 들어 <code>target</code>이 ES5 이하인 경우, 화살 함수 <code>() =&gt; this</code>는 동등한 <code>function</code> 표현식으로 바뀝니다.</p> <p><code>target</code>을 바꾼다는 것은 마찬가지로 <a href=\"#lib\"><code>lib</code></a>의 기본값을 바꿉니다. 원하는 대로 <code>target</code> 및 <code>lib</code> 설정을 “믹스 앤 매치” 할 수 있지만, 편의를 위해 <code>target</code>만 설정할 수 있습니다.</p> <p>Node와 같은 개발자 플랫폼의 경우 버전에 따라 대상에 대한 특정 기준이 있습니다. <a href=\"https://github.com/tsconfig/bases#centralized-recommendations-for-tsconfig-bases\">tsconfig/bases</a>에서 공통 플랫폼 및 해당 버전에 대한 커뮤니티 구성 TSConfig 세트를 찾을 수 있습니다.</p> <p><code>ESNext</code> 값은 특별하게 TypeScript가 지원하는 가장 높은 버전을 나타냅니다. 이 설정은 TypeScript 버전과 같다는 것을 의미하는 것이 아니며 업그레이드 예측 가능성을 낮출 수 있으므로 주의해야 합니다.</p> </div> <ul>\n<li>\n<span>Default:</span><p><code>ES3</code></p> </li> <li>\n<span>Allowed:</span><ul>\n<li>\n<p><code>es3</code></p> </li>\n<li>\n<p><code>es5</code></p> </li>\n<li>\n<p><code>es6</code>/<code>es2015</code></p> </li>\n<li>\n<p><code>es2016</code></p> </li>\n<li>\n<p><code>es2017</code></p> </li>\n<li>\n<p><code>es2018</code></p> </li>\n<li>\n<p><code>es2019</code></p> </li>\n<li>\n<p><code>es2020</code></p> </li>\n<li>\n<p><code>es2021</code></p> </li>\n<li>\n<p><code>es2022</code></p> </li>\n<li>\n<p><code>esnext</code></p> </li>\n</ul>\n</li> <li>\n<span>Released:</span><p><a aria-label=\"Release notes for TypeScript 1.0\" href=\"https://www.typescriptlang.org/docs/handbook/release-notes/typescript-1-0.html\">1.0</a></p> </li>\n</ul> </div></section> <section> <h3 id=\"useDefineForClassFields-config\"> Use Define For Class Fields - <code>useDefineForClassFields</code>\n</h3> <div> <div> <p>This flag is used as part of migrating to the upcoming standard version of class fields. TypeScript introduced class fields many years before it was ratified in TC39. The latest version of the upcoming specification has a different runtime behavior to TypeScript’s implementation but the same syntax.</p> <p>This flag switches to the upcoming ECMA runtime behavior.</p> <p>You can read more about the transition in <a href=\"https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-7.html#the-usedefineforclassfields-flag-and-the-declare-property-modifier\">the 3.7 release notes</a>.</p> </div> <ul>\n<li>\n<span>Default:</span><p><code>true</code> if <a href=\"#target\"><code>target</code></a> is <code>ES2022</code> or higher, including <code>ESNext</code>; <code>false</code> otherwise.</p> </li> <li>\n<span>Released:</span><p><a aria-label=\"Release notes for TypeScript 3.7\" href=\"https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-7.html\">3.7</a></p> </li>\n</ul> </div></section> <div class=\"category\"> <h2 id=\"Compiler_Diagnostics_6251\">Compiler Diagnostics</h2> </div> <section> <h3 id=\"diagnostics-config\"> Diagnostics - <code>diagnostics</code>\n</h3> <div> <div> <p>Used to output diagnostic information for debugging. This command is a subset of <a href=\"#extendedDiagnostics\"><code>extendedDiagnostics</code></a> which are more user-facing results, and easier to interpret.</p> <p>If you have been asked by a TypeScript compiler engineer to give the results using this flag in a compile, in which there is no harm in using <a href=\"#extendedDiagnostics\"><code>extendedDiagnostics</code></a> instead.</p> </div> <ul>\n<li>\n<span>Deprecated</span> </li> <li>\n<span>Related:</span><ul><li>\n<p><a href=\"#extendedDiagnostics\" aria-label=\"Jump to compiler option info for extendedDiagnostics\"><code>extendedDiagnostics</code></a></p> </li></ul>\n</li>\n</ul> </div></section> <section> <h3 id=\"explainFiles-config\"> Explain Files - <code>explainFiles</code>\n</h3> <div> <div> <p>Print names of files which TypeScript sees as a part of your project and the reason they are part of the compilation.</p> <p>For example, with this project of just a single <code>index.ts</code> file</p> <pre data-language=\"shell\">example\n├── index.ts\n├── package.json\n└── tsconfig.json</pre> <p>Using a <code>tsconfig.json</code> which has <code>explainFiles</code> set to true:</p> <pre data-language=\"json\">{\n  \"compilerOptions\": {\n    \"target\": \"es5\",\n    \"module\": \"commonjs\",\n    \"explainFiles\": true\n  }\n}</pre> <p>Running TypeScript against this folder would have output like this:</p> <pre data-language=\"typescript\">❯ tsc\nnode_modules/typescript/lib/lib.d.ts\n  Default library for target 'es5'\nnode_modules/typescript/lib/lib.es5.d.ts\n  Library referenced via 'es5' from file 'node_modules/typescript/lib/lib.d.ts'\nnode_modules/typescript/lib/lib.dom.d.ts\n  Library referenced via 'dom' from file 'node_modules/typescript/lib/lib.d.ts'\nnode_modules/typescript/lib/lib.webworker.importscripts.d.ts\n  Library referenced via 'webworker.importscripts' from file 'node_modules/typescript/lib/lib.d.ts'\nnode_modules/typescript/lib/lib.scripthost.d.ts\n  Library referenced via 'scripthost' from file 'node_modules/typescript/lib/lib.d.ts'\nindex.ts\n  Matched by include pattern '**/*' in 'tsconfig.json'</pre> <p>The output above show:</p> <ul> <li>The initial lib.d.ts lookup based on <a href=\"#target\"><code>target</code></a>, and the chain of <code>.d.ts</code> files which are referenced</li> <li>The <code>index.ts</code> file located via the default pattern of <a href=\"#include\"><code>include</code></a>\n</li> </ul> <p>This option is intended for debugging how a file has become a part of your compile.</p> </div> <ul><li>\n<span>Released:</span><p><a aria-label=\"Release notes for TypeScript 4.2\" href=\"https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-2.html\">4.2</a></p> </li></ul> </div></section> <section> <h3 id=\"extendedDiagnostics-config\"> Extended Diagnostics - <code>extendedDiagnostics</code>\n</h3> <div> <div> <p>You can use this flag to discover where TypeScript is spending its time when compiling. This is a tool used for understanding the performance characteristics of your codebase overall.</p> <p>You can learn more about how to measure and understand the output in the performance <a href=\"https://github.com/microsoft/TypeScript/wiki/Performance\">section of the wiki</a>.</p> </div> <ul><li>\n<span>Related:</span><ul><li>\n<p><a href=\"#diagnostics\" aria-label=\"Jump to compiler option info for diagnostics\"><code>diagnostics</code></a></p> </li></ul>\n</li></ul> </div></section> <section> <h3 id=\"generateCpuProfile-config\"> Generate CPU Profile - <code>generateCpuProfile</code>\n</h3> <div> <div> <p>This option gives you the chance to have TypeScript emit a v8 CPU profile during the compiler run. The CPU profile can provide insight into why your builds may be slow.</p> <p>This option can only be used from the CLI via: <code>--generateCpuProfile tsc-output.cpuprofile</code>.</p> <pre data-language=\"shell\">npm run tsc --generateCpuProfile tsc-output.cpuprofile</pre> <p>This file can be opened in a chromium based browser like Chrome or Edge Developer in <a href=\"https://developers.google.com/web/tools/chrome-devtools/rendering-tools/js-execution\">the CPU profiler</a> section. You can learn more about understanding the compilers performance in the <a href=\"https://github.com/microsoft/TypeScript/wiki/Performance\">TypeScript wiki section on performance</a>.</p> </div> <ul>\n<li>\n<span>Default:</span><p><code>profile.cpuprofile</code></p> </li> <li>\n<span>Released:</span><p><a aria-label=\"Release notes for TypeScript 3.7\" href=\"https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-7.html\">3.7</a></p> </li>\n</ul> </div></section> <section> <h3 id=\"listEmittedFiles-config\"> List Emitted Files - <code>listEmittedFiles</code>\n</h3> <div> <div> <p>Print names of generated files part of the compilation to the terminal.</p> <p>This flag is useful in two cases:</p> <ul> <li>You want to transpile TypeScript as a part of a build chain in the terminal where the filenames are processed in the next command.</li> <li>You are not sure that TypeScript has included a file you expected, as a part of debugging the <a href=\"#Project_Files_0\">file inclusion settings</a>.</li> </ul> <p>For example:</p> <pre data-language=\"typescript\">example\n├── index.ts\n├── package.json\n└── tsconfig.json</pre> <p>With:</p> <pre tsconfig=\"true\" data-language=\"typescript\">{\n  \"compilerOptions\": {\n    \"declaration\": true,\n    \"listFiles\": true\n  }\n}</pre> <p>Would echo paths like:</p> <pre data-language=\"typescript\">$ npm run tsc\n\npath/to/example/index.js\npath/to/example/index.d.ts</pre> <p>Normally, TypeScript would return silently on success.</p> </div>  </div></section> <section> <h3 id=\"listFiles-config\"> List Files - <code>listFiles</code>\n</h3> <div> <div> <p>컴파일하는 파일 이름을 출력합니다. 이 기능은 TypeScript에 예상한 파일이 포함되어 있는지 확실하지 않을 때 유용합니다.</p> <p>예를들면:</p> <pre data-language=\"typescript\">example\n├── index.ts\n├── package.json\n└── tsconfig.json</pre> <p>다음과 같습니다:</p> <pre tsconfig=\"true\" data-language=\"typescript\">{\n  \"compilerOptions\": {\n    \"listFiles\": true\n  }\n}</pre> <p>echo paths는 다음과 같습니다:</p> <pre data-language=\"typescript\">$ npm run tsc\npath/to/example/node_modules/typescript/lib/lib.d.ts\npath/to/example/node_modules/typescript/lib/lib.es5.d.ts\npath/to/example/node_modules/typescript/lib/lib.dom.d.ts\npath/to/example/node_modules/typescript/lib/lib.webworker.importscripts.d.ts\npath/to/example/node_modules/typescript/lib/lib.scripthost.d.ts\npath/to/example/index.ts</pre> <p>TypeScript 4.2 버전을 사용할 경우 <a href=\"#explainFiles\"><code>explainFiles</code></a>을 참조하십시오. 파일이 추가된 이유에 대한 설명 또한 제공합니다.</p> </div> <ul><li>\n<span>Related:</span><ul><li>\n<p><a href=\"#explainFiles\" aria-label=\"Jump to compiler option info for explainFiles\"><code>explainFiles</code></a></p> </li></ul>\n</li></ul> </div></section> <section> <h3 id=\"traceResolution-config\"> Trace Resolution - <code>traceResolution</code>\n</h3> <div> <div> <p>사용자가 모듈이 포함되지 않은 이유를 디버깅하고자 할 때. <code>traceResolutions</code>를 <code>true</code>로 설정하여 처리된 각 파일의 처리 과정에 대한 TypeScript 출력 정보를 얻을 수 있습니다.</p> <p><a href=\"https://www.typescriptlang.org/docs/handbook/module-resolution.html#tracing-module-resolution\">핸드북</a>에서 이에 대한 자세한 내용을 볼 수 있습니다.</p> </div> <ul><li>\n<span>Released:</span><p><a aria-label=\"Release notes for TypeScript 2.0\" href=\"https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-0.html\">2.0</a></p> </li></ul> </div></section> <div class=\"category\"> <h2 id=\"Projects_6255\">Projects</h2> </div> <section> <h3 id=\"composite-config\"> Composite - <code>composite</code>\n</h3> <div> <div> <p><code>composite</code> 옵션은 아직 빌드되지 않은 프로젝트의 빠른 빌드 설정을 위해 빌드 도구(<code>—build</code> 모드에서 TypeScript를 포함한)에 특정 조건을 적용합니다.</p> <p>이 설정이 켜져 있으면:</p> <ul> <li> <p>만약 <code>rootDir</code> 설정이 설정되어 있지 않다면, 기본값은 ‘tsconfig.json’ 파일을 포함하는 디렉터리입니다.</p> </li> <li> <p>모든 실행 파일은 <code>include</code> 패턴과 일치하거나 <code>파일</code> 배열에 나열되어야 합니다. 만약 이 제약 조건을 위반하면, ‘tsc’는 지정되지 않은 파일을 알려줍니다.</p> </li> <li> <p><code>declaration</code>의 기본값은 <code>true</code> 입니다.</p> </li> </ul> <p>TypeScript 프로젝트에 대한 문서는 <a href=\"https://www.typescriptlang.org/docs/handbook/project-references.html\">핸드북</a>에서 확인할 수 있습니다.</p> </div> <ul>\n<li>\n<span>Related:</span><ul>\n<li>\n<p><a href=\"#incremental\" aria-label=\"Jump to compiler option info for incremental\"><code>incremental</code></a></p> </li>\n<li>\n<p><a href=\"#tsBuildInfoFile\" aria-label=\"Jump to compiler option info for tsBuildInfoFile\"><code>tsBuildInfoFile</code></a></p> </li>\n</ul>\n</li> <li>\n<span>Released:</span><p><a aria-label=\"Release notes for TypeScript 3.0\" href=\"https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-0.html\">3.0</a></p> </li>\n</ul> </div></section> <section> <h3 id=\"disableReferencedProjectLoad-config\"> Disable Referenced Project Load - <code>disableReferencedProjectLoad</code>\n</h3> <div> <div> <p>In multi-project TypeScript programs, TypeScript will load all of the available projects into memory in order to provide accurate results for editor responses which require a full knowledge graph like ‘Find All References’.</p> <p>If your project is large, you can use the flag <code>disableReferencedProjectLoad</code> to disable the automatic loading of all projects. Instead, projects are loaded dynamically as you open files through your editor.</p> </div> <ul><li>\n<span>Released:</span><p><a aria-label=\"Release notes for TypeScript 4.0\" href=\"https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-0.html\">4.0</a></p> </li></ul> </div></section> <section> <h3 id=\"disableSolutionSearching-config\"> Disable Solution Searching - <code>disableSolutionSearching</code>\n</h3> <div> <div> <p>When working with <a href=\"https://www.typescriptlang.org/docs/handbook/project-references.html\">composite TypeScript projects</a>, this option provides a way to declare that you do not want a project to be included when using features like <em>find all references</em> or <em>jump to definition</em> in an editor.</p> <p>This flag is something you can use to increase responsiveness in large composite projects.</p> </div> <ul><li>\n<span>Released:</span><p><a aria-label=\"Release notes for TypeScript 3.8\" href=\"https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-8.html\">3.8</a></p> </li></ul> </div></section> <section> <h3 id=\"disableSourceOfProjectReferenceRedirect-config\"> Disable Source Project Reference Redirect - <code>disableSourceOfProjectReferenceRedirect</code>\n</h3> <div> <div> <p>When working with <a href=\"https://www.typescriptlang.org/docs/handbook/project-references.html\">composite TypeScript projects</a>, this option provides a way to go <a href=\"https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-7.html#build-free-editing-with-project-references\">back to the pre-3.7</a> behavior where d.ts files were used to as the boundaries between modules. In 3.7 the source of truth is now your TypeScript files.</p> </div> <ul><li>\n<span>Released:</span><p><a aria-label=\"Release notes for TypeScript 3.7\" href=\"https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-7.html\">3.7</a></p> </li></ul> </div></section> <section> <h3 id=\"incremental-config\"> Incremental - <code>incremental</code>\n</h3> <div> <div> <p>Tells TypeScript to save information about the project graph from the last compilation to files stored on disk. This creates a series of <code>.tsbuildinfo</code> files in the same folder as your compilation output. They are not used by your JavaScript at runtime and can be safely deleted. You can read more about the flag in the <a href=\"https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-4.html#faster-subsequent-builds-with-the---incremental-flag\">3.4 release notes</a>.</p> <p>To control which folders you want to the files to be built to, use the config option <a href=\"#tsBuildInfoFile\"><code>tsBuildInfoFile</code></a>.</p> </div> <ul>\n<li>\n<span>Default:</span><p><code>true</code> if <a href=\"#composite\"><code>composite</code></a>; <code>false</code> otherwise.</p> </li> <li>\n<span>Related:</span><ul>\n<li>\n<p><a href=\"#composite\" aria-label=\"Jump to compiler option info for composite\"><code>composite</code></a></p> </li>\n<li>\n<p><a href=\"#tsBuildInfoFile\" aria-label=\"Jump to compiler option info for tsBuildInfoFile\"><code>tsBuildInfoFile</code></a></p> </li>\n</ul>\n</li> <li>\n<span>Released:</span><p><a aria-label=\"Release notes for TypeScript 3.4\" href=\"https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-4.html\">3.4</a></p> </li>\n</ul> </div></section> <section> <h3 id=\"tsBuildInfoFile-config\"> TS Build Info File - <code>tsBuildInfoFile</code>\n</h3> <div> <div> <p>This setting lets you specify a file for storing incremental compilation information as a part of composite projects which enables faster building of larger TypeScript codebases. You can read more about composite projects <a href=\"https://www.typescriptlang.org/docs/handbook/project-references.html\">in the handbook</a>.</p> <p>The default depends on a combination of other settings:</p> <ul> <li>If <code>outFile</code> is set, the default is <code>&lt;outFile&gt;.tsbuildinfo</code>.</li> <li>If <code>rootDir</code> and <code>outDir</code> are set, then the file is <code>&lt;outDir&gt;/&lt;relative path to config from rootDir&gt;/&lt;config name&gt;.tsbuildinfo</code> For example, if <code>rootDir</code> is <code>src</code>, <code>outDir</code> is <code>dest</code>, and the config is <code>./tsconfig.json</code>, then the default is <code>./tsconfig.tsbuildinfo</code> as the relative path from <code>src/</code> to <code>./tsconfig.json</code> is <code>../</code>.</li> <li>If <code>outDir</code> is set, then the default is <code>&lt;outDir&gt;/&lt;config name&gt;.tsbuildInfo</code>\n</li> <li>Otherwise, the default is <code>&lt;config name&gt;.tsbuildInfo</code>\n</li> </ul> </div> <ul>\n<li>\n<span>Default:</span><p><code>.tsbuildinfo</code></p> </li> <li>\n<span>Related:</span><ul>\n<li>\n<p><a href=\"#incremental\" aria-label=\"Jump to compiler option info for incremental\"><code>incremental</code></a></p> </li>\n<li>\n<p><a href=\"#composite\" aria-label=\"Jump to compiler option info for composite\"><code>composite</code></a></p> </li>\n</ul>\n</li> <li>\n<span>Released:</span><p><a aria-label=\"Release notes for TypeScript 3.4\" href=\"https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-4.html\">3.4</a></p> </li>\n</ul> </div></section> <div class=\"category\"> <h2 id=\"Output_Formatting_6256\">Output Formatting</h2> </div> <section> <h3 id=\"noErrorTruncation-config\"> No Error Truncation - <code>noErrorTruncation</code>\n</h3> <div> <div> <p>Do not truncate error messages.</p> <p>With <code>false</code>, the default.</p> <pre data-language=\"ts\">var x: {\n  propertyWithAnExceedinglyLongName1: string;\n  propertyWithAnExceedinglyLongName2: string;\n  propertyWithAnExceedinglyLongName3: string;\n  propertyWithAnExceedinglyLongName4: string;\n  propertyWithAnExceedinglyLongName5: string;\n  propertyWithAnExceedinglyLongName6: string;\n  propertyWithAnExceedinglyLongName7: string;\n  propertyWithAnExceedinglyLongName8: string;\n};\n \n// String representation of type of 'x' should be truncated in error message\nvar s: string = x;</pre> <p>With <code>true</code></p> <pre data-language=\"ts\">var x: {\n  propertyWithAnExceedinglyLongName1: string;\n  propertyWithAnExceedinglyLongName2: string;\n  propertyWithAnExceedinglyLongName3: string;\n  propertyWithAnExceedinglyLongName4: string;\n  propertyWithAnExceedinglyLongName5: string;\n  propertyWithAnExceedinglyLongName6: string;\n  propertyWithAnExceedinglyLongName7: string;\n  propertyWithAnExceedinglyLongName8: string;\n};\n \n// String representation of type of 'x' should be truncated in error message\nvar s: string = x;</pre> </div>  </div></section> <section> <h3 id=\"preserveWatchOutput-config\"> Preserve Watch Output - <code>preserveWatchOutput</code>\n</h3> <div> <div> <p>Whether to keep outdated console output in watch mode instead of clearing the screen every time a change happened.</p> </div> <ul><li>\n<span>Internal</span> </li></ul> </div></section> <section> <h3 id=\"pretty-config\"> Pretty - <code>pretty</code>\n</h3> <div> <div> <p>Stylize errors and messages using color and context, this is on by default — offers you a chance to have less terse, single colored messages from the compiler.</p> </div> <ul><li>\n<span>Default:</span><p><code>true</code></p> </li></ul> </div></section> <div class=\"category\"> <h2 id=\"Completeness_6257\">Completeness</h2> </div> <section> <h3 id=\"skipDefaultLibCheck-config\"> Skip Default Lib Check - <code>skipDefaultLibCheck</code>\n</h3> <div> <div> <p>Use <a href=\"#skipLibCheck\"><code>skipLibCheck</code></a> instead. Skip type checking of default library declaration files.</p> </div>  </div></section> <section> <h3 id=\"skipLibCheck-config\"> Skip Lib Check - <code>skipLibCheck</code>\n</h3> <div> <div> <p>Skip type checking of declaration files.</p> <p>This can save time during compilation at the expense of type-system accuracy. For example, two libraries could define two copies of the same <code>type</code> in an inconsistent way. Rather than doing a full check of all <code>d.ts</code> files, TypeScript will type check the code you specifically refer to in your app’s source code.</p> <p>A common case where you might think to use <code>skipLibCheck</code> is when there are two copies of a library’s types in your <code>node_modules</code>. In these cases, you should consider using a feature like <a href=\"https://yarnpkg.com/lang/en/docs/selective-version-resolutions/\">yarn’s resolutions</a> to ensure there is only one copy of that dependency in your tree or investigate how to ensure there is only one copy by understanding the dependency resolution to fix the issue without additional tooling.</p> <p>Another possibility is when you are migrating between TypeScript releases and the changes cause breakages in node_modules and the JS standard libraries which you do not want to deal with during the TypeScript update.</p> <p>Note, that if these issues come from the TypeScript standard library you can replace the library using <a href=\"https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-5.html#supporting-lib-from-node_modules\">TypeScript 4.5’s lib replacement</a> technique.</p> </div> <ul>\n<li>\n<span>Recommended</span> </li> <li>\n<span>Released:</span><p><a aria-label=\"Release notes for TypeScript 2.0\" href=\"https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-0.html\">2.0</a></p> </li>\n</ul> </div></section> <div class=\"category\"> <h2 id=\"Command_line_Options_6171\">Command Line</h2> </div> <div class=\"category\"> <h2 id=\"Watch_and_Build_Modes_6250\">Watch Options</h2> <p>TypeScript 3.8 shipped a new strategy for watching directories, which is crucial for efficiently picking up changes to <code>node_modules</code>.</p> <p>On operating systems like Linux, TypeScript installs directory watchers (as opposed to file watchers) on <code>node_modules</code> and many of its subdirectories to detect changes in dependencies. This is because the number of available file watchers is often eclipsed by the number of files in <code>node_modules</code>, whereas there are way fewer directories to track.</p> <p>Because every project might work better under different strategies, and this new approach might not work well for your workflows, TypeScript 3.8 introduces a new <code>watchOptions</code> field which allows users to tell the compiler/language service which watching strategies should be used to keep track of files and directories.</p> </div> <section> <h3 id=\"assumeChangesOnlyAffectDirectDependencies-config\"> Assume Changes Only Affect Direct Dependencies - <code>assumeChangesOnlyAffectDirectDependencies</code>\n</h3> <div> <div> <p>When this option is enabled, TypeScript will avoid rechecking/rebuilding all truly possibly-affected files, and only recheck/rebuild files that have changed as well as files that directly import them.</p> <p>This can be considered a ‘fast &amp; loose’ implementation of the watching algorithm, which can drastically reduce incremental rebuild times at the expense of having to run the full build occasionally to get all compiler error messages.</p> </div> <ul><li>\n<span>Released:</span><p><a aria-label=\"Release notes for TypeScript 3.8\" href=\"https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-8.html\">3.8</a></p> </li></ul> </div></section> </div> </article></div> <div><article id=\"watchOptions\"> <h2 id=\"watch-options\" style=\"position:relative;\">Watch Options</h2> <p>You can configure the how TypeScript <code>--watch</code> works. This section is mainly for handling case where <code>fs.watch</code> and <code>fs.watchFile</code> have additional constraints like on Linux. You can read more at <a href=\"https://www.typescriptlang.org/docs/handbook/configuring-watch.html\">Configuring Watch</a>.</p> <div> <section> <h3 id=\"watch-watchFile-config\"> Watch File - <code>watchFile</code>\n</h3> <div> <div> <p>The strategy for how individual files are watched.</p> <ul> <li>\n<code>fixedPollingInterval</code>: Check every file for changes several times a second at a fixed interval.</li> <li>\n<code>priorityPollingInterval</code>: Check every file for changes several times a second, but use heuristics to check certain types of files less frequently than others.</li> <li>\n<code>dynamicPriorityPolling</code>: Use a dynamic queue where less-frequently modified files will be checked less often.</li> <li>\n<code>useFsEvents</code> (the default): Attempt to use the operating system/file system’s native events for file changes.</li> <li>\n<code>useFsEventsOnParentDirectory</code>: Attempt to use the operating system/file system’s native events to listen for changes on a file’s parent directory</li> </ul> </div> <ul>\n<li>\n<span>Allowed:</span><ul>\n<li>\n<p><code>fixedpollinginterval</code></p> </li>\n<li>\n<p><code>prioritypollinginterval</code></p> </li>\n<li>\n<p><code>dynamicprioritypolling</code></p> </li>\n<li>\n<p><code>fixedchunksizepolling</code></p> </li>\n<li>\n<p><code>usefsevents</code></p> </li>\n<li>\n<p><code>usefseventsonparentdirectory</code></p> </li>\n</ul>\n</li> <li>\n<span>Released:</span><p><a aria-label=\"Release notes for TypeScript 3.8\" href=\"https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-8.html\">3.8</a></p> </li>\n</ul> </div></section> <section> <h3 id=\"watch-watchDirectory-config\"> Watch Directory - <code>watchDirectory</code>\n</h3> <div> <div> <p>The strategy for how entire directory trees are watched under systems that lack recursive file-watching functionality.</p> <ul> <li>\n<code>fixedPollingInterval</code>: Check every directory for changes several times a second at a fixed interval.</li> <li>\n<code>dynamicPriorityPolling</code>: Use a dynamic queue where less-frequently modified directories will be checked less often.</li> <li>\n<code>useFsEvents</code> (the default): Attempt to use the operating system/file system’s native events for directory changes.</li> </ul> </div> <ul>\n<li>\n<span>Allowed:</span><ul>\n<li>\n<p><code>usefsevents</code></p> </li>\n<li>\n<p><code>fixedpollinginterval</code></p> </li>\n<li>\n<p><code>dynamicprioritypolling</code></p> </li>\n<li>\n<p><code>fixedchunksizepolling</code></p> </li>\n</ul>\n</li> <li>\n<span>Released:</span><p><a aria-label=\"Release notes for TypeScript 3.8\" href=\"https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-8.html\">3.8</a></p> </li>\n</ul> </div></section> <section> <h3 id=\"watch-fallbackPolling-config\"> Fallback Polling - <code>fallbackPolling</code>\n</h3> <div> <div> <p>When using file system events, this option specifies the polling strategy that gets used when the system runs out of native file watchers and/or doesn’t support native file watchers.</p> <ul> <li>\n<code>fixedPollingInterval</code>: Check every file for changes several times a second at a fixed interval.</li> <li>\n<code>priorityPollingInterval</code>: Check every file for changes several times a second, but use heuristics to check certain types of files less frequently than others.</li> <li>\n<code>dynamicPriorityPolling</code>: Use a dynamic queue where less-frequently modified files will be checked less often.</li> <li>\n<code>synchronousWatchDirectory</code>: Disable deferred watching on directories. Deferred watching is useful when lots of file changes might occur at once (e.g. a change in <code>node_modules</code> from running <code>npm install</code>), but you might want to disable it with this flag for some less-common setups.</li> </ul> </div> <ul>\n<li>\n<span>Allowed:</span><ul>\n<li>\n<p><code>fixedinterval</code></p> </li>\n<li>\n<p><code>priorityinterval</code></p> </li>\n<li>\n<p><code>dynamicpriority</code></p> </li>\n<li>\n<p><code>fixedchunksize</code></p> </li>\n</ul>\n</li> <li>\n<span>Released:</span><p><a aria-label=\"Release notes for TypeScript 3.8\" href=\"https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-8.html\">3.8</a></p> </li>\n</ul> </div></section> <section> <h3 id=\"watch-synchronousWatchDirectory-config\"> Synchronous Watch Directory - <code>synchronousWatchDirectory</code>\n</h3> <div> <div> <p>Synchronously call callbacks and update the state of directory watchers on platforms that don`t support recursive watching natively. Instead of giving a small timeout to allow for potentially multiple edits to occur on a file.</p> <pre tsconfig=\"true\" data-language=\"typescript\">{\n  \"watchOptions\": {\n    \"synchronousWatchDirectory\": true\n  }\n}</pre> </div>  </div></section> <section> <h3 id=\"watch-excludeDirectories-config\"> Exclude Directories - <code>excludeDirectories</code>\n</h3> <div> <div> <p>You can use <a href=\"#excludeFiles\"><code>excludeFiles</code></a> to drastically reduce the number of files which are watched during <code>--watch</code>. This can be a useful way to reduce the number of open file which TypeScript tracks on Linux.</p> <pre tsconfig=\"true\" data-language=\"typescript\">{\n  \"watchOptions\": {\n    \"excludeDirectories\": [\"**/node_modules\", \"_build\", \"temp/*\"]\n  }\n}</pre> </div>  </div></section> <section> <h3 id=\"watch-excludeFiles-config\"> Exclude Files - <code>excludeFiles</code>\n</h3> <div> <div> <p>You can use <code>excludeFiles</code> to remove a set of specific files from the files which are watched.</p> <pre tsconfig=\"true\" data-language=\"typescript\">{\n  \"watchOptions\": {\n    \"excludeFiles\": [\"temp/file.ts\"]\n  }\n}</pre> </div>  </div></section> </div> </article></div> <div><article id=\"typeAcquisition\"> <h2 id=\"type-acquisition\" style=\"position:relative;\">Type Acquisition</h2> <p>Type Acquisition is only important for JavaScript projects. In TypeScript projects you need to include the types in your projects explicitly. However, for JavaScript projects, the TypeScript tooling will download types for your modules in the background and outside of your node_modules folder.</p> <div> <section> <h3 id=\"type-enable-config\"> Enable - <code>enable</code>\n</h3> <div> <div> <p>Disables automatic type acquisition in JavaScript projects:</p> <pre data-language=\"json\">{\n  \"typeAcquisition\": {\n    \"enable\": false\n  }\n}</pre> </div>  </div></section> <section> <h3 id=\"type-include-config\"> Include - <code>include</code>\n</h3> <div> <div> <p>If you have a JavaScript project where TypeScript needs additional guidance to understand global dependencies, or have disabled the built-in inference via <a href=\"#disableFilenameBasedTypeAcquisition\"><code>disableFilenameBasedTypeAcquisition</code></a>.</p> <p>You can use <code>include</code> to specify which types should be used from DefinitelyTyped:</p> <pre data-language=\"json\">{\n  \"typeAcquisition\": {\n    \"include\": [\"jquery\"]\n  }\n}</pre> </div> </div></section> <section> <h3 id=\"type-exclude-config\"> Exclude - <code>exclude</code>\n</h3> <div> <div> <p>Offers a config for disabling the type-acquisition for a certain module in JavaScript projects. This can be useful for projects which include other libraries in testing infrastructure which aren’t needed in the main application.</p> <pre data-language=\"json\">{\n  \"typeAcquisition\": {\n    \"exclude\": [\"jest\", \"mocha\"]\n  }\n}</pre> </div> </div></section> <section> <h3 id=\"type-disableFilenameBasedTypeAcquisition-config\"> Disable Filename Based Type Acquisition - <code>disableFilenameBasedTypeAcquisition</code>\n</h3> <div> <div> <p>TypeScript’s type acquisition can infer what types should be added based on filenames in a project. This means that having a file like <code>jquery.js</code> in your project would automatically download the types for JQuery from DefinitelyTyped.</p> <p>You can disable this via <code>disableFilenameBasedTypeAcquisition</code>.</p> <pre data-language=\"json\">{\n  \"typeAcquisition\": {\n    \"disableFilenameBasedTypeAcquisition\": true\n  }\n}</pre> </div> <ul><li>\n<span>Released:</span><p><a aria-label=\"Release notes for TypeScript 4.1\" href=\"https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-1.html\">4.1</a></p> </li></ul> </div></section> </div> </article></div>\n</div><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2012-2023 Microsoft<br>Licensed under the Apache License, Version 2.0.<br>\n    <a href=\"https://www.typescriptlang.org/ko/tsconfig\" class=\"_attribution-link\">https://www.typescriptlang.org/ko/tsconfig</a>\n  </p>\n</div>\n","declaration-files/templates/module-class-d-ts":"<h1>Module: Class</h1> <p>예를 들어 다음과 같은 자바스크립트 코드를 다루는 경우를 가정합시다.</p> <pre data-language=\"ts\">const Greeter = require(\"super-greeter\");\n\nconst greeter = new Greeter();\ngreeter.greet();</pre> <p>UMD 또는 일반 모듈을 임포팅하는 두 가지 경우 모두에 대해 대응하려면 다음을 참고합니다.</p> <pre data-language=\"ts\">// Type definitions for [~라이브러리 이름~] [~선택적 버전 숫자~]\n// Project: [~프로젝트 이름~]\n// Definitions by: [~내 이름~] &lt;[~내 URL~]&gt;\n\n/*~ 클래스 모듈을 위한 모듈 템플릿 입니다.\n *~ 이름을 index.d.ts로 변경하고, 모듈 이름의 폴더에 배치해야 합니다.\n *~ 예를 들어, \"super-greeter\" 파일을 작성하는 경우\n *~ 이 파일은 'super-greeter/index.d.ts'가 되어야 합니다.\n */\n\n// ES6 모듈은 직접 클래스 객체를 export할 수 없습니다.\n// 이 파일은 CommonJS-style을 사용해서 import 해야 합니다.\n//   import x = require('[~THE MODULE~]');\n//\n// 또한, --allowSyntheticDefaultImports 나\n// --esModuleInterop 옵션을 활성화한다면,\n// default import로 import할 수 있습니다:\n//   import x from '[~THE MODULE~]';\n//\n// ES6 모듈의 제한에 대한 일반적인 해결 방법을 이해하려면\n// https://www.typescriptlang.org/docs/handbook/modules.html#export--and-import--require\n// 에서 TypeScript 문서를 참고하세요.\n\n/*~ 전역 변수 'myClassLib'을 노출하는 UMD 모듈을\n *~ 모듈 로더 환경 외부에서 로드하려면, 여기에서 전역으로 선언하세요.\n *~ 그렇지 않으면, 이 선언을 제거하세요.\n */\nexport as namespace \"super-greeter\";\n\n/*~ 이 선언은 클래스 생성자 함수를\n *~ 파일에서 export된 객체로 지정합니다.\n */\nexport = Greeter;\n\n/*~ 이 클래스에서 모듈 메서드와 프로퍼티를 지정합니다. */\ndeclare class Greeter {\n  constructor(customGreeting?: string);\n\n  greet: void;\n\n  myMethod(opts: MyClass.MyClassMethodOptions): number;\n}\n\n/*~ 모듈에서 타입을 노출하려면\n *~ 이 블록 안에 위치시키세요.\n *~\n *~ 네임스페이스를 포함할 경우,\n *~ --esModuleInterop 이 설정되어 있지 않으면,\n *~ 모듈을 네임 스페이스 객체로 잘못 import 할 수 있습니다:\n *~   import * as x from '[~THE MODULE~]'; // 오류! 이렇게 하지 마세요!\n */\ndeclare namespace MyClass {\n  export interface MyClassMethodOptions {\n    width?: number;\n    height?: number;\n  }\n}</pre><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2012-2023 Microsoft<br>Licensed under the Apache License, Version 2.0.<br>\n    <a href=\"https://www.typescriptlang.org/ko/docs/handbook/declaration-files/templates/module-class-d-ts.html\" class=\"_attribution-link\">https://www.typescriptlang.org/ko/docs/handbook/declaration-files/templates/module-class-d-ts.html</a>\n  </p>\n</div>\n","asp-net-core":"<h1>ASP.NET Core</h1>\n<h3 id=\"aspnet-코어-및-typescript-설치-install-aspnet-core-and-typescript\" style=\"position:relative;\">ASP.NET 코어 및 TypeScript 설치 (Install ASP.NET Core and TypeScript)</h3> <p>먼저 필요한 경우에는 <a href=\"https://dotnet.microsoft.com/apps/aspnet\">ASP.NET Core</a>를 설치합니다.이 퀵 스타트 가이드를 위해서는 Visual Studio 2015 또는 2017이 필요합니다.</p> <p>다음으로 사용 중인 Visual Studio에 최신 TypeScript가 설치되지 않은 경우 <a href=\"https://www.typescriptlang.org/index.html#download-links\">여기서 설치</a>할 수 있습니다.</p> <h3 id=\"새-프로젝트-만들기-create-a-new-project\" style=\"position:relative;\">새 프로젝트 만들기 (Create a new project)</h3> <ol> <li>\n<strong>File</strong> 선택합니다</li> <li>\n<strong>New Project</strong> 선택합니다 (Ctrl + Shift + N)</li> <li>프로젝트 검색창에서 <strong>.NET Core</strong>를 찾습니다</li> <li>\n<strong>ASP.NET Core Web Application</strong>을 선택하고 <em>Next</em> 버튼을 누릅니다</li> </ol> <p><img src=\"data:image/png;base64,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\" alt=\"Visual Studio Project Window Screenshot\"></p> <ol start=\"5\"> <li>프로젝트명과 솔루션명을 정하고 <em>Create</em> 버튼을 누릅니다</li> </ol> <p><img src=\"data:image/png;base64,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\" alt=\"Visual Studio New Project Window Screenshot\"></p> <ol start=\"6\"> <li>이전 창에서 <strong>Empty</strong> 템플릿 선택 후 <em>Create</em> 버튼을 누릅니다</li> </ol> <p><img src=\"data:image/png;base64,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\" alt=\"Visual Studio Web Application Screenshot\"></p> <p>애플리케이션이 실행되는지 확인합니다</p> <p><img src=\"data:image/png;base64,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\" alt='A screenshot of Edge showing \"Hello World\" as success'></p> <h3 id=\"서버-설정-set-up-the-server\" style=\"position:relative;\">서버 설정 (Set up the server)</h3> <p>다음과 같이 들어가 <strong>Dependencies &gt; Manage NuGet Packages &gt; Browse.</strong> <code>Microsoft.AspNetCore.StaticFiles</code>와 <code>Microsoft.TypeScript.MSBuild</code>를 검색하여 설치합니다:</p> <p><img src=\"https://www.typescriptlang.org/images/tutorials/aspnet/downloaddependency.png\" alt=\"The Visual Studio search for Nuget\"></p> <p><code>Startup.cs</code> 파일을 열고 <code>Configure</code> 함수를 다음과 같이 수정합니다:</p> <pre data-language=\"typescript\">public void Configure(IApplicationBuilder app, IHostingEnvironment env)\n{\n    if (env.IsDevelopment())\n    {\n        app.UseDeveloperExceptionPage();\n    }\n\n    app.UseDefaultFiles();\n    app.UseStaticFiles();\n}</pre> <p><code>UseDefaultFiles</code> 와 <code>UseStaticFiles</code> 밑에 빨간 선이 보인다면 비주얼 스튜디오를 재실행합니다</p> <h2 id=\"타입스크립트-추가-add-typescript\" style=\"position:relative;\">타입스크립트 추가 (Add TypeScript)</h2> <p>이제 새로운 폴더를 추가하고 <code>scripts</code>라고 이름을 지정합니다.</p> <p><img src=\"https://www.typescriptlang.org/images/tutorials/aspnet/newfolder.png\" alt='The Path of \"Add\" then \"New Folder\" in Visual Studio from a Web Project'></p> <p><img src=\"data:image/png;base64,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\" alt=\"\"></p> <h3 id=\"타입스크립트-코드-추가-add-typescript-code\" style=\"position:relative;\">타입스크립트 코드 추가 (Add TypeScript code)</h3> <p><code>scripts</code>를 마우스 오른쪽 버튼으로 클릭하고 <strong>New Item</strong>을 클릭합니다. 그런 다음 <strong>TypeScript File</strong> 을 선택하고 <code>app.ts</code>의 이름을 지정합니다.</p> <p><img src=\"https://www.typescriptlang.org/images/tutorials/aspnet/tsfile.png\" alt=\"A highlight of the new folder\"></p> <h3 id=\"예제-코드-추가-add-example-code\" style=\"position:relative;\">예제 코드 추가 (Add example code)</h3> <p>app.ts에 다음 코드를 입력하십시오</p> <pre data-language=\"ts\">function sayHello() {\n  const compiler = (document.getElementById(\"compiler\") as HTMLInputElement)\n    .value;\n  const framework = (document.getElementById(\"framework\") as HTMLInputElement)\n    .value;\n  return `Hello from ${compiler} and ${framework}!`;\n}</pre> <h3 id=\"빌드-설정-set-up-the-build\" style=\"position:relative;\">빌드 설정 (Set up the build)</h3> <p><em>TypeScript 컴파일러 설정</em></p> <p>먼저 TypeScript에 빌드 방법을 알려줘야 합니다. <code>scripts</code> 폴더를 마우스 오른쪽 버튼으로 클릭하고 <strong>New Item</strong>을 클릭합니다. 그런 다음 <strong>TypeScript ConfigurationFile</strong>을 선택하고 기본 이름인 <code>tsconfig.json</code>을 사용합니다.</p> <p><img src=\"https://www.typescriptlang.org/images/tutorials/aspnet/tsconfig.png\" alt=\"A screenshot showing the new file diaglogue with TypeScript JSON Config selected\"></p> <p>기본 <code>tsconfig.json</code>를 다음으로 대체합니다:</p> <pre tsconfig=\"true\" data-language=\"typescript\">{\n  \"compilerOptions\": {\n    \"noEmitOnError\": true,\n    \"noImplicitAny\": true,\n    \"sourceMap\": true,\n    \"target\": \"es6\"\n  },\n  \"files\": [\"./app.ts\"],\n  \"compileOnSave\": true\n}</pre> <ul> <li>\n<code>noEmitOnError</code> : 오류 발생 시 아웃풋을 내보내지 않습니다.</li> <li>\n<code>noImplicitAny</code> : 표현과 선언에 암묵적으로 <code>any</code> 타입을 사용한 경우 오류가 발생합니다.</li> <li>\n<code>sourceMap</code> : <code>.map</code> 파일 생성합니다.</li> <li>\n<code>target</code> : ECMAScript 타겟 버전을 명시합니다.</li> </ul> <p>Note: <code>\"ESNext\"</code> 는 최신 버전을 지원합니다.</p> <p><code>\"noImplicitAny\"</code> 는 새로 코드를 짤 때마다 쓰면 좋습니다. 실수로 타입을 지정하지 않은 경우를 방지할 수 있습니다. <code>\"compileOnSave\"</code> 는 웹 앱 실행 중에 코드를 쉽게 변경할 수 있도록 합니다.</p> <h3 id=\"npm-설정\" style=\"position:relative;\"><em>NPM 설정</em></h3> <p>이제 JavaScript 패키지를 다운로드할 수 있도록 NPM을 설정해야 합니다. 프로젝트를 마우스 오른쪽 버튼으로 누르고 <strong>New Item</strong>을 클릭합니다. 그런 다음 <strong>NPM Configuration File</strong>을 선택하고 기본 이름 <code>package.json</code>을 사용합니다.</p> <p><img src=\"https://www.typescriptlang.org/images/tutorials/aspnet/packagejson.png\" alt=\"Screenshot of VS showing new file dialog with 'npm configuration file' selected\"></p> <p><code>package.json</code> 파일의 <code>\"devDependencies\"</code>에 <em>gulp</em> 와 <em>del</em>을 추가합니다</p> <pre tsconfig=\"true\" data-language=\"typescript\">\"devDependencies\": {\n    \"gulp\": \"4.0.2\",\n    \"del\": \"5.1.0\"\n}</pre> <p>Visual Studio는 파일을 저장하는 즉시 gulp 및 del 설치를 시작해야 합니다. 그렇지 않은 경우 package.json을 마우스 오른쪽 버튼으로 누르고 Restore Packages를 클릭합니다.</p> <p>솔루션 익스플로러에 <code>npm</code> 폴더가 생긴 것을 확인할 수 있습니다.</p> <p><img src=\"https://www.typescriptlang.org/images/tutorials/aspnet/npm.png\" alt=\"Screenshot of VS showing npm folder\"></p> <h3 id=\"gulp-설정\" style=\"position:relative;\"><em>gulp 설정</em></h3> <p>프로젝트를 마우스 오른쪽 클릭을 하고 <strong>New Item</strong> 클릭합니다. <strong>JavaScript File</strong>를 선택한 다음 <code>gulpfile.js</code>라는 이름을 사용합니다.</p> <pre data-language=\"js\">/// &lt;binding AfterBuild='default' Clean='clean' /&gt;\n/*\n이 파일은 Gulp의 작업을 정의하고 플러그인을 사용하기 위한 entry point입니다.\n자세한 내용을 보려면 여기를 클릭하십시오. http://go.microsoft.com/fwlink/?LinkId=518007\n*/\n\nvar gulp = require(\"gulp\");\nvar del = require(\"del\");\n\nvar paths = {\n  scripts: [\"scripts/**/*.js\", \"scripts/**/*.ts\", \"scripts/**/*.map\"],\n};\n\ngulp.task(\"clean\", function () {\n  return del([\"wwwroot/scripts/**/*\"]);\n});\n\ngulp.task(\"default\", function () {\n  gulp.src(paths.scripts).pipe(gulp.dest(\"wwwroot/scripts\"));\n});</pre> <p>첫 번째 줄은 Visual Studio에게 빌드가 끝난 후에 작업을 ‘default’로 실행하도록 지시합니다. Visual Studio에 빌드를 정리하도록 요청하면 ‘clean’작업도 실행됩니다.</p> <p>이제 <code>gulpfile.js</code>를 마우스 오른쪽 버튼으로 클릭하고 Task Runner Explorer를 클릭합니다.</p> <p><img src=\"data:image/png;base64,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\" alt=\"Screenshot of right clicking on the &quot;Gulpfile.js&quot; with 'Task Runner Exploere' selected\"></p> <p>‘default’ 및 ‘clean’작업이 표시되지 않으면 탐색기를 새로고침 합니다 :</p> <p><img src=\"data:image/png;base64,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\" alt='Screenshot of task explorer with \"Gulpfile.js\" in it'></p> <h3 id=\"html-페이지-작성-write-an-html-page\" style=\"position:relative;\">HTML 페이지 작성 (Write an HTML page)</h3> <p><code>wwwroot</code> 폴더를 마우스 오른쪽 클릭하고 (만약 폴더가 보이지 않는다면 프로젝트를 빌드합니다) 새로운 파일을 추가하고 <code>index.html</code>로 이름을 지정합니다. <code>index.html </code>에 다음 코드를 추가합니다</p> <pre data-language=\"typescript\">&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n&lt;head&gt;\n    &lt;meta charset=\"utf-8\" /&gt;\n    &lt;script src=\"scripts/app.js\"&gt;&lt;/script&gt;\n    &lt;title&gt;&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n    &lt;div id=\"message\"&gt;&lt;/div&gt;\n    &lt;div&gt;\n        Compiler: &lt;input id=\"compiler\" value=\"TypeScript\" onkeyup=\"document.getElementById('message').innerText = sayHello()\" /&gt;&lt;br /&gt;\n        Framework: &lt;input id=\"framework\" value=\"ASP.NET\" onkeyup=\"document.getElementById('message').innerText = sayHello()\" /&gt;\n    &lt;/div&gt;\n&lt;/body&gt;\n&lt;/html&gt;</pre> <h3 id=\"테스트-test\" style=\"position:relative;\">테스트 (Test)</h3> <ol> <li>프로젝트를 실행하십시오.</li> <li>입력 상자에 입력할 때 메시지가 표시됩니다 :</li> </ol> <p><img src=\"data:image/gif;base64,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\" alt=\"A GIF of Edge showing the code you have just wrote\"></p> <h3 id=\"디버그-debug\" style=\"position:relative;\">디버그 (Debug)</h3> <ol> <li>Edge에서 F12 키를 누르고 Debugger 탭을 클릭하십시오.</li> <li>첫 번째 localhost 폴더를 찾은 다음 scripts/app.ts를 찾습니다.</li> <li>return 라인이 있는 라인에 breakpoint를 설정합니다</li> <li>Type 상자에 내용을 입력하고 breakpoint가 TypeScript 코드에 들어가고 검사가 올바르게 작동하는지 확인합니다.</li> </ol> <p><img src=\"https://www.typescriptlang.org/images/tutorials/aspnet/debugger.png\" alt=\"An image showing the debugger running the code you have just wrote\"></p> <p>TypeScript를 사용한 당신의 첫 .NET 코어 프로젝트 생성을 축하합니다.</p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2012-2023 Microsoft<br>Licensed under the Apache License, Version 2.0.<br>\n    <a href=\"https://www.typescriptlang.org/ko/docs/handbook/asp-net-core.html\" class=\"_attribution-link\">https://www.typescriptlang.org/ko/docs/handbook/asp-net-core.html</a>\n  </p>\n</div>\n"}