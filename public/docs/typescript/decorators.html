<h1>Decorators</h1>
<h2 id="소개-introduction" style="position:relative;">소개 (Introduction)</h2> <blockquote class="bg-reading"> <p>Further Reading:<br><a href="https://saul-mirone.github.io/a-complete-guide-to-typescript-decorator/">A Complete Guide to TypeScript Decorators</a></p> </blockquote> <p>TypeScript 및 ES6에 클래스가 도입됨에 따라, 클래스 및 클래스 멤버에 어노테이션을 달거나 수정하기 위해 추가 기능이 필요한 특정 시나리오가 있습니다. 데코레이터는 클래스 선언과 멤버에 어노테이션과 메타-프로그래밍 구문을 추가할 수 있는 방법을 제공합니다. 데코레이터는 JavaScript에 대한 <a href="https://github.com/tc39/proposal-decorators">2단계 제안</a>이며 TypeScript의 실험적 기능으로 이용 가능합니다.</p> <blockquote> <p>참고 데코레이터는 향후 릴리스에서 변경될 수 있는 실험적인 기능입니다.</p> </blockquote> <p>데코레이터에 대한 실험적 지원을 활성화하려면 명령줄 또는 <code>tsconfig.json</code>에서 <code>experimentDecorators</code> 컴파일러 옵션을 활성화해야합니다:</p> <p><strong>명령줄 (Command Line)</strong>:</p> <pre data-language="shell">tsc --target ES5 --experimentalDecorators</pre> <p><strong>tsconfig.json</strong>:</p> <pre tsconfig="true" data-language="typescript">{
  "compilerOptions": {
    "target": "ES5",
    "experimentalDecorators": true
  }
}</pre> <h1 id="데코레이터-decorators" style="position:relative;">데코레이터 (Decorators)</h1> <p><em>데코레이터</em>는 <a href="#%ED%81%B4%EB%9E%98%EC%8A%A4-%EB%8D%B0%EC%BD%94%EB%A0%88%EC%9D%B4%ED%84%B0-class-decorators">클래스 선언</a>, <a href="#%EB%A9%94%EC%84%9C%EB%93%9C-%EB%8D%B0%EC%BD%94%EB%A0%88%EC%9D%B4%ED%84%B0-method-decorators">메서드</a>, <a href="#%EC%A0%91%EA%B7%BC%EC%9E%90-%EB%8D%B0%EC%BD%94%EB%A0%88%EC%9D%B4%ED%84%B0-accessor-decorators">접근자</a>, <a href="#%ED%94%84%EB%A1%9C%ED%8D%BC%ED%8B%B0-%EB%8D%B0%EC%BD%94%EB%A0%88%EC%9D%B4%ED%84%B0-property-decorators">프로퍼티</a> 또는 <a href="#%EB%A7%A4%EA%B0%9C%EB%B3%80%EC%88%98-%EB%8D%B0%EC%BD%94%EB%A0%88%EC%9D%B4%ED%84%B0-parameter-decorators">매개 변수</a>에 첨부할 수 있는 특수한 종류의 선언입니다. 데코레이터는 <code>@expression</code> 형식을 사용합니다. 여기서 <code>expression</code>은 데코레이팅 된 선언에 대한 정보와 함께 런타임에 호출되는 함수여야 합니다.</p> <p>예를 들어, 데코레이터 <code>@sealed</code>를 사용하면 다음과 같이 <code>sealed</code> 함수를 작성할 수 있습니다.</p> <pre data-language="ts">function sealed(target) {
    // 'target' 변수와 함께 무언가를 수행합니다.
}</pre> <h2 id="데코레이터-팩토리-decorator-factories" style="position:relative;">데코레이터 팩토리 (Decorator Factories)</h2> <p>데코레이터가 선언에 적용되는 방식을 원하는 대로 바꾸고 싶다면 데코레이터 팩토리를 작성할 수 있습니다. <em>데코레이터 팩토리</em>는 단순히 데코레이터가 런타임에 호출할 표현식을 반환하는 함수입니다.</p> <p>다음과 같은 방식으로 데코레이터 팩토리를 작성할 수 있습니다.</p> <pre data-language="ts">function color(value: string) { // 데코레이터 팩토리
    return function (target) { // 데코레이터
        // 'target'과 'value' 변수를 가지고 무언가를 수행합니다.
  };
}</pre> <h2 id="데코레이터-합성-decorator-composition" style="position:relative;">데코레이터 합성 (Decorator Composition)</h2> <p>다음 예제와 같이 선언에 여러 데코레이터를 적용할 수 있습니다.</p> <ul> <li>단일 행일 경우:</li> </ul> <pre data-language="ts">@f @g x</pre> <ul> <li>여러 행일 경우:</li> </ul> <pre data-language="ts">@f
@g
x</pre> <p>여러 데코레이터가 단일 선언에 적용되는 경우는 <a href="http://en.wikipedia.org/wiki/Function_composition">수학의 합성 함수</a>와 유사합니다. 이 모델에서 함수 <em>f</em>와 <em>g</em>을 합성할 때 (<em>f</em>∘<em>g</em>)(<em>x</em>)의 합성 결과는 <em>f</em>(<em>g</em>(<em>x</em>))와 같습니다.</p> <p>따라서 TypeScript에서 단일 선언에서 여러 데코레이터를 사용할 때 다음 단계가 수행됩니다.</p> <ol> <li>각 데코레이터의 표현은 위에서 아래로 평가됩니다.</li> <li>그런 다음 결과는 아래에서 위로 함수로 호출됩니다.</li> </ol> <p><a href="#%EB%8D%B0%EC%BD%94%EB%A0%88%EC%9D%B4%ED%84%B0-%ED%8C%A9%ED%86%A0%EB%A6%AC-decorator-factories">데코레이터 팩토리</a>를 사용하는 경우 다음 예제를 통해 이 수행 순서를 관찰 할 수 있습니다.</p>  <pre data-language="ts">function first() {
  console.log("first(): factory evaluated");
  return function (target: any, propertyKey: string, descriptor: PropertyDescriptor) {
    console.log("first(): called");
  };
}
 
function second() {
  console.log("second(): factory evaluated");
  return function (target: any, propertyKey: string, descriptor: PropertyDescriptor) {
    console.log("second(): called");
  };
}
 
class ExampleClass {
  @first()
  @second()
  method() {}
}</pre> <p>이는 결과를 콘솔에 출력합니다.</p> <pre data-language="shell">first(): factory evaluated
second(): factory evaluated
second(): called
first(): called</pre> <h2 id="데코레이터-평가-decorator-evaluation" style="position:relative;">데코레이터 평가 (Decorator Evaluation)</h2> <p>클래스에서 다양한 선언에 데코레이터를 적용하는 방법은 다음과 같이 잘 정의되어 있습니다.</p> <ol> <li>
<em>메서드</em>, <em>접근자</em> 또는 <em>프로퍼티 데코레이터</em>가 다음에 오는 <em>매개 변수 데코레이터</em>는 각 인스턴스 멤버에 적용됩니다.</li> <li>
<em>메서드</em>, <em>접근자</em> 또는 <em>프로퍼티 데코레이터</em>가 다음에 오는 <em>매개 변수 데코레이터</em>는 각 정적 멤버에 적용됩니다.</li> <li>
<em>매개 변수 데코레이터</em>는 생성자에 적용됩니다.</li> <li>
<em>클래스 데코레이터</em>는 클래스에 적용됩니다.</li> </ol> <h2 id="클래스-데코레이터-class-decorators" style="position:relative;">클래스 데코레이터 (Class Decorators)</h2> <p><strong>클래스 데코레이터</strong>는 클래스 선언 직전에 선언됩니다. 클래스 데코레이터는 클래스 생성자에 적용되며 클래스 정의를 관찰, 수정 또는 교체하는 데 사용할 수 있습니다. 클래스 데코레이터는 선언 파일이나 다른 주변 컨텍스트 (예: <code>선언</code> 클래스)에서 사용할 수 없습니다.</p> <p>클래스 데코레이터의 표현식은 데코레이팅된 클래스의 생성자를 유일한 인수로 런타임에 함수로 호출됩니다.</p> <p>클래스 데코레이터가 값을 반환하면 클래스가 선언을 제공하는 생성자 함수로 바꿉니다.</p> <blockquote> <p>참고 새 생성자 함수를 반환하도록 선택한 경우 원래 프로토타입을 유지 관리해야 합니다. 런타임에 데코레이터를 적용하는 로직은 이 기능을 <strong>대신해주지 않습니다.</strong></p> </blockquote> <p>다음은 <code>BugReport</code> 클래스에 적용된 클래스 데코레이터 (<code>@sealed</code>)의 예입니다.</p> <pre data-language="ts">@sealed
class BugReport {
  type = "report";
  title: string;
 
  constructor(t: string) {
    this.title = t;
  }
}</pre> <p>다음 함수 선언을 사용하여 <code>@sealed</code> 데코레이터를 정의할 수 있습니다.</p> <pre data-language="ts">function sealed(constructor: Function) {
  Object.seal(constructor);
  Object.seal(constructor.prototype);
}</pre> <p><code>@sealed</code>가 실행되면 생성자와 프로토 타입을 모두 감쌉니다.</p> <p>생성자를 재정의하는 방법에 대한 예제는 다음과 같습니다.</p>  <pre data-language="ts">function reportableClassDecorator&lt;T extends { new (...args: any[]): {} }&gt;(constructor: T) {
  return class extends constructor {
    reportingURL = "http://www...";
  };
}
 
@reportableClassDecorator
class BugReport {
  type = "report";
  title: string;
 
  constructor(t: string) {
    this.title = t;
  }
}
 
const bug = new BugReport("Needs dark mode");
console.log(bug.title); // Prints "Needs dark mode"
console.log(bug.type); // Prints "report"
 
// Note that the decorator *does not* change the TypeScript type
// and so the new property `reportingURL` is not known
// to the type system:
bug.reportingURL;</pre> <h2 id="메서드-데코레이터-method-decorators" style="position:relative;">메서드 데코레이터 (Method Decorators)</h2> <p><em>메서드 데코레이터</em>는 메서드 선언 직전에 선언됩니다. 데코레이터는 메서드의 <em>프로퍼티 설명자(Property Descriptor)</em> 에 적용되며 메서드 정의를 관찰, 수정 또는 대체하는 데 사용할 수 있습니다. 메서드 데코레이터는 선언 파일, 오버로드 또는 기타 주변 컨텍스트(예: <code>선언</code> 클래스)에서 사용할 수 없습니다.</p> <p>메서드 데코레이터의 표현식은 런타임에 다음 세 개의 인수와 함께 함수로 호출됩니다:</p> <ol> <li>정적 멤버에 대한 클래스의 생성자 함수 또는 인스턴스 멤버에 대한 클래스의 프로토타입입니다.</li> <li>멤버의 이름</li> <li>멤버의 <em>프로퍼티 설명자</em>
</li> </ol> <blockquote> <p>참고 스크립트 대상이 ‘ES5’보다 낮은 경우 <em>프로퍼티 설명자</em> 는 ‘undefined’이 됩니다.</p> </blockquote> <p>메서드 데코레이터가 값을 반환하면, 메서드의 <em>프로퍼티 설명자</em> 로 사용됩니다.</p> <blockquote> <p>참고 스크립트 대상이 ‘ES5’보다 낮은 경우 반환 값은 무시됩니다.</p> </blockquote> <p>다음은 <code>Greeter</code> 클래스의 메서드에 적용된 메서드 데코레이터 (<code>@enumerable</code>)의 예입니다:</p>  <pre data-language="ts">class Greeter {
  greeting: string;
  constructor(message: string) {
    this.greeting = message;
  }
 
  @enumerable(false)
  greet() {
    return "Hello, " + this.greeting;
  }
}</pre> <p>다음 함수 선언을 사용하여 <code>@enumerable</code> 데코레이터를 정의할 수 있습니다.</p>  <pre data-language="ts">function enumerable(value: boolean) {
  return function (target: any, propertyKey: string, descriptor: PropertyDescriptor) {
    descriptor.enumerable = value;
  };
}</pre> <p><code>@enumerable(false)</code>데코레이터는 <a href="#%EB%8D%B0%EC%BD%94%EB%A0%88%EC%9D%B4%ED%84%B0-%ED%8C%A9%ED%86%A0%EB%A6%AC-DecoratorFactories">데코레이터 팩토리</a>입니다. <code>@enumerable(false)</code> 데코레이터가 호출되면 프로퍼티 설명자의 <code>enumerable</code> 프로퍼티를 수정합니다.</p> <h2 id="접근자-데코레이터-accessor-decorators" style="position:relative;">접근자 데코레이터 (Accessor Decorators)</h2> <p><em>접근자 데코레이터</em>는 접근자 선언 바로 전에 선언됩니다. 접근자 데코레이터는 접근자의 <em>프로퍼티 설명자</em>에 적용되며 접근자의 정의를 관찰, 수정 또는 교체하는 데 사용할 수 있습니다. 접근자 데코레이터는 선언 파일이나 다른 주변 컨텍스트(예: <code>선언</code> 클래스)에서 사용할 수 없습니다.</p> <blockquote> <p>참고 TypeScript는 단일 멤버에 대해 <code>get</code> 및 <code>set</code> 접근자를 데코레이팅 할 수 없습니다. 대신 멤버의 모든 데코레이터를 문서 순서대로 지정된 첫 번째 접근자에 적용해야 합니다. 왜냐하면, 데코레이터는 각각의 선언이 아닌 <code>get</code>과 <code>set</code> 접근자를 결합한 <em>프로퍼티 설명자</em>에 적용되기 때문입니다.</p> </blockquote> <p>접근자 데코레이터의 표현 식은 런타임에 다음 세 가지 인수와 함께 함수로 호출됩니다:</p> <ol> <li>정적 멤버에 대한 클래스의 생성자 함수 또는 인스턴스 멤버에 대한 클래스의 프로토타입</li> <li>멤버의 이름</li> <li>멤버의 <em>프로퍼티 설명자</em>
</li> </ol> <blockquote> <p>참고 스크립트 대상이 ‘ES5’보다 낮은 경우 <em>프로퍼티 설명자</em>는 <code>undefined</code>가 됩니다.</p> </blockquote> <p>접근자 데코레이터가 값을 반환하면 멤버의 <em>프로퍼티 설명자</em>로 사용됩니다.</p> <blockquote> <p>참고 스크립트 대상이 ‘ES5’보다 낮은 경우 반환 값은 무시됩니다.</p> </blockquote> <p>다음은 <code>Point</code> 클래스의 멤버에 적용되는 접근자 데코레이터 (<code>@configurable</code>)의 예입니다:</p> <pre data-language="ts">class Point {
  private _x: number;
  private _y: number;
  constructor(x: number, y: number) {
    this._x = x;
    this._y = y;
  }
 
  @configurable(false)
  get x() {
    return this._x;
  }
 
  @configurable(false)
  get y() {
    return this._y;
  }
}</pre> <p>다음 함수 선언을 사용하여 <code>@configurable</code> 데코레이터를 정의할 수 있습니다:</p>  <pre data-language="ts">function configurable(value: boolean) {
  return function (target: any, propertyKey: string, descriptor: PropertyDescriptor) {
    descriptor.configurable = value;
  };
}</pre> <h2 id="프로퍼티-데코레이터-property-decorators" style="position:relative;">프로퍼티 데코레이터 (Property Decorators)</h2> <p><em>프로퍼티 데코레이터</em>는 프로퍼티 선언 바로 전에 선언됩니다. 프로퍼티 데코레이터는 선언 파일이나 다른 주변 컨텍스트(예: <code>선언</code> 클래스)에서 사용할 수 없습니다.</p> <p>프로퍼티 데코레이터의 표현 식은 런타임에 다음 두 개의 인수와 함께 함수로 호출됩니다:</p> <ol> <li>정적 멤버에 대한 클래스의 생성자 함수 또는 인스턴스 멤버에 대한 클래스의 프로토타입</li> <li>멤버의 이름</li> </ol> <blockquote> <p>참고 TypeScript에서 <code>프로퍼티 데코레이터</code>가 초기화되는 방식으로 인해 <em>프로퍼티 설명자</em>가 프로퍼티 데코레이터에 대한 인수로 제공되지 않습니다. 현재 프로토타입의 멤버를 정의할 때 인스턴스 프로퍼티를 설명하는 메커니즘이 없고 프로퍼티의 이니셜라이저를 관찰하거나 수정할 수 있는 방법이 없기 때문입니다. 반환 값도 무시됩니다. 따라서 프로퍼티 데코레이터는 특정 이름의 프로퍼티가 클래스에 선언되었음을 관찰하는 데만 사용할 수 있습니다.</p> </blockquote> <p>이 정보를 사용하여 다음 예와 같이 프로퍼티에 대한 메타데이터를 기록할 수 있습니다:</p> <pre data-language="ts">class Greeter {
  @format("Hello, %s")
  greeting: string;

  constructor(message: string) {
    this.greeting = message;
  }

  greet() {
    let formatString = getFormat(this, "greeting");
    return formatString.replace("%s", this.greeting);
  }
}</pre> <p>다음 함수 선언을 사용하여 <code>@format</code> 데코레이터와 <code>getFormat</code> 함수를 정의 할 수 있습니다:</p> <pre data-language="ts">import "reflect-metadata";

const formatMetadataKey = Symbol("format");

function format(formatString: string) {
  return Reflect.metadata(formatMetadataKey, formatString);
}

function getFormat(target: any, propertyKey: string) {
  return Reflect.getMetadata(formatMetadataKey, target, propertyKey);
}</pre> <p><code>@format("Hello, %s")</code> 데코레이터는 <a href="#%EB%8D%B0%EC%BD%94%EB%A0%88%EC%9D%B4%ED%84%B0-%ED%8C%A9%ED%86%A0%EB%A6%AC-Decorator-Factories">데코레이터 팩토리</a>입니다. <code>@format("Hello, %s")</code>가 호출되면 <code>reflect-metadata</code> 라이브러리의 <code>Reflect.metadata</code> 함수를 사용하여 프로퍼티에 대한 메타데이터 항목을 추가합니다. <code>getFormat</code>이 호출되면 형식의 메타데이터 값을 읽습니다.</p> <blockquote> <p>참고 이 예제에는 <code>reflect-metadata</code> 라이브러리가 필요합니다. <code>reflect-metadata</code> 라이브러리에 대한 자세한 내용은 <a href="#%EB%A9%94%ED%83%80%EB%8D%B0%EC%9D%B4%ED%84%B0-metadata">메타데이터</a>를 참조하십시오.</p> </blockquote> <h2 id="매개변수-데코레이터-parameter-decorators" style="position:relative;">매개변수 데코레이터 (Parameter Decorators)</h2> <p><em>매개변수 데코레이터</em>는 매개 변수 선언 직전에 선언됩니다. 매개변수 데코레이터는 클래스 생성자 또는 메서드 선언의 함수에 적용됩니다. 매개변수 데코레이터는 선언 파일, 오버로드 또는 다른 주변 컨텍스트(예: <code>선언</code> 클래스)에서 사용할 수 없습니다.</p> <p>매개 변수 데코레이터의 표현식은 런타임시 다음 세 개의 인수와 함께 함수로 호출됩니다:</p> <ol> <li>정적 멤버에 대한 클래스의 생성자 함수 또는 인스턴스 멤버에 대한 클래스의 프로토타입</li> <li>멤버의 이름</li> <li>함수의 매개 변수 목록에 있는 매개 변수의 서수 색인(ordinal index)</li> </ol> <blockquote> <p>참고 매개변수 데코레이터는 매개변수가 메서드에서 선언되었을 때에만 관찰하는 데에 사용할 수 있습니다.</p> </blockquote> <p>메개변수 데코레이터의 반환 값은 무시됩니다.</p> <p>다음은 <code>BugReport</code> 클래스 멤버의 매개 변수에 적용되는 매개 변수 데코레이터 (<code>@required</code>)의 예입니다:</p>  <pre data-language="ts">class BugReport {
  type = "report";
  title: string;
 
  constructor(t: string) {
    this.title = t;
  }
 
  @validate
  print(@required verbose: boolean) {
    if (verbose) {
      return this.title;
    } else {
      return `type: ${this.type}\ntitle: ${this.title}`;
    }
  }
}</pre> <p>다음 함수 선언을 사용하여 <code>@required</code> 및 <code>@validate</code> 데코레이터를 정의할 수 있습니다.</p>  <pre data-language="ts">import "reflect-metadata";
const requiredMetadataKey = Symbol("required");
 
function required(target: Object, propertyKey: string | symbol, parameterIndex: number) {
  let existingRequiredParameters: number[] = Reflect.getOwnMetadata(requiredMetadataKey, target, propertyKey) || [];
  existingRequiredParameters.push(parameterIndex);
  Reflect.defineMetadata( requiredMetadataKey, existingRequiredParameters, target, propertyKey);
}
 
function validate(target: any, propertyName: string, descriptor: TypedPropertyDescriptor&lt;Function&gt;) {
  let method = descriptor.value!;
 
  descriptor.value = function () {
    let requiredParameters: number[] = Reflect.getOwnMetadata(requiredMetadataKey, target, propertyName);
    if (requiredParameters) {
      for (let parameterIndex of requiredParameters) {
        if (parameterIndex &gt;= arguments.length || arguments[parameterIndex] === undefined) {
          throw new Error("Missing required argument.");
        }
      }
    }
    return method.apply(this, arguments);
  };
}</pre> <p><code>@required</code> 데코레이터는 필요에 따라 매개변수를 표시하는 메타데이터 항목을 추가합니다. 그런 다음 <code>@validate</code> 데코레이터는 원래 메서드를 호출하기 전에 인수 유효성 검증하는 함수로 기존의 <code>greet</code> 메서드를 감쌉니다.</p> <blockquote> <p>참고 이 예제에는 <code>reflect-metadata</code> 라이브러리가 필요합니다. <code>reflect-metadata</code> 라이브러리에 대한 자세한 내용은 [메타데이터] (#메타데이터-metadata)를 참조하십시오.</p> </blockquote> <h2 id="메타데이터-metadata" style="position:relative;">메타데이터 (Metadata)</h2> <p>일부 예제는 <a href="https://github.com/rbuckton/ReflectDecorators">실험적 메타데이터 API</a>에 대한 폴리필(polyfill)을 추가하는 <code>reflect-metadata</code> 라이브러리를 사용합니다. 이 라이브러리는 아직 ECMAScript (JavaScript) 표준의 일부가 아닙니다. 그러나 데코레이터가 공식적으로 ECMAScript 표준의 일부로 채택되면 이러한 확장을 채택하게 될 것입니다.</p> <p>npm을 통해 설치할 수 있습니다.</p> <pre data-language="shell">npm i reflect-metadata --save</pre> <p>TypeScript에는 데코레이터가 있는 선언에 대해 특정 타입의 메타 데이터를 내보내는 실험적인 지원을 포함합니다. 이 실험적인 지원을 가능하게 하려면, 명령행 또는<code>tsconfig.json</code>에서 <code>emitDecoratorMetadata</code> 컴파일러 옵션을 설정해야 합니다.</p> <p><strong>명령줄</strong>:</p> <pre data-language="shell">tsc --target ES5 --experimentalDecorators --emitDecoratorMetadata</pre> <p><strong>tsconfig.json</strong>:</p> <pre tsconfig="true" data-language="typescript">{
  "compilerOptions": {
    "target": "ES5",
    "experimentalDecorators": true,
    "emitDecoratorMetadata": true
  }
}</pre> <p>활성화되면 <code>reflect-metadata</code>라이브러리를 가져오기만 하면 추가 디자인-타임 타입 정보가 런타임에 사용 가능합니다.</p> <p>다음 예제에서 이를 확인할 수 있습니다.</p>  <pre data-language="ts">import "reflect-metadata";
 
class Point {
  constructor(public x: number, public y: number) {}
}
 
class Line {
  private _start: Point;
  private _end: Point;
 
  @validate
  set start(value: Point) {
    this._start = value;
  }
 
  get start() {
    return this._start;
  }
 
  @validate
  set end(value: Point) {
    this._end = value;
  }
 
  get end() {
    return this._end;
  }
}
 
function validate&lt;T&gt;(target: any, propertyKey: string, descriptor: TypedPropertyDescriptor&lt;T&gt;) {
  let set = descriptor.set!;
  
  descriptor.set = function (value: T) {
    let type = Reflect.getMetadata("design:type", target, propertyKey);
 
    if (!(value instanceof type)) {
      throw new TypeError(`Invalid type, got ${typeof value} not ${type.name}.`);
    }
 
    set.call(this, value);
  };
}
 
const line = new Line()
line.start = new Point(0, 0)
 
// @ts-ignore
// line.end = {}
 
// Fails at runtime with:
// &gt; Invalid type, got object not Point
 </pre> <p>TypeScript 컴파일러는 <code>@Reflect.metadata</code> 데코레이터를 사용하여 디자인-타임 타입 정보를 주입합니다. 다음 TypeScript와 동일하다고 생각할 수 있습니다.</p> <pre data-language="ts">class Line {
  private _start: Point;
  private _end: Point;

  @validate
  @Reflect.metadata("design:type", Point)
  set start(value: Point) {
    this._start = value;
  }
  get start() {
    return this._start;
  }

  @validate
  @Reflect.metadata("design:type", Point)
  set end(value: Point) {
    this._end = value;
  }
  get end() {
    return this._end;
  }
}</pre> <blockquote> <p>참고 데코레이터 메타 데이터는 실험적인 기능으로 향후 릴리스에서 주요 변경 사항이 있을 수 있습니다.</p> </blockquote><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2012-2023 Microsoft<br>Licensed under the Apache License, Version 2.0.<br>
    <a href="https://www.typescriptlang.org/ko/docs/handbook/decorators.html" class="_attribution-link">https://www.typescriptlang.org/ko/docs/handbook/decorators.html</a>
  </p>
</div>
