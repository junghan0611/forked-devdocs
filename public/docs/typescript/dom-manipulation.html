<h1>DOM Manipulation</h1>
<h1 id="dom-조작-dom-manipulation" style="position:relative;">DOM 조작 (DOM Manipulation)</h1> <h3 id="htmlelement-타입-탐구-an-exploration-into-the-htmlelement-type" style="position:relative;">
<em><code>HTMLElement</code> 타입 탐구</em> (<em>An exploration into the <code>HTMLElement</code> type</em>)</h3> <p>표준화 이후 20여 년 동안, JavaScript는 많은 발전을 이루었습니다. 2020년에는 서버, 데이터 사이언스, 그리고 IoT 기기에도 JavaScript를 사용할 수 있지만, 가장 인기 있는 활용 사례는 웹 브라우저인 것을 기억하는 것이 중요합니다.</p> <p>웹 사이트는 HTML 및/또는 XML 문서로 구성됩니다. 이러한 문서들은 정적이어서, 변하지 않습니다. <em>문서 객체 모델(DOM)은</em> 정적 웹 사이트를 기능적으로 작동시키기 위해 브라우저에 의해 구현된 프로그래밍 인터페이스입니다. DOM API를 사용하면 문서의 구조, 스타일, 그리고 내용을 변경할 수 있습니다. API는 매우 강력해서 이를 바탕으로 보다 쉽게 동적인 웹사이트들 개발하기 위해 수많은 프런트엔드 프레임워크(jQuery, React, Angular 등)가 개발되었습니다.</p> <p>TypeScript는 타입이 있는 JavaScript 상위 집합(superset)이며, DOM API에 대한 타입 정의를 제공합니다. 이러한 정의는 모든 기본 TypeScript 프로젝트에서 쉽게 사용 가능합니다. <em>lib.dom.d.ts</em> 에 있는 2만여 줄의 정의 중에서, 가장 눈에 띄는 것은 <code>HTMLElement</code>입니다. 이 타입은 TypeScript를 사용한 DOM 조작의 중축입니다.</p> <blockquote> <p><a href="https://github.com/microsoft/TypeScript/blob/master/lib/lib.dom.d.ts">DOM 타입 정의</a>에 대한 소스코드는 이곳에서 볼 수 있습니다.</p> </blockquote> <h2 id="기본-예제-basic-example" style="position:relative;">기본 예제 (Basic Example)</h2> <p>간단한 예시 파일 <em>index.html</em>:</p> <pre data-language="typescript">&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
  &lt;head&gt;&lt;title&gt;TypeScript Dom Manipulation&lt;/title&gt;&lt;/head&gt;
  &lt;body&gt;
    &lt;div id="app"&gt;&lt;/div&gt;
    &lt;!-- Assume index.js is the compiled output of index.ts --&gt;
    &lt;script src="index.js"&gt;&lt;/script&gt;
  &lt;/body&gt;
&lt;/html&gt;</pre> <p><code>#app</code> 요소에 <code>&lt;p&gt;Hello, World&lt;/p&gt;</code> 요소를 추가하는 TypeScript 스크립트를 살펴보겠습니다.</p> <pre data-language="ts">// 1. id 프로퍼티를 사용하여 div 요소를 선택합니다.
const app = document.getElementById("app");

// 2. 새로운 &lt;p&gt;&lt;/p&gt; 요소를 프로그래밍 방식으로 생성합니다.
const p = document.createElement("p");

// 3. 텍스트 내용을 추가합니다.
p.textContent = "Hello, World!";

// 4. div 요소에 p 요소를 자식 노드로 추가합니다.
app?.appendChild(p);</pre> <p><em>index.html</em> 페이지를 컴파일하고 실행한 후, HTML 결과:</p> <pre data-language="html">&lt;div id="app"&gt;
  &lt;p&gt;Hello, World!&lt;/p&gt;
&lt;/div&gt;</pre> <h2 id="document-인터페이스-the-document-interface" style="position:relative;">
<code>Document</code> 인터페이스 (The <code>Document</code> Interface)</h2> <p>TypeScript 코드의 첫 번째 줄은 전역변수 <code>document</code>를 사용하며, 그 변수를 검사하면 <em>lib.dom.d.ts</em> 파일의 <code>Document</code> 인터페이스에 의해 정의된 것으로 표시됩니다. 그 코드의 스니펫(snippet)에는 <code>getElementById</code>와 <code>createElement</code>라는 두 가지 메서드 호출이 포함되어 있습니다.</p> <h3 id="documentgetelementbyid" style="position:relative;"><code>Document.getElementById</code></h3> <p>이 메서드의 정의는 다음과 같습니다:</p> <pre data-language="ts">getElementById(elementId: string): HTMLElement | null;</pre> <p>문자열 id 요소가 전달되면 <code>HTMLElement</code> 또는 <code>null</code>이 반환됩니다. 이 메서드는 가장 중요한 타입들 중 하나인 <code>HTMLElement</code>를 도입합니다. 이 타입은 다른 모든 요소 인터페이스의 기본 인터페이스 역할을 합니다. 예를 들면, 예제 코드에서 <code>p</code> 변수는 <code>HTMLParagraphElement</code> 타입입니다. 다음으로, 이 메서드는 <code>null</code>을 반환할 수 있다는 점에 유의해야 합니다. 메서드가 실제로 지정된 요소를 찾을 수 있을지 없을지에 따라 확실한 사전 런타임이 될 수 없기 때문입니다. 스니펫 코드의 마지막 줄에는, <code>appendChild</code>를 호출하기 위해 새로운 <em>선택적 체이닝(optional chaining)</em> 연산자가 사용되고 있습니다.</p> <h3 id="documentcreateelement" style="position:relative;"><code>Document.createElement</code></h3> <p>이 메서드의 정의는 다음과 같습니다(<em>deprecated</em> 표기된 정의는 생략했습니다):</p> <pre data-language="ts">createElement&lt;K extends keyof HTMLElementTagNameMap&gt;(tagName: K, options?: ElementCreationOptions): HTMLElementTagNameMap[K];
createElement(tagName: string, options?: ElementCreationOptions): HTMLElement;</pre> <p>이는 오버 로드된 함수 정의입니다. 두 번째 오버로드는 가장 단순하며 <code>getElementById</code> 메서드와 매우 유사하게 작동합니다. 어떤 <code>문자열</code>이 전달되면 HTMLElement 표준이 반환됩니다. 이 정의는 개발자가 고유한 HTML 요소 태그를 생성할 수 있게 합니다.</p> <p>예를 들면 <code>document.createElement('xyz')</code>는 HTML 규격에 지정된 요소가 아닌 <code>&lt;xyz&gt;&lt;/xyz&gt;</code> 요소를 반환합니다.</p> <blockquote> <p>관심 있는 사람들을 위해 언급하자면, <code>document.getElementsByTagName</code>를 사용해 사용자 정의 태그(custom tag) 요소와 상호작용할 수 있습니다.</p> </blockquote> <p><code>createElement</code>의 첫 번째 정의에는, 고급 제네릭 패턴들을 사용하고 있습니다. 이는 내용을 나누어 이해하는 것이 가장 좋습니다. 먼저 <code>&lt;K extends keyof HTMLElementTagNameMap&gt;</code>라는 제네릭 표현부터 시작합니다. 이 표현식은 <code>HTMLElementTagNameMap</code> 인터페이스의 키에 제약을 받는 제네릭 매개변수 <code>K</code>를 정의하고 있습니다. 그 맵 인터페이스는 모든 지정된 HTML 태그 이름과 해당 타입 인터페이스를 포함하고 있습니다. 예를 들면 여기 코드 초반에 5개의 매핑된 값이 있습니다:</p> <pre data-language="ts">interface HTMLElementTagNameMap {
    "a": HTMLAnchorElement;
    "abbr": HTMLElement;
    "address": HTMLElement;
    "applet": HTMLAppletElement;
    "area": HTMLAreaElement;
        ...
}</pre> <p>일부 요소들은 고유한 프로퍼티를 나타내지 않아 <code>HTMLElement</code>를 반환하기도 하지만, 그 외 타입 요소들은 고유한 프로퍼티와 메서드를 가지고 특정 인터페이스(<code>HTMLElement</code>에서 확장되거나 구현됨)를 반환합니다.</p> <p>이제, <code>createElement</code> 정의의 나머지 부분인 <code>(tagName: K, options?: ElementCreationOptions): HTMLElementTagNameMap[K]</code>를 살펴보겠습니다. 첫 번째 인수 <code>tagName</code>은 제네릭 매개변수 <code>K</code>로 정의됩니다. TypeScript 인터프리터는 이 인수로부터 제네릭 매개변수를 <em>추론</em> 할 수 있는 충분한 성능을 가지고 있습니다. 이는 개발자가 메서드를 사용할 때 실제로 제네릭 매개변수를 지정할 필요가 없음을 의미하며, 어떤 값이 <code>tagName</code>인수로 전달되든 간에 <code>K</code>로 추론되므로 정의의 나머지 부분에 사용할 수 있을 것입니다. 정확히 무슨 일이 일어나는지를 보면 반환값 <code>HTMLElementTagNameMap[K]</code>는 <code>tagName</code>인수를 가지고 해당 타입을 반환합니다. 이 정의는 스니펫 코드 <code>p</code> 변수에서 <code>HTMLParagraphElement</code>타입을 얻는 방법입니다. 그리고 코드가 <code>document.createElement('a')</code>였다면, <code>HTMLAnchorElement</code>타입의 요소가 됩니다.</p> <h2 id="node-인터페이스-the-node-interface" style="position:relative;">
<code>Node</code> 인터페이스 (The <code>Node</code> interface)</h2> <p><code>document.getElementById</code> 함수는 <code>HTMLElement</code>를 반환합니다. <code>HTMLElement</code> 인터페이스는 <code>Node</code> 인터페이스를 확장한 <code>Element</code> 인터페이스를 확장합니다. 이러한 프로토타입 확장은 모든 <code>HTMLElements</code>가 표준 메서드의 하위 집합을 활용할 수 있도록 합니다. 코드 스니펫에서는 <code>Node</code> 인터페이스에 정의된 속성을 사용하여 웹 사이트에 새 <code>p</code> 요소를 추가합니다.</p> <h3 id="nodeappendchild" style="position:relative;"><code>Node.appendChild</code></h3> <p>코드 스니펫의 마지막 줄은 <code>app?.appendChild(p)</code>입니다. 이전 섹션(<code>document.getElementById</code>)에서는 <code>app</code>이 런타임에 null일 가능성이 있기 때문에 <em>선택적 체이닝(optional chaining)</em> 연산자가 여기에 사용된다고 설명했습니다. <code>appendChild</code>의 메서드는 다음과 같습니다:</p> <pre data-language="ts">appendChild&lt;T extends Node&gt;(newChild: T): T;</pre> <p>제네릭 매개변수 <code>T</code>가 <code>newChild</code> 인수로부터 나온 것이기 때문에 이 메서드는 <code>createElement</code> 메서드와 유사하게 작동합니다. <code>T</code>는 또 다른 기본 인터페이스인 <code>노드</code>로 <em>제한</em>됩니다.</p> <h2 id="children과-childnodes의-차이점-difference-between-children-and-childnodes" style="position:relative;">
<code>children</code>과 <code>childNodes</code>의 차이점 (Difference between <code>children</code> and <code>childNodes</code>)</h2> <p>이전에 이 문서는 <code>HTMLElement</code> 인터페이스가 <code>Node</code>로부터 확장된 <code>Element</code>에서 확장된 개념이라고 설명했습니다. DOM API에는 <em>자식(children)</em> 요소 개념이 있습니다. 예를 들어 HTML에서 <code>p</code> 태그는 <code>div</code> 요소의 자식입니다.</p> <pre data-language="typescript+html">&lt;div&gt;
  &lt;p&gt;Hello, World&lt;/p&gt;
  &lt;p&gt;TypeScript!&lt;/p&gt;
&lt;/div&gt;;

const div = document.getElementByTagName("div")[0];

div.children;
// HTMLCollection(2) [p, p]

div.childNodes;
// NodeList(2) [p, p]</pre> <p><code>div</code> 요소를 찾아낸 후 <code>children</code> 프로퍼티는 <code>HTMLParagraphElements</code>를 포함하는 <code>HTMLCollection</code> 리스트를 반환합니다. <code>childNodes</code> 프로퍼티는 위와 유사하게 노드 리스트인 <code>NodeList</code>를 반환합니다. 각 <code>p</code> 태그는 여전히 <code>HTMLParagraphElements</code> 타입이지만, <code>NodeList</code>는 추가적으로 <code>HTMLCollection</code> 리스트에는 없는 <em>HTML 노드</em> 를 포함할 수 있습니다.</p> <p><code>p</code> 태그 중 하나를 제거하여 html을 수정하되 텍스트는 그대로 유지하십시오.</p> <pre data-language="typescript+html">&lt;div&gt;
  &lt;p&gt;Hello, World&lt;/p&gt;
  TypeScript!
&lt;/div&gt;;

const div = document.getElementByTagName("div")[0];

div.children;
// HTMLCOllection(1) [p]

div.childNodes;
// NodeList(2) [p, text]</pre> <p>어떻게 두 개의 리스트가 변했는지 보겠습니다. <code>children</code>은 현재 <code>&lt;p&gt;Hello, World&lt;/p&gt;</code> 요소만을 포함하고 있고, <code>childNodes</code>는 두 개의 <code>p</code> 노드가 아닌 <code>text</code> 노드를 포함하고 있습니다. <code>NodeList</code>에서 <code>text</code> 부분은 <code>TypeScript!</code> 텍스트를 포함하는 문자 그대로의 <code>Node</code>입니다. <code>children</code> 리스트는 이 <code>Node</code>를 포함하지 않습니다. 왜냐하면 <code>HTMLElement</code>로 간주하지 않기 때문입니다.</p> <h2 id="queryselector와-queryselectorall-메서드-the-queryselector-and-queryselectorall-methods" style="position:relative;">
<code>querySelector</code>와 <code>querySelectorAll</code> 메서드 (The <code>querySelector</code> and <code>querySelectorAll</code> methods)</h2> <p>두 개의 메서드 모두 고유한 제약 조건 집합에 적합한 돔 요소 리스트를 가져오는 데 좋은 도구입니다. 메서드들은 <em>lib.dom.d.ts</em> 에 다음과 같이 정의되어 있습니다:</p> <pre data-language="ts">/**
 * 선택자와 일치하는 노드의 자식 중 첫 번째 요소를 반환합니다.
 */
querySelector&lt;K extends keyof HTMLElementTagNameMap&gt;(selectors: K): HTMLElementTagNameMap[K] | null;
querySelector&lt;K extends keyof SVGElementTagNameMap&gt;(selectors: K): SVGElementTagNameMap[K] | null;
querySelector&lt;E extends Element = Element&gt;(selectors: string): E | null;

/**
 * 선택자와 일치하는 모든 노드 자식 요소를 반환합니다.
 */
querySelectorAll&lt;K extends keyof HTMLElementTagNameMap&gt;(selectors: K): NodeListOf&lt;HTMLElementTagNameMap[K]&gt;;
querySelectorAll&lt;K extends keyof SVGElementTagNameMap&gt;(selectors: K): NodeListOf&lt;SVGElementTagNameMap[K]&gt;;
querySelectorAll&lt;E extends Element = Element&gt;(selectors: string): NodeListOf&lt;E&gt;;</pre> <p><code>querySelectorAll</code> 정의는 <code>NodeListOf</code>라는 새로운 타입을 반환한다는 점을 제외하면 <code>getElementByTagName</code>과 유사합니다. 이 반환 타입은 기본적으로 표준 JavaScript 리스트 요소의 맞춤형으로 구현되었습니다. <code>NodeListOf&lt;E&gt;</code>를 <code>E[]</code>로 바꿔보면 틀림없이 매우 유사한 사용자 경험을 제공할 것입니다. <code>NodeListOf</code>는 <code>length</code> , <code>item(index)</code>, <code>forEach((value, key, parent) =&gt; void)</code> , 그리고 숫자 인덱스 생성과 같은 프로퍼티 및 메서드만을 구현합니다. 또한, 메서드는 <em>노드</em> 가 아닌 <em>요소</em> 리스트를 반환하며 이는 <code>.childNodes</code> 메서드에서 <code>NodeList</code>가 반환한 것입니다. 모순처럼 보일 수 있지만, <code>Element</code> 인터페이스는 <code>Node</code>에서 확장된 점에 유의해야 합니다.</p> <p>두 개의 메서드가 동작하는 것을 보려면 기존 코드를 다음과 같이 수정하십시오:</p> <pre data-language="typescript+html">&lt;ul&gt;
  &lt;li&gt;First :)&lt;/li&gt;
  &lt;li&gt;Second!&lt;/li&gt;
  &lt;li&gt;Third times a charm.&lt;/li&gt;
&lt;/ul&gt;;

const first = document.querySelector("li"); // 첫 번째 li 요소를 반환합니다.
const all = document.querySelectorAll("li"); // 모든 li 요소를 포함하는 리스트를 반환합니다.</pre> <h2 id="더-자세히-알고-싶으십니까-interested-in-learning-more" style="position:relative;">더 자세히 알고 싶으십니까? (Interested in learning more?)</h2> <p><em>lib.dom.d.ts</em> 타입 정의에서 가장 좋은 부분은 Mozilla Developer Network (MDN) 문서 사이트에 표기된 타입들을 반영했다는 것입니다. 예를 들어, <code>HTMLElement</code> 인터페이스는 MDN에서 <a href="https://developer.mozilla.org/docs/Web/API/HTMLElement">HTMLElement 페이지</a>에 문서화 되어 있습니다. 이 페이지에는 사용 가능한 모든 프로퍼티, 메서드, 때로는 예시까지 제공합니다. 해당 페이지가 훌륭한 다른 면은 표준 문서에 맞는 링크를 제공한다는 것입니다. 다음은 <a href="https://www.w3.org/TR/html52/dom.html#htmlelement">HTMLElement의 W3C 권장사항</a>에 대한 링크입니다.</p> <p>소스코드 참조:</p> <ul> <li><a href="http://www.ecma-international.org/ecma-262/10.0/index.html">ECMA-262 Standard</a></li> <li><a href="https://developer.mozilla.org/docs/Web/API/Document_Object_Model/Introduction">Introduction to the DOM</a></li> </ul><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2012-2023 Microsoft<br>Licensed under the Apache License, Version 2.0.<br>
    <a href="https://www.typescriptlang.org/ko/docs/handbook/dom-manipulation.html" class="_attribution-link">https://www.typescriptlang.org/ko/docs/handbook/dom-manipulation.html</a>
  </p>
</div>
