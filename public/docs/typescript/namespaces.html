<h1>Namespaces</h1>
<blockquote> <p><strong>용어에 대한 설명:</strong> TypeScript 1.5 버전부터 용어가 변경되었습니다. “Internal modules” 은 “네임스페이스” 로 변경되었습니다. “External modules” 은 “모듈” 로 변경되었습니다. 이는 <a href="http://www.ecma-international.org/ecma-262/6.0/">ECMAScript 2015</a>의 용어와 통일시키기 위함입니다. (<code>module X {</code> 는 현재 선호되는 <code>namespace X {</code> 와 동일합니다.)</p> </blockquote> <p>이 게시물에서는 TypeScript에서 네임스페이스(구 “internal modules”)를 사용하여 코드를 구성하는 다양한 방법을 간략하게 설명합니다. 위에서 설명했듯이, “internal modules” 은 “네임스페이스” 로 변경되었습니다. 이에 따라, 인터널 모듈을 선언하기 위해 쓰였던 <code>module</code> 키워드는 <code>namespace</code> 키워드로 대체되어야 합니다. 이를 통해 신규 사용자의 혼란을 방지할 수 있습니다.</p> <h1 id="첫-번째-단계-first-steps" style="position:relative;">첫 번째 단계 (First steps)</h1> <p><b><a href="#table-of-contents">↥ 위로</a></b></p> <p>이 페이지 전체에서 예제로 사용할 프로그램을 시작하겠습니다. 웹 페이지의 양식에 대한 사용자 입력을 확인하거나 외부로부터 받은 데이터 파일의 형식을 확인하기 위해 간단한 문자열 검사기 세트를 작성했습니다.</p> <h2 id="단일-파일-검사기-validators-in-a-single-file" style="position:relative;">단일 파일 검사기 (Validators in a single file)</h2> <pre data-language="ts">interface StringValidator {
    isAcceptable(s: string): boolean;
}

let lettersRegexp = /^[A-Za-z]+$/;
let numberRegexp = /^[0-9]+$/;

class LettersOnlyValidator implements StringValidator {
    isAcceptable(s: string) {
        return lettersRegexp.test(s);
    }
}

class ZipCodeValidator implements StringValidator {
    isAcceptable(s: string) {
        return s.length === 5 &amp;&amp; numberRegexp.test(s);
    }
}

// 시도해 볼 샘플
let strings = ["Hello", "98052", "101"];

// 사용할 검사기
let validators: { [s: string]: StringValidator; } = {};
validators["ZIP code"] = new ZipCodeValidator();
validators["Letters only"] = new LettersOnlyValidator();

// 각 문자열이 각 검사기를 통과했는지 표시
for (let s of strings) {
    for (let name in validators) {
        let isMatch = validators[name].isAcceptable(s);
        console.log(`'${ s }' ${ isMatch ? "matches" : "does not match" } '${ name }'.`);
    }
}</pre> <h1 id="네임스페이스-적용하기-namespacing" style="position:relative;">네임스페이스 적용하기 (Namespacing)</h1> <p>더 많은 검사기를 추가하게 되면, 타입을 추적하고 다른 객체와 이름 충돌을 방지하기 위해 일종의 구조 체계가 필요합니다. 전역 네임스페이스에 다른 이름을 많이 넣는 대신, 객체들을 하나의 네임스페이스로 감싸겠습니다.</p> <p>이 예에서는 모든 검사기 관련 개체를 <code>Validation</code>이라는 하나의 네임스페이스로 옮기겠습니다.<br> 여기서 인터페이스 및 클래스가 네임스페이스 외부에서도 접근 가능하도록 선언부에 <code>export</code>를 붙입니다.<br> 반면, 변수 <code>letterRegexp</code>와 <code>numberRegexp</code>는 구현 세부 사항이므로 외부로 내보내지 않아 네임스페이스 외부 코드에서 접근할 수 없습니다. 파일 하단의 테스트 코드에서, 네임스페이스 외부에서 사용될 때 타입의 이름을 검증해야 합니다 (예: <code>Validation.LetterOnlyValidator</code>).</p> <h2 id="네임스페이스화된-검사기-namespaced-validators" style="position:relative;">네임스페이스화된 검사기 (Namespaced Validators)</h2> <pre data-language="ts">namespace Validation {
    export interface StringValidator {
        isAcceptable(s: string): boolean;
    }

    const lettersRegexp = /^[A-Za-z]+$/;
    const numberRegexp = /^[0-9]+$/;

    export class LettersOnlyValidator implements StringValidator {
        isAcceptable(s: string) {
            return lettersRegexp.test(s);
        }
    }

    export class ZipCodeValidator implements StringValidator {
        isAcceptable(s: string) {
            return s.length === 5 &amp;&amp; numberRegexp.test(s);
        }
    }
}

// 시도해 볼 샘플
let strings = ["Hello", "98052", "101"];

// 사용할 검사기
let validators: { [s: string]: Validation.StringValidator; } = {};
validators["ZIP code"] = new Validation.ZipCodeValidator();
validators["Letters only"] = new Validation.LettersOnlyValidator();

// 각 문자열이 각 검사기를 통과했는지 표시
for (let s of strings) {
    for (let name in validators) {
        console.log(`"${ s }" - ${ validators[name].isAcceptable(s) ? "matches" : "does not match" } ${ name }`);
    }
}</pre> <h1 id="파일-간-분할-splitting-across-files" style="position:relative;">파일 간 분할 (Splitting Across Files)</h1> <p><b><a href="#table-of-contents">↥ 위로</a></b></p> <p>애플리케이션 규모가 커지면, 코드를 여러 파일로 분할해야 유지 보수가 용이합니다.</p> <h2 id="다중-파일-네임스페이스-multi-file-namespaces" style="position:relative;">다중 파일 네임스페이스 (Multi-file namespaces)</h2> <p><b><a href="#table-of-contents">↥ 위로</a></b></p> <p>여기서 <code>Validation</code> 네임스페이스를 여러 파일로 분할합니다. 파일이 분리되어 있어도 같은 네임스페이스에 기여할 수 있고 마치 한 곳에서 정의된 것처럼 사용할 수 있습니다. 파일 간 의존성이 존재하므로, 참조 태그를 추가하여 컴파일러에게 파일 간의 관계를 알립니다. 그 외에 테스트 코드는 변경되지 않았습니다.</p> <h5 id="validationts" style="position:relative;">Validation.ts</h5> <pre data-language="ts">namespace Validation{
    export interface StringValidator{
        isAcceptable(s: string): boolean;
    }
}</pre> <h5 id="lettersonlyvalidatorsts" style="position:relative;">LettersOnlyValidators.ts</h5> <pre data-language="ts">/// &lt;reference path="Validation.ts" /&gt;
namespace Validation {
    const lettersRegexp = /^[A-Za-z]+$/;
    export class LettersOnlyValidator implements StringValidator {
        isAcceptable(s: string) {
            return lettersRegexp.test(s);
        }
    }
}</pre> <h5 id="zipcodevalidatorsts" style="position:relative;">ZipCodeValidators.ts</h5> <pre data-language="ts">/// &lt;reference path="Validation.ts" /&gt;
namespace Validation {
    const numberRegexp = /^[0-9]+$/;
    export class ZipCodeValidator implements StringValidator {
        isAcceptable(s: string) {
            return s.length === 5 &amp;&amp; numberRegexp.test(s);
        }
    }
}</pre> <h5 id="testts" style="position:relative;">Test.ts</h5> <pre data-language="ts">/// &lt;reference path="Validation.ts" /&gt;
/// &lt;reference path="LettersOnlyValidator.ts" /&gt;
/// &lt;reference path="ZipCodeValidator.ts" /&gt;

// Some samples to try
let strings = ["Hello", "98052", "101"];

// Validators to use
let validators: { [s: string]: Validation.StringValidator; } = {};
validators["ZIP code"] = new Validation.ZipCodeValidator();
validators["Letters only"] = new Validation.LettersOnlyValidator();

// Show whether each string passed each validator
for (let s of strings) {
    for (let name in validators) {
        console.log(`"${ s }" - ${ validators[name].isAcceptable(s) ? "matches" : "does not match" } ${ name }`);
    }
}</pre> <p>파일이 여러 개 있으면 컴파일된 코드가 모두 로드되는지 확인해야 합니다. 이를 수행하는 두 가지 방법이 있습니다.</p> <p>먼저, 모든 입력 파일을 하나의 JavaScript 출력 파일로 컴파일하기 위해 <code>--outFile</code> 플래그를 사용하여 연결 출력(concatenated output)을 사용할 수 있습니다:</p> <pre data-language="shell">tsc --outFile sample.js Test.ts</pre> <p>컴파일러는 파일에 있는 참조 태그를 기반으로 출력 파일을 자동으로 정렬합니다. 각 파일을 개별적으로 지정할 수도 있습니다:</p> <pre data-language="shell">tsc --outFile sample.js Validation.ts LettersOnlyValidator.ts ZipCodeValidator.ts Test.ts</pre> <p>또는 파일별 컴파일 (기본값)을 사용하여 각 입력 파일을 하나의 JavaScript 파일로 생성할 수 있습니다. 여러 JS 파일이 생성되는 경우, 웹 페이지에서 생성된 개별 파일을 적절한 순서로 로드하기 위해 <code>&lt;script&gt;</code> 태그를 사용해야 합니다. 예를 들어:</p> <h5 id="mytestpagehtml-인용" style="position:relative;">MyTestPage.html (인용)</h5> <pre data-language="html">    &lt;script src="Validation.js" type="text/javascript" /&gt;
    &lt;script src="LettersOnlyValidator.js" type="text/javascript" /&gt;
    &lt;script src="ZipCodeValidator.js" type="text/javascript" /&gt;
    &lt;script src="Test.js" type="text/javascript" /&gt;</pre> <h1 id="별칭-aliases" style="position:relative;">별칭 (Aliases)</h1> <p><b><a href="#table-of-contents">↥ 위로</a></b></p> <p>네임스페이스 작업을 단순화할 수 있는 또 다른 방법은 일반적으로 사용되는 객체의 이름을 더 짧게 만들기 위해 <code>import q = x.y.z</code>를 사용하는 것입니다. 모듈을 로드하는 데 사용되는 <code>import x = require ("name")</code> 구문과 혼동하지 않기 위해, 이 구문은 단순히 특정 심벌에 별칭을 생성합니다. 이러한 종류의 가져오기(일반적으로 별칭이라고 함)는 모듈 가져오기에서 생성된 객체를 포함하여 모든 종류의 식별자에 대해 사용할 수 있습니다.</p> <pre data-language="ts">namespace Shapes {
    export namespace Polygons {
        export class Triangle { }
        export class Square { }
    }
}

import polygons = Shapes.Polygons;
let sq = new polygons.Square(); // 'new Shapes.Polygons.Square()'와 동일</pre> <p><code>require</code> 키워드를 사용하지 않는다는 것을 명심하세요; 대신 가져오는 심벌은 정해진 이름으로 직접 할당합니다. <code>var</code>를 사용하는 것과 비슷하지만, 가져온 심벌의 타입 및 네임스페이스 의미에 대해서도 동작합니다. 특히, 값의 경우 <code>import</code>는 원래 심벌와 별개의 참조이므로 별칭 <code>var</code>에 대한 변경 내용은 원래 변수에 반영되지 않습니다.</p> <h1 id="다른-javascript-라이브러리로-작업하기-working-with-other-javascript-libraries" style="position:relative;">다른 JavaScript 라이브러리로 작업하기 (Working with Other JavaScript Libraries)</h1> <p><b><a href="#table-of-contents">↥ 위로</a></b></p> <p>TypeScript로 작성되지 않은 라이브러리의 형태를 설명하려면, 라이브러리가 외부에 제공하는 API를 선언해야 합니다. 대부분의 JavaScript 라이브러리는 소수의 최상위 객체만 노출하므로 네임스페이스를 사용하는 것이 좋습니다.</p> <p>구현을 정의하지 않은 선언을 “ambient”라고 부릅니다. 일반적으로 이것은 <code>.d.ts</code> 파일에 정의되어 있습니다. C/C++에 익숙하다면 이를 <code>.h</code> 파일로 생각할 수 있습니다. 몇 가지 예를 살펴보겠습니다.</p> <h2 id="ambient-네임스페이스-ambient-namespaces" style="position:relative;">Ambient 네임스페이스 (Ambient Namespaces)</h2> <p><b><a href="#table-of-contents">↥ 위로</a></b></p> <p>널리 사용되는 D3 라이브러리는 <code>d3</code>이라는 전역 객체에서 기능을 정의합니다. 이 라이브러리는 <code>&lt;script&gt;</code> 태그를 통해 로드되므로(모듈 로더 대신) 형태를 정의하기 위해 선언할 때 네임스페이스를 사용합니다. TypeScript 컴파일러는 이 형태를 보기 위해, ambient 네임스페이스 선언을 사용합니다. 예를 들어 다음과 같이 작성할 수 있습니다:</p> <h5 id="d3dts-간단한-인용" style="position:relative;">D3.d.ts (간단한 인용)</h5> <pre data-language="ts">declare namespace D3 {
    export interface Selectors {
        select: {
            (selector: string): Selection;
            (element: EventTarget): Selection;
        };
    }

    export interface Event {
        x: number;
        y: number;
    }

    export interface Base extends Selectors {
        event: Event;
    }
}

declare var d3: D3.Base;</pre><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2012-2023 Microsoft<br>Licensed under the Apache License, Version 2.0.<br>
    <a href="https://www.typescriptlang.org/ko/docs/handbook/namespaces.html" class="_attribution-link">https://www.typescriptlang.org/ko/docs/handbook/namespaces.html</a>
  </p>
</div>
