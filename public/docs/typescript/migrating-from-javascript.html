<h1>Migrating from JavaScript</h1>
<p>TypeScript는 공백 상태가 아닙니다. JavaScript 생태계를 바탕으로 구축되었으며, 오늘날 많은 JavaScript가 존재합니다. JavaScript 코드 베이스를 TypeScript로 변환하는 것은 다소 지루하지만 어렵진 않습니다. 이 튜토리얼에서 어떻게 시작하는지 살펴보겠습니다. TypeScript 코드를 작성하기 위해 핸드북을 충분히 읽었다고 가정하고 설명하겠습니다.</p> <p>React 프로젝트를 변환하고자 한다면, <a href="https://github.com/Microsoft/TypeScript-React-Conversion-Guide#typescript-react-conversion-guide">React 변환 가이드</a>를 먼저 읽어보는 것을 추천합니다.</p> <h1 id="디렉토리-설정하기-setting-up-your-directories" style="position:relative;">디렉토리 설정하기 (Setting up your Directories)</h1> <p>일반 JavaScript로 작성하는 경우, <code>src</code>, <code>lib</code> 또는 <code>dist</code> 디렉터리에 있는 <code>.js</code> 파일이 JavaScript를 직접 실행한 다음, 원하는 대로 실행했을 가능성이 높습니다.</p> <p>이 경우, 작성한 파일은 TypeScript에 입력으로 사용되고, 그로 인한 출력을 실행하게 됩니다. JS에서 TS로의 전환하는 동안, TypeScript가 입력 파일을 겹쳐 쓰는 것을 방지하기 위해 입력 파일을 분리할 필요가 있습니다. 만약 출력 파일이 특정 디렉터리에 위치해야 하는 경우, 그 위치가 출력 디렉터리가 되어야 합니다.</p> <p>또한 JavaScript에서 번들링을 하거나 바벨 같은 트랜스파일러를 사용하는 것처럼, 중간 단계를 실행할 수 있습니다. 이러한 경우, 이렇게 설정된 폴더 구조를 가지고 있을 수 있습니다.</p> <p>이 시점부터, 디렉터리가 다음과 같이 설정되었다고 가정하겠습니다:</p> <pre data-language="text">projectRoot
├── src
│   ├── file1.js
│   └── file2.js
├── built
└── tsconfig.json</pre> <p>만약 <code>src</code> 디렉터리 바깥에 <code>tests</code> 폴더가 존재한다면, <code>src</code>와 <code>tests</code> 내부에 각각 <code>tsconfig.json</code>이 존재할 수 있습니다.</p> <h1 id="설정-파일-작성하기-writing-a-configuration-file" style="position:relative;">설정 파일 작성하기 (Writing a Configuration File)</h1> <p>TypeScript는 어떤 파일을 포함하고, 어떤 종류의 체크가 수행되어야 하는지와 같은 프로젝트 옵션을 관리하기 위해, <code>tsconfig.json</code>이라 불리는 파일을 사용합니다. 프로젝트의 뼈대를 구성해 보겠습니다:</p> <pre data-language="json">{
    "compilerOptions": {
        "outDir": "./built",
        "allowJs": true,
        "target": "es5"
    },
    "include": [
        "./src/**/*"
    ]
}</pre> <p>TypeScript에 대한 몇 가지 사항을 명시하고 있습니다:</p> <ol> <li>
<code>src</code> 디렉터리에서 해석되는 모든 파일을 읽습니다 (<code>include</code> 포함).</li> <li>JavaScript 파일을 입력으로 허용합니다 (<code>allowJs</code> 포함).</li> <li>
<code>built</code> 내부의 모든 출력 파일을 내보냅니다 (<code>outDir</code> 포함).</li> <li>최신 JavaScript 구성을 ECMAScript 5와 같은 이전 버전으로 변환합니다(<code>target</code> 사용).</li> </ol> <p>이 시점에서, 프로젝트의 루트에서 <code>tsc</code>를 작동시키려면, 반드시 <code>built</code> 디렉터리에 있는 출력 파일이 표시되어야 합니다. <code>built</code> 안의 레이아웃 파일은 <code>src</code>의 레이아웃과 동일해야 합니다. 이제 프로젝트가 TypeScript로 작동할 것입니다.</p> <h2 id="초기-혜택-early-benefits" style="position:relative;">초기 혜택 (Early Benefits)</h2> <p>TypeScript가 프로젝트를 이해하는 것으로부터 몇 가지 큰 혜택을 받을 수 있습니다. <a href="https://code.visualstudio.com">VS Code</a> 나 <a href="https://visualstudio.com">Visual Studio</a> 에디터를 열어보면, 자동완성과 같은 툴링 지원을 받는 것을 볼 수 있습니다. 또한 다음 옵션이 들어 있는 특정 버그도 잡을 수 있습니다:</p> <ul> <li>함수의 마지막에 return을 빠뜨리는 것을 방지하는 <code>noImplicitReturns</code>
</li> <li>switch 블록의 <code>case</code> 사이에 <code>break</code>를 빠뜨리는 것을 절대 잊지 않기 위한 <code>noFallthroughCasesInSwitch</code>
</li> </ul> <p>또한 <code>allowUnreachableCode</code> 와 <code>allowUnusedLabels</code> 각각을 사용해, TypeScript는 도달할 수 없는 코드와 라벨에 대한 경고를 할 것입니다.</p> <h1 id="빌드-툴과-통합하기-integrating-with-build-tools" style="position:relative;">빌드 툴과 통합하기 (Integrating with Build Tools)</h1> <p>파이프라인에 더 많은 제작 단계가 있을 수 있습니다. 각각의 파일에 무언가를 연결할 수도 있습니다. 개별 빌드 도구는 다르지만, 빌드 도구의 핵심을 다루기 위해 최선을 다할 것입니다.</p> <h2 id="gulp" style="position:relative;">Gulp</h2> <p>만약 Gulp를 어떤 방식으로 사용하고 있다면, TypeScript와 <a href="gulp.md">Gulp를 사용하는 방법</a>과 Browserify, Babelify, Uglify 같은 일반적인 빌드 툴과 통합하는 방법에 대한 튜토리얼이 있습니다. 그곳에서 더 많은 내용을 볼 수 있습니다.</p> <h2 id="webpack" style="position:relative;">Webpack</h2> <p>Webpack 통합은 꽤 간단합니다. 쉬운 디버깅을 위해 <code>source-map-loader</code>와 결합한 TypeScript 로더, <code>awesome-typescript-loader</code>를 사용할 수 있습니다. 단순히 실행하고</p> <pre data-language="shell">npm install awesome-typescript-loader source-map-loader</pre> <p>다음 옵션에서 <code>webpack.config.js</code> 파일과 병합하세요:</p> <pre data-language="js">module.exports = {
    entry: "./src/index.ts",
    output: {
        filename: "./dist/bundle.js",
    },

    // webpack의 출력을 디버깅하기 위해 소스맵을 활성화 합니다.
    devtool: "source-map",

    resolve: {
        // 해석 가능한 확장자로 '.ts' 와 '.tsx' 를 추가합니다.
        extensions: ["", ".webpack.js", ".web.js", ".ts", ".tsx", ".js"]
    },

    module: {
        loaders: [
            // '.ts' 나 '.tsx' 확장자로 끝나는 모든 파일은 'awesome-typescript-loader'에 의해 처리됩니다.
            { test: /\.tsx?$/, loader: "awesome-typescript-loader" }
        ],

        preLoaders: [
            // 모든 출력 '.js' 파일은 'source-map-loader'에 의해 재처리된 소스맵을 갖습니다.
            { test: /\.js$/, loader: "source-map-loader" }
        ]
    },

    // 다른 옵션들...
};</pre> <p>awesome-typescript-loader는 다른 로더가 <code>.js</code> 파일을 처리하기 전에 실행되어야 한다는 점을 유의하세요.</p> <p>Webpack을 위한 또 다른 TypeScript 로더, <a href="https://github.com/TypeStrong/ts-loader">ts-loader</a>도 같습니다. <a href="https://github.com/s-panferov/awesome-typescript-loader#differences-between-ts-loader">여기</a>에서 둘 사이의 차이점을 읽을 수 있습니다.</p> <p><a href="react-&amp;-webpack.md">React와 Webpack 튜토리얼</a>에서 Webpack 사용에 관한 예제를 볼 수 있습니다.</p> <h1 id="typescript-파일로-이동하기-moving-to-typescript-files" style="position:relative;">TypeScript 파일로 이동하기 (Moving to TypeScript Files)</h1> <p>이제, TypeScript 파일을 사용해 시작할 준비가 되었을 것입니다. 첫 번째 단계는 <code>.js</code> 파일을 <code>.ts</code> 파일로 이름을 바꾸는 것입니다. 파일이 JSX를 사용한다면 이름을 <code>.tsx</code>로 변경하세요.</p> <p>그 단계를 마치셨나요? 좋습니다! JavaScript에서 TypeScript로 파일을 성공적으로 마이그레이션 했습니다!</p> <p>당연히, 그것이 바로 느껴지지는 않을 것입니다. TypeScript를 지원하는 에디터로 파일을 열어보면 (또는 <code>tsc --pretty</code>를 실행하면), 특정 줄에 빨간 구불구불한 선이 나타날 것입니다. Microsoft Word 같은 에디터의 빨간 구불구불한 선처럼 생각하면 됩니다. Word가 문서를 여전히 프린트할 수 있는 것처럼, TypeScript도 여전히 코드를 해석할 수 있습니다.</p> <p>만약 그것이 너무 느슨해 보인다면, 더 엄격하게 행동할 수 있습니다. 예를 들어, 오류 발생 시 JavaScript를 TypeScript로 컴파일 <em>하지 않으려면</em>, <code>noEmitOnError</code> 옵션을 사용할 수 있습니다. 그러한 의미에서, TypeScript는 이상적인 엄격함을 갖고 있고, 원하는 만큼 그 기준을 높일 수 있습니다.</p> <p>최대한 엄격한 세팅을 사용할 계획이라면, 지금 설정하는 것이 좋습니다(<a href="#%EB%8D%94-%EC%97%84%EA%B2%A9%ED%95%9C-%EC%B2%B4%ED%81%AC%ED%95%98%EA%B8%B0-getting-stricter-checks">더 엄격한 체크하기</a> 참조). 예를 들어, TypeScript가 명시적 설명 없이는 타입을 <code>any</code>로 추론하지 않기를 원한다면, 파일을 수정하기 전 <code>noImplicitAny</code>를 사용할 수 있습니다. 다소 부담스럽게 느껴질 수 있지만, 장기적으로 훨씬 이득입니다.</p> <h2 id="오류-제거하기-weeding-out-errors" style="position:relative;">오류 제거하기 (Weeding out Errors)</h2> <p>언급했던 것처럼, 전환 후 에러 메시지가 뜨는 것은 예상하지 못했습니다. 중요한 점은 실제로 하나하나의 오류를 어떻게 처리할 것인지 결정하는 것입니다. 종종 이것이 합법적인 버그가 될 수 있지만, 때때로 TypeScript에게 무엇을 더 잘하려고 하는지 설명해야 합니다.</p> <h3 id="모듈로부터-import-하기-importing-from-modules" style="position:relative;">모듈로부터 import 하기 (Importing from Modules)</h3> <p>시작할 때 <code>Cannot find name 'require'.</code>, and <code>Cannot find name 'define'.</code> 같은 에러가 많이 나타날 수 있습니다. 이러한 경우, 모듈을 사용할 수 있습니다. 아래의 선언을 통해 TypeScript에게 이러한 기능이 존재한다고 납득시킬 수 있지만</p> <pre data-language="ts">// For Node/CommonJS
declare function require(path: string): any;</pre> <p>또는</p> <pre data-language="ts">// For RequireJS/AMD
declare function define(...args: any[]): any;</pre> <p>이러한 호출을 제거하고 import를 위한 TypeScript 구문을 사용하는 것이 더 낫습니다.</p> <p>먼저, TypeScript <code>module</code> 플래그를 설정함으로써 모듈 시스템을 활성화해야 합니다. 유효한 옵션은 <code>commonjs</code>, <code>amd</code>, <code>system</code>, 그리고 <code>umd</code>입니다.</p> <p>만약 다음과 같은 Node/CommonJS 코드를 갖고 있다면:</p> <pre data-language="js">var foo = require("foo");

foo.doStuff();</pre> <p>또는 다음의 RequireJS/AMD 코드를 갖고 있다면:</p> <pre data-language="js">define(["foo"], function(foo) {
    foo.doStuff();
})</pre> <p>그러면 다음의 TypeScript 코드를 작성해야 합니다:</p> <pre data-language="ts">import foo = require("foo");

foo.doStuff();</pre> <h3 id="선언-파일-시작하기-getting-declaration-files" style="position:relative;">선언 파일 시작하기 (Getting Declaration Files)</h3> <p>만약 TypeScript import로 전환을 시작했다면, <code>Cannot find module 'foo'.</code> 같은 오류가 발생할 수 있습니다. 여기서 문제는 라이브러리를 설명하는 <em>선언 파일</em>이 없을 가능성이 높다는 것입니다. 다행히 해결 방법은 꽤 쉽습니다. 만약 TypeScript가 <code>lodash</code> 같은 패키지에 대해 경고를 발생시키면, 그냥 작성하면 됩니다</p> <pre data-language="shell">npm install -S @types/lodash</pre> <p><code>commonjs</code> 말고 다른 모듈 옵션을 사용한다면, <code>moduleResolution</code>을 <code>node</code>로 설정해야 합니다.</p> <p>그 후, lodash를 문제없이 import 할 수 있고, 정확하게 완성할 수 있습니다.</p> <h3 id="모듈-export-하기-exporting-from-modules" style="position:relative;">모듈 export 하기 (Exporting from Modules)</h3> <p>전형적으로, 모듈을 export 하는 것은<code>exports</code> 혹은 <code>module.exports</code> 같은 값을 프로퍼티에 추가하는 것을 포함합니다. TypeScript는 최상위-레벨의 export 문을 허용합니다. 예를 들어, 함수를 이렇게 export 했다면:</p> <pre data-language="js">module.exports.feedPets = function(pets) {
    // ...
}</pre> <p>그것을 다음과 같이 작성할 수 있습니다:</p> <pre data-language="ts">export function feedPets(pets) {
    // ...
}</pre> <p>때로 exports 객체를 완전히 재작성할 수 있습니다. 아래 예제처럼 즉시 호출하기 위해 이러한 흔한 패턴을 사용합니다:</p> <pre data-language="js">var express = require("express");
var app = express();</pre> <p>전에는 이렇게 작성했을 수 있습니다:</p> <pre data-language="js">function foo() {
    // ...
}
module.exports = foo;</pre> <p>TypeScript에서, 이것을 <code>export =</code> 구문을 사용하여 모델링 할 수 있습니다.</p> <pre data-language="ts">function foo() {
    // ...
}
export = foo;</pre> <h3 id="너무-많은너무-적은-인수-too-manytoo-few-arguments" style="position:relative;">너무 많은/너무 적은 인수 (Too many/too few arguments)</h3> <p>때로 너무 많은/너무 적은 인수를 갖고 있는 함수를 호출할 때가 있습니다. 전형적인 버그이지만, 그러나 몇몇 경우, 어떠한 매개변수를 쓰는 대신 <code>arguments</code> 객체를 사용하는 함수를 선언할 수 있습니다:</p> <pre data-language="js">function myCoolFunction() {
    if (arguments.length == 2 &amp;&amp; !Array.isArray(arguments[1])) {
        var f = arguments[0];
        var arr = arguments[1];
        // ...
    }
    // ...
}

myCoolFunction(function(x) { console.log(x) }, [1, 2, 3, 4]);
myCoolFunction(function(x) { console.log(x) }, 1, 2, 3, 4);</pre> <p>이 경우, TypeScript를 사용해서 호출자에게 함수 오버로드를 사용해 <code>myCoolFunction</code>이 호출되는 방법을 알려주어야 합니다.</p> <pre data-language="ts">function myCoolFunction(f: (x: number) =&gt; void, nums: number[]): void;
function myCoolFunction(f: (x: number) =&gt; void, ...nums: number[]): void;
function myCoolFunction() {
    if (arguments.length == 2 &amp;&amp; !Array.isArray(arguments[1])) {
        var f = arguments[0];
        var arr = arguments[1];
        // ...
    }
    // ...
}</pre> <p><code>myCoolFunction</code>에 오버로드 시그니처 두 개를 추가했습니다. 첫 번째 검사는 <code>myCoolFunction</code>이 (<code>number</code>를 인수로 갖는) 함수와 <code>number</code> 배열을 가진다는 것을 명시합니다. 두 번째 검사는 <code>myCoolFunction</code>이 마찬가지로 함수를 가지고, 나머지 연산자(<code>...nums</code>)를 사용하여 그 외의 인수는 몇개의 인수든 <code>number</code>가 되어야 함을 명시합니다.</p> <h3 id="순차적으로-추가된-프로퍼티-sequentially-added-properties" style="position:relative;">순차적으로 추가된 프로퍼티 (Sequentially Added Properties)</h3> <p>어떤 사람들은 객체를 생성하고 다음과 같이 동적으로 프로퍼티를 추가하는 것이 미관상 더 보기 좋다고 생각합니다:</p> <pre data-language="js">var options = {};
options.color = "red";
options.volume = 11;</pre> <p>TypeScript는 <code>options</code>을 프로퍼티가 없는 <code>{}</code>로 인식했기 때문에 <code>color</code>와 <code>volume</code>을 할당할 수 없다고 할 것입니다. 만약 선언을 리터럴 객체로 변경하면, 오류가 발생하지 않습니다:</p> <pre data-language="ts">let options = {
    color: "red",
    volume: 11
};</pre> <p>또한 <code>options</code>의 타입을 정의해야 하고 객체 리터럴에 대한 타입 단언을 추가해야 합니다.</p> <pre data-language="ts">interface Options { color: string; volume: number }

let options = {} as Options;
options.color = "red";
options.volume = 11;</pre> <p>대신, <code>options</code>이 단순히 타입<code>any</code>를 갖는다고 명시할 수 있는데, 이 방법은 가장 쉬운 방법이지만 가장 적은 장점을 가지고 있습니다.</p> <h3 id="any-object-and-" style="position:relative;">
<code>any</code>, <code>Object</code>, and <code>{}</code>
</h3> <p><code>Object</code>는 대부분의 경우 가장 일반적인 타입이므로, 값이 어떤 프로퍼티도 가질 수 있다고 말하기 위해 <code>Object</code> 나 <code>{}</code>를 사용하고 싶을 수 있습니다. 하지만 <code>any</code>가 가장 유연한 타입이므로, 이러한 경우에는 <strong>실제로 <code>any</code>가 가장 적절한 타입 입니다</strong>.</p> <p>예를 들어, <code>Object</code>를 타입으로 선언한 경우 <code>toLowerCase()</code>같은 메서드를 호출할 수 없습니다. 더 일반적으로 사용한다는 것은 타입으로 더 적은 일을 할 수 있다는 것을 의미하지만, <code>any</code>는 어떤 일이든 할 수 있게 하는 동시에 가장 일반적인 타입이라는 점에서 특별합니다. 그것은 <code>any</code>를 호출하고, 구성하고, 프로퍼티에 접근하는 등의 일을 할 수 있다는 것을 의미합니다. 그러나 <code>any</code>를 사용하면 TypeScript가 제공하는 대부분의 타입 검사와 에디터 지원을 받을 수 없다는 것을 명심하세요.</p> <p>만약 <code>Object</code>와 <code>{}</code>로 결정이 내려지면, <code>{}</code>를 선택해야 합니다. 이 둘은 거의 같지만, 특정 난해한 상황에서 기술적으로 <code>{}</code>이 <code>Object</code>보다 더 일반적인 타입입니다.</p> <h2 id="더-엄격한-체크하기-getting-stricter-checks" style="position:relative;">더 엄격한 체크하기 (Getting Stricter Checks)</h2> <p>TypeScript는 프로그램에 대한 안정성과 분석을 제공하는 특정한 검사를 갖고 있습니다. TypeScript로 코드베이스를 시작하면, 향상된 안전성을 위한 검사를 활성화할 수 있습니다.</p> <h3 id="암시적인-any는-피하기-no-implicit-any" style="position:relative;">암시적인 <code>any</code>는 피하기 (No Implicit <code>any</code>)</h3> <p>어떤 타입이어야 하는지 TypeScript가 파악할 수 없는 경우가 있습니다. 최대한 유연하게 대응하기 위해, 그 자리에 <code>any</code>를 사용하기로 결정할 것입니다. 이것은 마이그레이션에는 좋지만, <code>any</code>를 사용한다는 것은 다른 곳에서 받을 수 있는 어떠한 타입 안정성과 툴링 지원도 받지 못한다는 것을 의미합니다. TypeScript가 이런 부분에 플래그와 에러를 띄울 수 있도록 <code>noImplicitAny</code>옵션을 사용할 수 있습니다.</p> <h3 id="엄격한-null--undefined-검사-strict-null--undefined-checks" style="position:relative;">엄격한 <code>null</code> &amp; <code>undefined</code> 검사 (Strict <code>null</code> &amp; <code>undefined</code> Checks)</h3> <p>기본적으로, TypeScript는 <code>null</code> 과 <code>undefined</code>이 모든 타입의 도메인에 존재한다고 가정합니다. <code>number</code>로 선언된 타입이 <code>null</code> 혹은 <code>undefined</code>이 될 수 있다는 의미입니다. <code>null</code> 과 <code>undefined</code>는 JavaScript 와 TypeScript 에서 빈번한 버그 원인이기 때문에, TypeScript 에는 이러한 문제의 걱정을 덜어주는 <code>strictNullChecks</code> 옵션이 있습니다.</p> <p><code>strictNullChecks</code>가 활성화되면, <code>null</code>과 <code>undefined</code>는 각각 <code>null</code>과 <code>undefined</code>라는 자체 유형을 가져옵니다. 어떤 것이 <code>null</code>이 <em>될 가능성이 있는</em> 상황에서, 원래 타입과 함께 유니언 타입을 사용할 수 있습니다. 예를 들어, 만약 <code>number</code>나 <code>null</code>이 될수 있는 경우, <code>number | null</code>로 타입을 작성할 수 있습니다.</p> <p>TypeScript가 <code>null</code>/<code>undefined</code>라고 생각할 수 있는 값을 갖고 있지만, 타입에 대해 더 잘 알고 있는 경우, 후위 연산자 <code>!</code>를 사용해 다르게 사용할 수 있습니다.</p> <pre data-language="ts">declare var foo: string[] | null;

foo.length;  // error - 'foo' is possibly 'null'

foo!.length; // okay - 'foo!' just has type 'string[]'</pre> <p>앞으로, <code>strictNullChecks</code>를 사용할 때, 의존성이 <code>strictNullChecks</code>를 사용하도록 업데이트 되어야 할 수 있습니다.</p> <h3 id="this에-대한-암시적-any-피하기-no-implicit-any-for-this" style="position:relative;">
<code>this</code>에 대한 암시적 <code>any</code> 피하기 (No Implicit <code>any</code> for <code>this</code>)</h3> <p><code>this</code> 키워드를 클래스 밖에서 사용할 때, 기본적으로 <code>any</code> 타입을 가집니다. 예를 들어, <code>Point</code> 클래스를 상상해 보세요, 그리고 메서드로 추가하고 싶은 함수를 상상해보세요:</p> <pre data-language="ts">class Point {
    constructor(public x, public y) {}
    getDistance(p: Point) {
        let dx = p.x - this.x;
        let dy = p.y - this.y;
        return Math.sqrt(dx ** 2 + dy ** 2);
    }
}
// ...

// 인터페이스를 다시 열어보세요.
interface Point {
    distanceFromOrigin(point: Point): number;
}
Point.prototype.distanceFromOrigin = function(point: Point) {
    return this.getDistance({ x: 0, y: 0});
}</pre> <p>위에서 언급 한 것과 같은 문제가 있습니다 - <code>getDistance</code>의 철자를 틀리기 쉽고 에러가 발생하지 않았습니다. 이러한 이유 때문에, TypeScript 에 <code>noImplicitThis</code> 옵션이 있습니다. 이 옵션이 설정되면, TypeScript는 <code>this</code>가 명시적 타입 없이 사용될 때 에러를 발생시킵니다. 해결책은 인터페이스나 함수 자체에서 명시적 타입을 전달하기 위해 <code>this</code>-매개변수를 사용하는 것입니다:</p> <pre data-language="ts">Point.prototype.distanceFromOrigin = function(this: Point, point: Point) {
    return this.getDistance({ x: 0, y: 0});
}</pre><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2012-2023 Microsoft<br>Licensed under the Apache License, Version 2.0.<br>
    <a href="https://www.typescriptlang.org/ko/docs/handbook/migrating-from-javascript.html" class="_attribution-link">https://www.typescriptlang.org/ko/docs/handbook/migrating-from-javascript.html</a>
  </p>
</div>
