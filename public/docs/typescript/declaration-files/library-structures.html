<h1>Library Structures</h1>
<h1 id="개요-overview" style="position:relative;">개요 (Overview)</h1> <p>일반적으로, 선언 파일을 <em>구조화</em>하는 방법은 라이브러리를 사용하는 방법에 따라 다릅니다. JavaScript에서 사용할 라이브러리를 제공하는 방법은 여러 가지가 있고, 이에 맞추어 선언 파일을 작성해야 합니다. 이 가이드는 일반적인 라이브러리 패턴을 식별하는 방법과, 그 패턴에 상응하는 선언 파일을 작성하는 방법에 대해 다룹니다.</p> <p>주요 라이브러리 각각의 구조화 패턴 유형은 <a href="https://www.typescriptlang.org/docs/handbook/declaration-files/templates.html">템플릿</a> 섹션에 있습니다. 이 템플릿으로 시작하면 더 빠르게 진행할 수 있습니다.</p> <h1 id="라이브러리-종류-식별하기-identifying-kinds-of-libraries" style="position:relative;">라이브러리 종류 식별하기 (Identifying Kinds of Libraries)</h1> <p>첫 번째로, TypeScript 선언 파일이 나타낼 수 있는 라이브러리 종류를 다뤄보겠습니다. 각 종류의 라이브러리를 <em>사용하는</em> 방법과, <em>작성하는</em> 방법, 그리고 실제 라이브러리들의 예제를 볼 것입니다.</p> <p>라이브러리의 구조를 식별하는 것은 선언 파일을 작성하는 첫 단계입니다. <em>사용법</em>과 <em>코드</em>를 기반으로 구조를 식별하는 방법에 대한 힌트를 제공합니다. 라이브러리의 문서와 구성에 따라서, 어떤 건 다른 것보다 훨씬 쉬울 수 있습니다. 본인에게 더 편한 것을 사용할 것을 추천합니다.</p> <h2 id="어떤-사항을-고려해야-하는가-what-should-you-look-for" style="position:relative;">어떤 사항을 고려해야 하는가? (What should you look for?)</h2> <p>라이브러리를 사용하기 전에, 다음 사항을 고려해 볼 수 있습니다.</p> <ol> <li> <p>라이브러리를 다운로드하는 방식이 무엇인가?</p> <p>예를 들어, npm으로만 다운로드 할 수 있는가? 아니면 CDN 에서만 다운로드 할 수 있는가?</p> </li> <li> <p>라이브러리를 임포트하는 방식이 무엇인가?</p> <p>전역 객체를 추가하는 방식인가? 아니면 <code>require</code> 또는 <code>import</code>/<code>export</code> 구문을 사용하는 방식인가?</p> </li> </ol> <h2 id="여러-종류의-라이브러리에-대한-간단한-샘플" style="position:relative;">여러 종류의 라이브러리에 대한 간단한 샘플</h2> <h2 id="모듈형-라이브러리-modular-libraries" style="position:relative;">모듈형 라이브러리 (Modular Libraries)</h2> <p>어떤 라이브러리는 모듈 로더 환경에서만 동작합니다. 예를 들어, <code>express</code>는 Node.js에서만 동작하고 반드시 CommonJS의 <code>require</code> 함수로 로드되어야 합니다.</p> <p>ECMAScript 2015 (ES2015, ECMAScript 6, ES6로도 잘 알려진), CommonJS와 RequireJS는 <em>모듈</em>을 <em>importing</em>하는 비슷한 개념을 가지고 있습니다. JavaScript의 CommonJS (Node.js)를 예를 들면, 다음과 같이 작성합니다</p> <pre data-language="js">var fs = require("fs");</pre> <p>TypeScript나 ES6에서는, <code>import</code> 키워드가 같은 목적을 제공합니다:</p> <pre data-language="ts">import fs = require("fs");</pre> <p>일반적으로 모듈형 라이브러리의 문서에서 다음 코드들 중 하나를 볼 수 있습니다:</p> <pre data-language="js">var someLib = require('someLib');</pre> <p>혹은</p> <pre data-language="js">define(..., ['someLib'], function(someLib) {

});</pre> <p>전역 모듈과 마찬가지로 UMD 모듈의 문서에서도 이 예제들을 볼 수 있으므로, 코드나 문서를 반드시 확인하세요.</p> <h3 id="코드에서-모듈-라이브러리-식별하기-identifying-a-module-library-from-code" style="position:relative;">코드에서 모듈 라이브러리 식별하기 (Identifying a Module Library from Code)</h3> <p>모듈형 라이브러리는 일반적으로 다음 중 몇 가지를 반드시 가지고 있습니다:</p> <ul> <li>
<code>require</code> 혹은 <code>define</code>에 대한 무조건적인 호출</li> <li>
<code>import * as a from 'b';</code> 혹은 <code>export c;</code> 같은 선언문</li> <li>
<code>exports</code> 혹은 <code>module.exports</code>에 대한 할당</li> </ul> <p>다음은 거의 갖지 않습니다:</p> <ul> <li>
<code>window</code> 혹은 <code>global</code> 프로퍼티 할당</li> </ul> <h3 id="모듈을-위한-템플릿-templates-for-modules" style="position:relative;">모듈을 위한 템플릿 (Templates For Modules)</h3> <p>모듈을 위한 네 가지 템플릿이 있습니다.</p> <ul> <li><a href="https://www.typescriptlang.org/docs/handbook/declaration-files/templates/module-d-ts.html"><code>module.d.ts</code></a></li> <li><a href="https://www.typescriptlang.org/docs/handbook/declaration-files/templates/module-class-d-ts.html"><code>module-class.d.ts</code></a></li> <li><a href="https://www.typescriptlang.org/docs/handbook/declaration-files/templates/module-function-d-ts.html"><code>module-function.d.ts</code></a></li> <li><a href="https://www.typescriptlang.org/docs/handbook/declaration-files/templates/module-plugin-d-ts.html"><code>module-plugin.d.ts</code></a></li> </ul> <p>각각이 어떻게 동작하는지에 대한 개요는 <a href="https://www.typescriptlang.org/docs/handbook/declaration-files/templates/module-d-ts.html"><code>module.d.ts</code></a>를 참조하세요.</p> <p>만약 모듈을 함수처럼 <em>호출</em>할 수 있으면 <a href="https://www.typescriptlang.org/docs/handbook/declaration-files/templates/module-function-d-ts.html"><code>module-function.d.ts</code></a>을 사용하세요:</p> <pre data-language="js">const x = require("foo");
// 참고: 함수로 'x'를 호출
const y = x(42);</pre> <p>만약 모듈이 <code>new</code>를 사용하여 <em>생성</em>될 수 있다면 <a href="https://www.typescriptlang.org/docs/handbook/declaration-files/templates/module-class-d-ts.html"><code>module-class.d.ts</code></a>를 사용하세요:</p> <pre data-language="js">const x = require("bar");
// 참고: 'new' 연산자를 import된 변수에 사용
const y = new x("hello");</pre> <p>임포트 되었을 때 다른 모듈에 수정사항을 만드는 모듈을 사용한다면, <a href="https://www.typescriptlang.org/docs/handbook/declaration-files/templates/module-plugin-d-ts.html"><code>module-plugin.d.ts</code></a> 템플릿을 사용하세요:</p> <pre data-language="js">const jest = require("jest");
require("jest-matchers-files");</pre> <h2 id="전역-라이브러리-global-libraries" style="position:relative;">전역 라이브러리 (Global Libraries)</h2> <p><em>전역</em> 라이브러리는 전역 스코프 (즉, <code>import</code> 형식을 사용하지 않음)에서 접근 가능한 라이브러리입니다. 많은 라이브러리는 사용을 위해 간단히 하나 이상의 전역 변수를 노출합니다. 예를 들어, <a href="https://jquery.com/">jQuery</a>를 사용한다면, <code>$</code> 변수를 참조해서 사용할 수 있습니다:</p> <pre data-language="ts">$(() =&gt; { console.log('hello!'); } );</pre> <p>HTML 스크립트 태그로 라이브러리를 사용하는 방법은 라이브러리 문서에서 지침을 볼 수 있습니다:</p> <pre data-language="html">&lt;script src="http://a.great.cdn.for/someLib.js"&gt;&lt;/script&gt;</pre> <p>오늘날, 대부분의 전역에서 접근 가능한 유명 라이브러리들은 실제로 UMD 라이브러리로 작성되어 있습니다 (아래를 참조). UMD 라이브러리 문서는 전역 라이브러리 문서와 구별하기 어렵습니다. 전역 선언 파일을 작성하기 전에, 실제로는 UMD가 아닌지 확인하십시오.</p> <h3 id="코드에서-전역-라이브러리-식별하기-identifying-a-global-library-from-code" style="position:relative;">코드에서 전역 라이브러리 식별하기 (Identifying a Global Library from Code)</h3> <p>전역 라이브러리 코드는 대게 엄청 간단합니다. 전역 “Hello, world” 라이브러리는 다음과 같습니다:</p> <pre data-language="js">function createGreeting(s) {
    return "Hello, " + s;
}</pre> <p>혹은 다음과 같습니다:</p> <pre data-language="js">// Web
window.createGreeting = function (s) {
  return "Hello, " + s;
};

// Node
global.createGreeting = function (s) {
  return "Hello, " + s;
};

// Potentially any runtime
globalThis.createGreeting = function (s) {
  return "Hello, " + s;
};</pre> <p>전역 라이브러리의 코드를 보면, 보통 다음을 볼 수 있습니다:</p> <ul> <li>최상위 레벨 <code>var</code>문 이나 <code>function</code>선언</li> <li>하나 이상의 <code>window.someName</code> 할당</li> <li>DOM 인터페이스 <code>document</code> 혹은 <code>window</code>가 존재한다고 가정</li> </ul> <p>다음은 볼 수 <em>없습니다</em>:</p> <ul> <li>
<code>require</code> 이나 <code>define</code> 같은 모듈 로더 검사 혹은 사용</li> <li>
<code>var fs = require("fs");</code> 형태의 CommonJS/Node.js-스타일 import</li> <li>
<code>define(...)</code> 호출</li> <li>라이브러리를 <code>require</code> 혹은 import하는 방법에 대해 설명하는 문서</li> </ul> <h3 id="전역-라이브러리-예제-examples-of-global-libraries" style="position:relative;">전역 라이브러리 예제 (Examples of Global Libraries)</h3> <p>전역 라이브러리를 UMD 라이브러리로 바꾸는게 쉽기 때문에, 전역 스타일로 작성한 인기 라이브러리는 거의 없습니다. 하지만, 크기가 작고 DOM이 필요한 (혹은 의존성이 <em>없는</em>) 라이브러리는 여전히 전역입니다.</p> <h3 id="전역-라이브러리-템플릿-global-library-template" style="position:relative;">전역 라이브러리 템플릿 (Global Library Template)</h3> <p>템플릿 파일 <a href="templates/global.d.ts.md"><code>global.d.ts</code></a>은 예제 라이브러리 <code>myLib</code>를 정의합니다. <a href="#preventing-name-conflicts">“이름 충돌 방지” 각주</a>를 반드시 읽어보세요.</p> <h2 id="umd" style="position:relative;"><em>UMD</em></h2> <p><em>UMD</em> 모듈은 모듈로 (import를 통해) 사용할 수 있고 혹은 전역으로도 (모듈 로더 없는 환경에서 실행될 때) 사용할 수 있습니다. <a href="http://momentjs.com/">Moment.js</a> 같은 많은 유명한 라이브러리들은 이 방법으로 작성되었습니다. 예를 들어, Node.js나 RequireJS를 사용하면, 다음과 같이 작성합니다:</p> <pre data-language="ts">import moment = require("moment");
console.log(moment.format());</pre> <p>반면 바닐라 브라우저 환경에서는 다음과 같이 쓸 수 있습니다:</p> <pre data-language="js">console.log(moment.format());</pre> <h3 id="umd-라이브러리-식별하기-identifying-a-umd-library" style="position:relative;">UMD 라이브러리 식별하기 (Identifying a UMD library)</h3> <p><a href="https://github.com/umdjs/umd">UMD modules</a>은 모듈 로더 환경 유무를 검사합니다. 이는 다음과 같이 보이는 찾기 쉬운 패턴입니다:</p> <pre data-language="js">(function (root, factory) {
    if (typeof define === "function" &amp;&amp; define.amd) {
        define(["libName"], factory);
    } else if (typeof module === "object" &amp;&amp; module.exports) {
        module.exports = factory(require("libName"));
    } else {
        root.returnExports = factory(root.libName);
    }
}(this, function (b) {</pre> <p>만약 라이브러리 코드, 특히 파일 상단에서 <code>typeof define</code>, <code>typeof window</code> 혹은 <code>typeof module</code>에 대한 테스트를 보았다면, 거의 대부분 UMD 라이브러리입니다.</p> <p>UMD 라이브러리 문서에서는 <code>require</code>를 보여주는 “Node.js에서 사용하기” 예제를 종종 설명하고 “브라우저에서 사용하기” 예제에서는 <code>&lt;script&gt;</code> 태그를 사용해서 스크립트를 로드하는 방법을 보여줍니다.</p> <h3 id="umd-라이브러리-예제-examples-of-umd-libraries" style="position:relative;">UMD 라이브러리 예제 (Examples of UMD libraries)</h3> <p>유명한 라이브러리 대부분은 UMD 패키지로 사용할 수 있습니다. 예로는 <a href="https://jquery.com/">jQuery</a>, <a href="http://momentjs.com/">Moment.js</a>, <a href="https://loadash.com/">loadash</a> 등 더 많이 있습니다.</p> <h3 id="템플릿-template" style="position:relative;">템플릿 (Template)</h3> <p><a href="https://www.typescriptlang.org/docs/handbook/declaration-files/templates/module-plugin-d-ts.html"><code>module-plugin.d.ts</code></a> 템플릿을 사용하세요.</p> <h1 id="span-idconsuming-dependencies--의존성-사용하기-consuming-dependencies" style="position:relative;">
 의존성 사용하기 (Consuming Dependencies)</h1> <p>라이브러리가 몇 가지 의존성을 가지고 있을 수 있습니다. 이번 섹션에서는 선언 파일 안에 의존성을 import 하는 방법을 설명합니다.</p> <h2 id="전역-라이브러리-의존성-dependencies-on-global-libraries" style="position:relative;">전역 라이브러리 의존성 (Dependencies on Global Libraries)</h2> <p>만약 라이브러리가 전역 라이브러리에 의존성이 있다면, <code>/// &lt;reference types="..." /&gt;</code> 디렉티브를 사용하세요:</p> <pre data-language="ts">/// &lt;reference types="someLib" /&gt;

function getThing(): someLib.thing;</pre> <h2 id="모듈-의존성-dependencies-on-modules" style="position:relative;">모듈 의존성 (Dependencies on Modules)</h2> <p>만약 라이브러리가 모듈에 의존성이 있다면, <code>import</code>문을 사용하세요:</p> <pre data-language="ts">import * as moment from "moment";

function getThing(): moment;</pre> <h2 id="umd-라이브러리-의존성-dependencies-on-umd-libraries" style="position:relative;">UMD 라이브러리 의존성 (Dependencies on UMD libraries)</h2> <h3 id="전역-라이브러리에서-from-a-global-library" style="position:relative;">전역 라이브러리에서 (From a Global Library)</h3> <p>만약 전역 라이브러리가 UMD 모듈에 의존성이 있다면, <code>/// &lt;reference types</code> 디렉티브를 사용하세요:</p> <pre data-language="ts">/// &lt;reference types="moment" /&gt;

function getThing(): moment;</pre> <h3 id="모듈이나-umd-라이브러리에서-from-a-module-or-umd-library" style="position:relative;">모듈이나 UMD 라이브러리에서 (From a Module or UMD Library)</h3> <p>만약 모듈이나 UMD 라이브러리가 UMD 라이브러리에 의존성이 있다면, <code>import</code>문을 사용하세요:</p> <pre data-language="ts">import * as someLib from 'someLib';</pre> <p>UMD 라이브러리에 대한 의존성 선언에 <code>/// &lt;reference</code> 디렉티브를 사용하지 <em>마세요</em>!</p> <h1 id="각주-footnotes" style="position:relative;">각주 (Footnotes)</h1> <h2 id="span-idpreventing-name-conflicts--이름-충돌-방지하기-preventing-name-conflicts" style="position:relative;">
 이름 충돌 방지하기 (Preventing Name Conflicts)</h2> <p>전역 선언 파일을 작성할 때, 전역 스코프에 많은 타입을 정의할 수 있다는 점을 유의하세요. 많은 선언 파일이 프로젝트 내에 있을 때, 해결할 수 없는 이름 충돌이 발생할 수 있으므로 이를 사용하지 않는 것이 좋습니다.</p> <p>따라야 하는 간단한 규칙은 라이브러리가 정의한 전역 변수가 무엇이든 타입을 <em>네임스페이스</em>로 정의하는 것입니다. 예를 들어, 만약 라이브러리가 전역 값 ‘cats’를 정의하면, 다음과 같이 작성하고</p> <pre data-language="ts">declare namespace cats {
    interface KittySettings { }
}</pre> <p>이렇게 하지는 <em>마세요</em></p> <pre data-language="ts">// 최상위-레벨에서
interface CatsKittySettings { }</pre> <p>이 가이드는 선언 파일 사용자가 중단하지 않고 라이브러리를 UMD로 전환할 수 있도록 합니다.</p> <h2 id="span-idthe-impact-of-es6-on-module-plugins--es6가-모듈-플러그인에-미치는-영향-the-impact-of-es6-on-module-plugins" style="position:relative;">
 ES6가 모듈 플러그인에 미치는 영향 (The Impact of ES6 on Module Plugins)</h2> <p>어떤 플러그인은 기존 모듈에 최상위 export를 추가하거나 수정합니다. CommonJS와 다른 로더에서는 허용되지만, ES6 모듈은 불변하다고 간주되기에 이 패턴은 불가능합니다. 왜냐하면 TypeScript는 로더에 구애받지 않기에, 이 정책이 컴파일-시간에 적용되지 않지만, ES6 모듈 로더로 전환하려는 개발자는 알고 있어야 합니다.</p> <h2 id="모듈-호출-시그니처에-es6가-미치는-영향-the-impact-of-es6-on-module-call-signatures" style="position:relative;">모듈 호출 시그니처에 ES6가 미치는 영향 (The Impact of ES6 on Module Call Signatures)</h2> <p>Express와 같은 많은 유명한 라이브러리들은 import 될 때 호출 가능한 함수를 노출합니다. 예를 들어, 일반적인 Express 사용법은 다음과 같습니다:</p> <pre data-language="ts">import exp = require("express");
var app = exp();</pre> <p>ES6 모듈 로더에서, 최상위-레벨 객체(여기에서는 <code>exp</code>로 import)는 프로퍼티만 가질 수 있습니다; 최상위-레벨 모듈 객체는 <em>절대</em> 호출할 수 없습니다. 가장 일반적인 해결책은 호출 가능/생성 가능 객체를 <code>default</code> export로 정의하는 것입니다; 어떤 모듈 로더 shims은 자동으로 이 상황을 감지하고 최상위-레벨 객체를 <code>default</code> export로 바꿉니다. 만약 <code>tsconfig.json</code> 파일에 <a href="https://www.typescriptlang.org/tsconfig/#esModuleInterop"><code>"esModuleInterop": true</code></a> 라고 되어 있으면, Typescript가 위의 사항을 자동으로 처리합니다.</p><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2012-2023 Microsoft<br>Licensed under the Apache License, Version 2.0.<br>
    <a href="https://www.typescriptlang.org/ko/docs/handbook/declaration-files/library-structures.html" class="_attribution-link">https://www.typescriptlang.org/ko/docs/handbook/declaration-files/library-structures.html</a>
  </p>
</div>
